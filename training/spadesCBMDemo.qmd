---
author: 
  - "CÃ©line Boisvenue"
  - "Camille Giuliano"
date: last-modified
editor_options:
  chunk_output_type: console
editor:
  mode: source
bibliography: references/references.bib
execute:
  tidy: false
  warning: false
  message: false
  error: false
  cache: true
  eval: false
---

# Forest Carbon Modelling in SpaDES with `setupProject`

::: {.callout-tip appearance="simple"}
See \[Barebones R script\] for the code shown in this chapter
:::

```{r setup}
#| include: false
#| eval: true
#| cache: false
#| purl: false

knitr::opts_chunk$set(tidy = FALSE, 
                      warning = FALSE, 
                      message = FALSE, 
                      error = FALSE)

# truncate text output
hook_output <- knitr::knit_hooks$get("output")

knitr::knit_hooks$set(output = function(x, options) {
  if (!is.null(n <- options$outlines)) {
    x <- xfun::split_lines(x)
    if (length(x) > n) {
      # truncate the output
      x <- c(head(x, n), "....\n")
    }
    x <- paste(x, collapse = "\n")
  }
  hook_output(x, options)
})

if (Sys.getenv("USERNAME") == "GHA") {
  googledrive::drive_auth(path = Sys.getenv("GOOGLE_APP_CREDENTIALS"))
}

qmdPath <- normalizePath(getwd(), winslash = "/")

if (!interactive()) { 
  dir.create("~/SpaDES_book/spadesCBMDemo", recursive = TRUE)
  knitr::opts_knit$set(root.dir = "~/SpaDES_book/spadesCBMDemo")
}
```

spadesCBM is a modular, transparent, and spatially explicit implementation of the logic, pools structure, equations, and default assumptions of the Carbon Budget Model of the Canadian Forest Sector [CBM](https://natural-resources.canada.ca/climate-change/climate-change-impacts-forests/carbon-accounting/carbon-budget-model/13107).
It applies the science presented in @kurz2009 in a similar way to the
simulations in @boisvenue2016 and @boisvenue2022 but calls Python
functions for annual processes. These functions are, like much of
modelling-based science, continuously under development.

## spadesCBM Modules

Four modules need to be run in tandem for a spadesCBM simulation (see section XX
for how these relate in SpaDES). The first module *CBM_defaults* reads in
defaults CBM parameters for Canada.  The second module *CBM_dataPrep_SK* is
a data preparation SpaDES module, where input data and spatial layers are
assembled and prepared for a specific study area (the *SK*
indicates the specific study area or scenario, in this case it is a small raster in Saskatchewan). In spadesCBM, as in CBM, growth curves are
the main change-agent. The third module *CBM_vol2biomass* translates user-provided growth curves ($m^3/ha$) into increments for specific above ground carbon pools (metric tonnes of carbon/ha) using @boudewyn2007 models to which we added a smoothing algorithm. These three modules provide the inputs to the *CBM_core* module where processes are applied on a yearly time step. This modularity enables users to access and change default parameters, change inputs, and assess the impact of these changes. We are working on some implementations of this modularity and making these available to the community.
We hope others will do the same. A manual describing spadesCBM in detail is forthcoming. The link to the manual will be posted here.

Several core utilities to spadesCBm are provided by the [`CBMutils`](https://github.com/PredictiveEcology/CBMutils@development) package, available on GitHub. Active development in `CBMutils` and all `spadesCBM` modules is underway.

## Setup

In this example, we will setup the workflow using `setupProject` from the
[`SpaDES.project`](https://spades-project.predictiveecology.org/) package and
current versions of the spadesCBM modules.

``` {r}        
projectPath <- "~/spadesCBMpython"
dir.create(projectPath, recursive = TRUE, showWarnings = FALSE)
setwd(projectPath)

repos <- unique(c("predictiveecology.r-universe.dev", getOption("repos")))
install.packages("SpaDES.project",
                 repos = repos)

# start in 1998, and end in 2000
times <- list(start = 1998, end = 2000)

out <- SpaDES.project::setupProject(
  Restart = TRUE,
  useGit = "PredictiveEcology", # a developer sets and keeps this = TRUE
  overwrite = TRUE, # a user who wants to get latest modules sets this to TRUE
  paths = list(projectPath = projectPath),

  options = options(
    repos = c(repos = repos),
    Require.cloneFrom = Sys.getenv("R_LIBS_USER"),
    reproducible.destinationPath = "inputs",
    ## These are for speed
    reproducible.useMemoise = TRUE,
    # Require.offlineMode = TRUE,
    spades.moduleCodeChecks = FALSE
  ),
  modules =  c("PredictiveEcology/CBM_defaults@training",
               "PredictiveEcology/CBM_dataPrep_SK@training",
               "PredictiveEcology/CBM_vol2biomass@training",
               "PredictiveEcology/CBM_core@training"),
  times = times,
  require = c("SpaDES.core", "reticulate",
              "PredictiveEcology/libcbmr", "data.table"),

  parameters = list(
    CBM_defaults = list(
      .useCache = TRUE
    ),
    CBM_dataPrep_SK = list(
      .useCache = TRUE
    ),
    CBM_vol2biomass = list(
      .useCache = TRUE
    )
  ),

  ret = {
    reticulate::use_virtualenv(virtualenv = "r-reticulate")
    reticulate::py_install("libcbm", envname = "r-reticulate")
  },

  #### begin manually passed inputs #########################################
  ## define the  study area.
  masterRaster = {
    extent = terra::ext(c(xmin = -687696, xmax = -681036, ymin = 711955, ymax = 716183))
    masterRaster <- terra::rast(extent, res = 30)
    terra::crs(masterRaster) <- "PROJCRS[\"Lambert_Conformal_Conic_2SP\",\n    BASEGEOGCRS[\"GCS_GRS_1980_IUGG_1980\",\n        DATUM[\"D_unknown\",\n            ELLIPSOID[\"GRS80\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1,\n                    ID[\"EPSG\",9001]]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]],\n    CONVERSION[\"Lambert Conic Conformal (2SP)\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",-95,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",77,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"northing\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]"
    masterRaster[] <- rep(1, terra::ncell(masterRaster))
    mr <- reproducible::prepInputs(url = "https://drive.google.com/file/d/1zUyFH8k6Ef4c_GiWMInKbwAl6m6gvLJW/view?usp=drive_link",
                                   destinationPath = "inputs",
                                   to = masterRaster,
                                   method = "near")
    mr[mr[] == 0] <- NA
    mr
  },
  ## Give the location of the disturbance rasters.
  disturbanceRasters = "https://drive.google.com/file/d/12YnuQYytjcBej0_kdodLchPg7z9LygCt/view?usp=drive_link",

  # Restart = getOption("SpaDES.project.Restart", FALSE),

  outputs = as.data.frame(expand.grid(objectName = c("cbmPools", "NPP"),
                                      saveTime = sort(c(times$start,
                                                        times$start +
                                                          c(1:(times$end - times$start))
                                      )))),

)

out$loadOrder <- unlist(out$modules)

```

::: {.callout-important}
## Google account needed for this example

Like the LandR example, you will need to access some of the data using the `googledrive` R package (part of the `tidyverse` family). During the `simInit()` (or `simInitAndSpades()`) call R will prompt you to either choose a previously authenticated account (if you have previously used `googledrive`) or to open a browser window and authenticate. If this doesn't work, try this workaround:

```{r setupGoogle}
#| eval: false
#| results: hide
#| code-fold: false
#| code-summary: "Show code"
install.packages(c("googledrive", "httpuv"), repos = repos)

googledriveAuthPath <- "~/SpaDES_book/googledrive_auth_cache"
dir.create(googledriveAuthPath, showWarnings = FALSE)
googledrive::drive_auth(cache = "~/SpaDES_book/googledrive_auth_cache")

```

Make sure you give `tidyverse` read/write access to your files:

![](assets/img/gdriveauth.png){fig-align="center" width="467"}
:::

::: {.callout-important}
## Python is required for this example

The *CBM_core* module requires Python >=3.9 and <=3.12.7.

If a suitable version of Python does not already exist on your computer,
`setupProject` will use the [`reticulate`](https://rstudio.github.io/reticulate/) package to install it using the [pyenv](https://github.com/pyenv/pyenv) or [pyenv-win](https://github.com/pyenv-win/pyenv-win) project.

If you are using a Windows computer with Git installed, the `pyenv-win` tool will be acquired and managed directly by `reticulate`. If you are using a Windows computer without Git installed, you will be prompted to allow the `pyenv-win` tool to be downloaded directly from Github to your local user application data directory (`tools::R_user_dir("r-spadesCBM")`).

If the Python installation process fails or you would prefer to manually install Python, it can be downloaded directly from [python.org/downloads](https://python.org/downloads).

:::

## Run Simulation

Now that our project is set up, we can run our simulation.

```{r}         
simPython <- do.call(SpaDES.core::simInitAndSpades, out)
```

## Looking at results
### Outputs
In our `setupProject()` call, we defined certain outputs to be saved. You can see a list of these outputs your simulation has created, their name, and where they were saved by using the `outputs()` function like so:
```{r} 
> outputs(simPython)

  objectName saveTime                                                                      file     
1   cbmPools     1998 ~/spadesCBMpython/outputs/cbmPools_year1998.rds saveRDS    base  TRUE
2        NPP     1998      ~/spadesCBMpython/outputs/NPP_year1998.rds saveRDS    base  TRUE
3   cbmPools     1999 ~/spadesCBMpython/outputs/cbmPools_year1999.rds saveRDS    base  TRUE
4        NPP     1999      ~/spadesCBMpython/outputs/NPP_year1999.rds saveRDS    base  TRUE
5   cbmPools     2000 ~/spadesCBMpython/outputs/cbmPools_year2000.rds saveRDS    base  TRUE
6        NPP     2000      ~/spadesCBMpython/outputs/NPP_year2000.rds saveRDS    base  TRUE

```

In our simulation, as defined in `setupProject()`, we have `cbmPools.rds` and `NPP.rds` files for each simulation year. These files will be found in the `outputs` folder created in the project directory defined in our setup. 

### Plotting
We can also visualize some results using some plotting functions sourced from our modules. 

``` {r}        
carbonOutPlot(
  emissionsProducts = simPython$emissionsProducts
  ) # This plots yearly forest products and yearly emissions for the length of the simulation

 barPlot(
   cbmPools = simPython$cbmPools
   ) # This plots the carbon proportions above and below ground each simulation year

NPPplot(
  spatialDT = simPython$spatialDT,
  NPP = simPython$NPP,
  masterRaster = simPython$masterRaster
  ) # This plots the per-pixel average net primary production 

spatialPlot(
  cbmPools = simPython$cbmPools,
  years = 2000,
  masterRaster = simPython$masterRaster,
  spatialDT = simPython$spatialDT
  ) # this plots the Total Carbon per pixel for the final simulation year

```

You can also schedule these plots within a module so that they are automatically generated at the end of the simulation. In the `CBM_core.R` module, you can find these plots already defined in the `doEvent.CBM_core()` function.  

```{r}
plot = {
      if (time(sim) != start(sim)) {
        retry(quote({
          carbonOutPlot(
            emissionsProducts = sim$emissionsProducts
          )
        }), retries = 2)

        barPlot(
          cbmPools = sim$cbmPools
        )

        NPPplot(
          spatialDT = sim$spatialDT,
          NPP = sim$NPP,
          masterRaster = sim$masterRaster
        )
      }

      spatialPlot(
        cbmPools = sim$cbmPools,
        years = time(sim),
        masterRaster = sim$masterRaster,
        spatialDT = sim$spatialDT
      )
    },
```

If you look a few lines above where the plots are defined in the module (on line 186) you will find a line of code currently commented out. If this line was being read, this would schedule the plotting event at the very end of the simulation (i.e. `eventPriority = 12`). 

``` {r}        
# sim <- scheduleEvent(sim, end(sim), "CBM_core", "plot",  eventPriority = 12)
```

You can remove the comment # to add this line of code back in, save, and rerun your simulation. The plotting is now a scheduled event in this module. The model should now automatically run the plotting functions above.

## Changing the length of the simulation
We currently are only running our simulation for 3 years, from 1998 to 2000. You can confirm that our simulation ends in 2000 like so:
```{r}
> time(simPython)
[1] 2000
attr(,"unit")
[1] "year"

```

However, we have access to disturbance rasters until 2011. We can easily change the length of our simulation to a later year as long as we have the matching disturbance raster. If we wanted to extend our simulation to 2002 we could do so like this:
```{r}
end(simPython) <- 2002
```

We can then extend `simPython` to 2002 and create `simPython2`
```{r}
simPython2 <- spades(simPython)
```

With `simPython2`, you can look at your results and generate plots in the same way as we did with the 3 year simulation `simPython` earlier. 

## Changing study area

Changing study areas requires that all the inputs be available. In spadesCBM, that means growth curves where (i.e., which pixel) they apply, and what is the leading species for that stand, an age raster, an ecozone raster, and information about disturbances (i.e., disturbance rasters) for all the years of simulation. Since we have that information for the province of Saskatchewan, we can change the definition of the study area in our `setupProject` script.

## Barebones script
```{r}
projectPath <- "~/spadesCBMpython"
dir.create(projectPath, recursive = TRUE, showWarnings = FALSE)
setwd(projectPath)

repos <- unique(c("predictiveecology.r-universe.dev", getOption("repos")))
install.packages("SpaDES.project",
                 repos = repos)

# start in 1998, and end in 2000
times <- list(start = 1998, end = 2000)

out <- SpaDES.project::setupProject(
  Restart = TRUE,
  useGit = "PredictiveEcology", # a developer sets and keeps this = TRUE
  overwrite = TRUE, # a user who wants to get latest modules sets this to TRUE
  paths = list(projectPath = projectPath),

  options = options(
    repos = c(repos = repos),
    Require.cloneFrom = Sys.getenv("R_LIBS_USER"),
    reproducible.destinationPath = "inputs",
    ## These are for speed
    reproducible.useMemoise = TRUE,
    # Require.offlineMode = TRUE,
    spades.moduleCodeChecks = FALSE
  ),
  modules =  c("PredictiveEcology/CBM_defaults@training",
               "PredictiveEcology/CBM_dataPrep_SK@training",
               "PredictiveEcology/CBM_vol2biomass@training",
               "PredictiveEcology/CBM_core@training"),
  times = times,
  require = c("SpaDES.core", "reticulate",
              "PredictiveEcology/libcbmr", "data.table"),

  parameters = list(
    CBM_defaults = list(
      .useCache = TRUE
    ),
    CBM_dataPrep_SK = list(
      .useCache = TRUE
    ),
    CBM_vol2biomass = list(
      .useCache = TRUE
    )
  ),

  ret = {
    reticulate::use_virtualenv(virtualenv = "r-reticulate")
    reticulate::py_install("libcbm", envname = "r-reticulate")
  },

  #### begin manually passed inputs #########################################
  ## define the  study area.
  masterRaster = {
    extent = terra::ext(c(xmin = -687696, xmax = -681036, ymin = 711955, ymax = 716183))
    masterRaster <- terra::rast(extent, res = 30)
    terra::crs(masterRaster) <- "PROJCRS[\"Lambert_Conformal_Conic_2SP\",\n    BASEGEOGCRS[\"GCS_GRS_1980_IUGG_1980\",\n        DATUM[\"D_unknown\",\n            ELLIPSOID[\"GRS80\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1,\n                    ID[\"EPSG\",9001]]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]],\n    CONVERSION[\"Lambert Conic Conformal (2SP)\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",-95,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",77,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"northing\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]"
    masterRaster[] <- rep(1, terra::ncell(masterRaster))
    mr <- reproducible::prepInputs(url = "https://drive.google.com/file/d/1zUyFH8k6Ef4c_GiWMInKbwAl6m6gvLJW/view?usp=drive_link",
                                   destinationPath = "inputs",
                                   to = masterRaster,
                                   method = "near")
    mr[mr[] == 0] <- NA
    mr
  },
  ## Give the location of the disturbance rasters.
  disturbanceRasters = "https://drive.google.com/file/d/12YnuQYytjcBej0_kdodLchPg7z9LygCt/view?usp=drive_link",

  # Restart = getOption("SpaDES.project.Restart", FALSE),

  outputs = as.data.frame(expand.grid(objectName = c("cbmPools", "NPP"),
                                      saveTime = sort(c(times$start,
                                                        times$start +
                                                          c(1:(times$end - times$start))
                                      )))),

)

out$loadOrder <- unlist(out$modules)

# Run
simPython <- do.call(SpaDES.core::simInitAndSpades, out)
#INSERT ANY OTHER CODE HERE
## e.g. the example to change the start or end time, and the one to change the masterRaster. 

```
