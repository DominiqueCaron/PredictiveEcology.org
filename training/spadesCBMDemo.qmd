---
author: 
  - "CÃ©line Boisvenue"
  - "Camille Giuliano"
date: last-modified
editor_options:
  chunk_output_type: console
editor:
  mode: source
bibliography: references/references.bib
execute:
  tidy: false
  warning: false
  message: false
  error: false
  cache: true
  eval: false
---

# Forest Carbon Modelling in SpaDES with `setupProject`

::: {.callout-tip appearance="simple"}
See \[Barebones R script\] for the code shown in this chapter
:::

```{r setup}
#| include: false
#| eval: true
#| cache: false
#| purl: false

knitr::opts_chunk$set(tidy = FALSE, 
                      warning = FALSE, 
                      message = FALSE, 
                      error = FALSE)

# truncate text output
hook_output <- knitr::knit_hooks$get("output")

knitr::knit_hooks$set(output = function(x, options) {
  if (!is.null(n <- options$outlines)) {
    x <- xfun::split_lines(x)
    if (length(x) > n) {
      # truncate the output
      x <- c(head(x, n), "....\n")
    }
    x <- paste(x, collapse = "\n")
  }
  hook_output(x, options)
})

if (Sys.getenv("USERNAME") == "GHA") {
  googledrive::drive_auth(path = Sys.getenv("GOOGLE_APP_CREDENTIALS"))
}

qmdPath <- normalizePath(getwd(), winslash = "/")

if (!interactive()) { 
  dir.create("~/SpaDES_book/spadesCBMDemo", recursive = TRUE)
  knitr::opts_knit$set(root.dir = "~/SpaDES_book/spadesCBMDemo")
}
```

spadesCBM is a modular, transparent, and spatially explicit implementation of the logic, pools structure, equations, and default assumptions of the Carbon Budget Model of the Canadian Forest Sector [CBM](https://natural-resources.canada.ca/climate-change/climate-change-impacts-forests/carbon-accounting/carbon-budget-model/13107).
It applies the science presented in @kurz2009 in a similar way to the
simulations in @boisvenue2016 and @boisvenue2022 but calls Python
functions for annual processes. These functions are, like much of
modelling-based science, continuously under development.

## spadesCBM Modules

Four modules need to be run in tandem for a spadesCBM simulation (see section XX
for how these relate in SpaDES). The first module *CBM_defaults* reads in
defaults CBM parameters for Canada.  The second module *CBM_dataPrep_SK* is
a data preparation SpaDES module, where input data and spatial layers are
assembled and prepared for a specific study area (the *SK*
indicates the specific study area or scenario, in this case it is a small raster in Saskatchewan). In spadesCBM, as in CBM, growth curves are
the main change-agent. The third module *CBM_vol2biomass* translates user-provided growth curves ($m^3/ha$) into increments for specific above ground carbon pools (metric tonnes of carbon/ha) using @boudewyn2007 models to which we added a smoothing algorithm. These three modules provide the inputs to the *CBM_core* module where processes are applied on a yearly time step. This modularity enables users to access and change default parameters, change inputs, and assess the impact of these changes. We are working on some implementations of this modularity and making these available to the community.
We hope others will do the same. A manual describing spadesCBM in detail is forthcoming. The link to the manual will be posted here.

Several core utilities to spadesCBm are provided by the [`CBMutils`](https://github.com/PredictiveEcology/CBMutils@development) package, available on GitHub. Active development in `CBMutils` and all `spadesCBM` modules is underway.

## Setup

In this example, we will setup the workflow using `setupProject` from the
[`SpaDES.project`](https://spades-project.predictiveecology.org/) package and
current versions of the spadesCBM modules.

``` {r}        
projectPath <- "~/spadesCBMpython"
dir.create(projectPath, recursive = TRUE, showWarnings = FALSE)
setwd(projectPath)

repos <- unique(c("predictiveecology.r-universe.dev", getOption("repos")))
install.packages("SpaDES.project",
                 repos = repos)

# start in 1998, and end in 2000
times <- list(start = 1998, end = 2000)

out <- SpaDES.project::setupProject(
  Restart = TRUE,
  useGit = "PredictiveEcology", # a developer sets and keeps this = TRUE
  overwrite = TRUE, # a user who wants to get latest modules sets this to TRUE
  paths = list(projectPath = projectPath),

  options = options(
    repos = c(repos = repos),
    Require.cloneFrom = Sys.getenv("R_LIBS_USER"),
    reproducible.destinationPath = "inputs",
    ## These are for speed
    reproducible.useMemoise = TRUE,
    # Require.offlineMode = TRUE,
    spades.moduleCodeChecks = FALSE
  ),
  modules =  c("PredictiveEcology/CBM_defaults@training",
               "PredictiveEcology/CBM_dataPrep_SK@training",
               "PredictiveEcology/CBM_vol2biomass@training",
               "PredictiveEcology/CBM_core@training"),
  times = times,
  require = c("SpaDES.core", "reticulate",
              "PredictiveEcology/libcbmr", "data.table"),

  parameters = list(
    CBM_defaults = list(
      .useCache = TRUE
    ),
    CBM_dataPrep_SK = list(
      .useCache = TRUE
    ),
    CBM_vol2biomass = list(
      .useCache = TRUE
    )
  ),

  ret = {
    reticulate::use_virtualenv(virtualenv = "r-reticulate")
    reticulate::py_install("libcbm", envname = "r-reticulate")
  },

  #### begin manually passed inputs #########################################
  ## define the  study area.
  masterRaster = {
    extent = terra::ext(c(xmin = -687696, xmax = -681036, ymin = 711955, ymax = 716183))
    masterRaster <- terra::rast(extent, res = 30)
    terra::crs(masterRaster) <- "PROJCRS[\"Lambert_Conformal_Conic_2SP\",\n    BASEGEOGCRS[\"GCS_GRS_1980_IUGG_1980\",\n        DATUM[\"D_unknown\",\n            ELLIPSOID[\"GRS80\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1,\n                    ID[\"EPSG\",9001]]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]],\n    CONVERSION[\"Lambert Conic Conformal (2SP)\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",-95,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",77,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"northing\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]"
    masterRaster[] <- rep(1, terra::ncell(masterRaster))
    mr <- reproducible::prepInputs(url = "https://drive.google.com/file/d/1zUyFH8k6Ef4c_GiWMInKbwAl6m6gvLJW/view?usp=drive_link",
                                   destinationPath = "inputs",
                                   to = masterRaster,
                                   method = "near")
    mr[mr[] == 0] <- NA
    mr
  },
  ## Give the location of the disturbance rasters.
  disturbanceRasters = "https://drive.google.com/file/d/12YnuQYytjcBej0_kdodLchPg7z9LygCt/view?usp=drive_link",

  # Restart = getOption("SpaDES.project.Restart", FALSE),

  outputs = as.data.frame(expand.grid(objectName = c("cbmPools", "NPP"),
                                      saveTime = sort(c(times$start,
                                                        times$start +
                                                          c(1:(times$end - times$start))
                                      )))),

)

out$loadOrder <- unlist(out$modules)

```

::: {#imp-gdrive .callout-important}
## Google account needed for this example

Like the LandR example, you will need to access some of the data using the `googledrive` R package (part of the `tidyverse` family). During the `simInit()` (or `simInitAndSpades()`) call R will prompt you to either choose a previously authenticated account (if you have previously used `googledrive`) or to open a browser window and authenticate. If this doesn't work, try this workaround:

```{r setupGoogle}
#| eval: false
#| results: hide
#| code-fold: false
#| code-summary: "Show code"
install.packages(c("googledrive", "httpuv"), repos = repos)

googledriveAuthPath <- "~/SpaDES_book/googledrive_auth_cache"
dir.create(googledriveAuthPath, showWarnings = FALSE)
googledrive::drive_auth(cache = "~/SpaDES_book/googledrive_auth_cache")

```

Make sure you give `tidyverse` read/write access to your files:

![](assets/img/gdriveauth.png){fig-align="center" width="467"}
:::

::: {#imp-python .callout-important}
## Python is required for this example

The *CBM_core* module requires Python >=3.9 and <=3.12.7.

If a suitable version of Python does not already exist on your computer,
`setupProject` will use the [`reticulate`](https://rstudio.github.io/reticulate/) package to install it using the [pyenv](https://github.com/pyenv/pyenv) or [pyenv-win](https://github.com/pyenv-win/pyenv-win) project.

If you are using a Windows computer with Git installed, the `pyenv-win` tool will be acquired and managed directly by `reticulate`. If you are using a Windows computer without Git installed, you will be prompted to allow the `pyenv-win` tool to be downloaded directly from Github to your local user application data directory (`tools::R_user_dir("r-spadesCBM")`).

If the Python installation process fails or you would prefer to manually install Python, it can be downloaded directly from [python.org/downloads](https://python.org/downloads).

:::

## Run Simulation

Now that our project is set up, we can run our simulation.

```{r}         
simPython <- do.call(SpaDES.core::simInitAndSpades, out)
```

### Inspect your simulation



### Looking at results

Now that we've run our simulation, we can now visualize some results using some plotting functions sourced from our modules. 

``` {r}        
carbonOutPlot(
  emissionsProducts = simPython$emissionsProducts
  ) # This plots yearly forest products and yearly emissions for the length of the simulation

 barPlot(
   cbmPools = simPython$cbmPools
   ) # This plots the carbon proportions above and below ground each simulation year

NPPplot(
  spatialDT = simPython$spatialDT,
  NPP = simPython$NPP,
  masterRaster = simPython$masterRaster
  ) # This plots the per-pixel average net primary production 

spatialPlot(
  cbmPools = simPython$cbmPools,
  years = 2000,
  masterRaster = simPython$masterRaster,
  spatialDT = simPython$spatialDT
  ) # this plots the Total Carbon per pixel for the final simulation year

```

You can also schedule these plots within a module so that they are automatically generated at the end of the simulation. In `CBM_core.R` you can find these plots already defined in the `doEvent.CBM_core()` function.  
```{r}
plot = {
      if (time(sim) != start(sim)) {
        retry(quote({
          carbonOutPlot(
            emissionsProducts = sim$emissionsProducts
          )
        }), retries = 2)

        barPlot(
          cbmPools = sim$cbmPools
        )

        NPPplot(
          spatialDT = sim$spatialDT,
          NPP = sim$NPP,
          masterRaster = sim$masterRaster
        )
      }

      spatialPlot(
        cbmPools = sim$cbmPools,
        years = time(sim),
        masterRaster = sim$masterRaster,
        spatialDT = sim$spatialDT
      )
    },
```

If you look a few lines above where the plots are defined in the module (on line 186) you will find a line of code currently commented out:

``` {r}        
# sim <- scheduleEvent(sim, end(sim), "CBM_core", "plot",  eventPriority = 12)
```

You can remove the comment # to add this line of code back in, save, and rerun your simulation. You are now scheduling the plotting to occur at the end of the simulation. The model should now automatically run the plotting functions above.

## Changing study area

Changing study areas requires that all the inputs be available. In spadesCBM, that means growth curves where (i.e., which pixel) they apply, and what is the leading species for that stand, an age raster, an ecozone raster, and information about disturbances (i.e., disturbance rasters) for all the years of simulation. Since we have that information for the province of Saskatchewan, we can change the definition of the study area in our `setupProject` script.

## Barebones script
```{r}
projectPath <- "~/spadesCBMpython"
dir.create(projectPath, recursive = TRUE, showWarnings = FALSE)
setwd(projectPath)

repos <- unique(c("predictiveecology.r-universe.dev", getOption("repos")))
install.packages("SpaDES.project",
                 repos = repos)

# start in 1998, and end in 2000
times <- list(start = 1998, end = 2000)

out <- SpaDES.project::setupProject(
  Restart = TRUE,
  useGit = "PredictiveEcology", # a developer sets and keeps this = TRUE
  overwrite = TRUE, # a user who wants to get latest modules sets this to TRUE
  paths = list(projectPath = projectPath),

  options = options(
    repos = c(repos = repos),
    Require.cloneFrom = Sys.getenv("R_LIBS_USER"),
    reproducible.destinationPath = "inputs",
    ## These are for speed
    reproducible.useMemoise = TRUE,
    # Require.offlineMode = TRUE,
    spades.moduleCodeChecks = FALSE
  ),
  modules =  c("PredictiveEcology/CBM_defaults@training",
               "PredictiveEcology/CBM_dataPrep_SK@training",
               "PredictiveEcology/CBM_vol2biomass@training",
               "PredictiveEcology/CBM_core@training"),
  times = times,
  require = c("SpaDES.core", "reticulate",
              "PredictiveEcology/libcbmr", "data.table"),

  parameters = list(
    CBM_defaults = list(
      .useCache = TRUE
    ),
    CBM_dataPrep_SK = list(
      .useCache = TRUE
    ),
    CBM_vol2biomass = list(
      .useCache = TRUE
    )
  ),

  ret = {
    reticulate::use_virtualenv(virtualenv = "r-reticulate")
    reticulate::py_install("libcbm", envname = "r-reticulate")
  },

  #### begin manually passed inputs #########################################
  ## define the  study area.
  masterRaster = {
    extent = terra::ext(c(xmin = -687696, xmax = -681036, ymin = 711955, ymax = 716183))
    masterRaster <- terra::rast(extent, res = 30)
    terra::crs(masterRaster) <- "PROJCRS[\"Lambert_Conformal_Conic_2SP\",\n    BASEGEOGCRS[\"GCS_GRS_1980_IUGG_1980\",\n        DATUM[\"D_unknown\",\n            ELLIPSOID[\"GRS80\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1,\n                    ID[\"EPSG\",9001]]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]],\n    CONVERSION[\"Lambert Conic Conformal (2SP)\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",-95,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",77,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"northing\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]"
    masterRaster[] <- rep(1, terra::ncell(masterRaster))
    mr <- reproducible::prepInputs(url = "https://drive.google.com/file/d/1zUyFH8k6Ef4c_GiWMInKbwAl6m6gvLJW/view?usp=drive_link",
                                   destinationPath = "inputs",
                                   to = masterRaster,
                                   method = "near")
    mr[mr[] == 0] <- NA
    mr
  },
  ## Give the location of the disturbance rasters.
  disturbanceRasters = "https://drive.google.com/file/d/12YnuQYytjcBej0_kdodLchPg7z9LygCt/view?usp=drive_link",

  # Restart = getOption("SpaDES.project.Restart", FALSE),

  outputs = as.data.frame(expand.grid(objectName = c("cbmPools", "NPP"),
                                      saveTime = sort(c(times$start,
                                                        times$start +
                                                          c(1:(times$end - times$start))
                                      )))),

)

out$loadOrder <- unlist(out$modules)

# Run
simPython <- do.call(SpaDES.core::simInitAndSpades, out)
#INSERT ANY OTHER CODE HERE
## e.g. the example to change the start or end time, and the one to change the masterRaster. 

```
