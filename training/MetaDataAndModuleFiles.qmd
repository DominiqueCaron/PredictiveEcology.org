---
author: "Eliot McIntire"
date: last-modified
editor_options:
  chunk_output_type: console
execute:
  eval: false
  tidy: false
  warning: false
  message: false
  error: false
  cache: false
---

# Module Files and Metadata {#sec-moduleFilesAndMetadata}

```{r setup}
#| include: false
#| eval: true

## truncate text output
hook_output <- knitr::knit_hooks$get("output")

knitr::knit_hooks$set(output = function(y, options) {
  if (!is.null(n <- options$outlines)) {
    y <- xfun::split_lines(y)
    if (length(y) > n) {
      # truncate the output
      y <- c(head(y, n), "....\n")
    }
    y <- paste(y, collapse = "\n")
  }
  hook_output(y, options)
})
libPath <- ifelse(dir.exists("packages"), "packages", "training/packages") # if run interactively vs knited
.libPaths(libPath)
```

## Continue example -- a linear model

We will start by thinking about metadata: *What is metadata?*

Slightly modifying the example, we remove the line with
`x <- rnorm(10)`. This will make the code chunk not work because it
needs the `x` to run the next line. We can examine the following code
chunk. First, we ask: what are the **inputs** and the **outputs**?

```{r start}
# create some data
y <- x + rnorm(10)
# fit a linear model
model <- lm(y ~ x)
```

## Required Packages, Input Expectations and Output Creations

### Inputs and Outputs

We use the terms `expectsInput` and `createsOutput` to describe the
inputs and outputs in the metadata. This makes it clear that the
metadata do *not* specify which they will *go get*; rather, it makes it
clear that it doesn't matter *where* the inputs are coming from. They
could come from one of three sources: a user, another module, or
defaults that the developer sets up. Likewise, the module specifies
which outputs it creates, without specifying "for what other module".

The **inputs** to this chunk are just one: the object `x`. This code
will not work (i.e., it will cause an error) if `x` is not defined. We
can say that this code chunk "expects" `x` as an input.

The **outputs** are `y` and `model`. We can say that this code chunk
"creates" `y` and `model` as outputs. However, we had said in 
@sec-moduleintro that we would only be interested in
keeping `model`. So, we will continue with only one output, `model`.

### Required Packages

Next, *what are the package dependencies?*. We call this `reqdPkgs` in
the SpaDES metadata. We see that there are three functions: `rnorm`,
`lm` and `plot`. We don't know what packages they are in, so we can find
out by typing them at the R prompt. At the bottom of the function, it
says that the function `rnorm` is in the `stats` package. Fortunately
for us, this is a default ("base") package in R and it is always
pre-loaded. So, nothing to do here.

```{r second}
> rnorm function (n, mean = 0, sd = 1)  ... 
<environment: namespace:stats>}
```

So, our expectations, dependencies and creations are:

-   Inputs: `x`
-   Outputs: `model`
-   Package dependencies: Base packages only

We will next put them into the correct places in the new SpaDES module.

## Module files

Make the module again (see @sec-moduleintro). This time we will add
`sim$` for the `x` as we are now interested in the fact that it might be
coming from *outside* this module.

```{r}
#| eval: true

# make a module
Require::Require(c("reproducible", "SpaDES.core"), repos = c("https://predictiveecology.r-universe.dev", getOption("repos")))

# make a module
nm1 <- "My_linear_model"
modulePath <- "~/SpaDES_book/NewModuleIntro/NewModule"
SpaDES.core::newModule(name = nm1, path = modulePath, open = FALSE,
                       events = list(
                         init = {
                           y <- sim$x + rnorm(10)      # <--------- add sim$ here
                           # fit a linear model
                           sim$model <- lm(y ~ sim$x)  # <--------- add sim$ here
                         }
                       ))
```

**Where is this module code?** In the previous chapter, we didn't look
or care where the module code was.

`newModule` actually creates a new folder, with the `name` as provided
by the argument, in the folder specified with `path`. This folder has
several files in it. See
[`?newModule`](https://rdrr.io/cran/SpaDES.core/man/newModule.html) for
details. For now, run the above and open the `My_linear_model.R` script
that it creates.

When we make a module, we get a message stating where the module code
is. **From here, open the file**, e.g., by copy-pasting the file path
(pick the `.R` file NOT the `.Rmd` file for now)

::: {.callout-important appearance="simple" icon="false"}
**Opening a module file**

From here onward, we will need to manually open the module code file.
Every SpaDES module is defined by having at least 1 file that is named
with `<modulePath>/<moduleName>/<moduleName>.R`. Even though we can do a
lot with `newModule()`, we will need to get used to opening, examining
and changing the code in the module code file.
:::

We will look at a few elements in this chapter.

## `inputObjects`

Scroll down to `inputObjects` and `expectsInputs()`. This is where we
will put our `inputs` that we noticed in our code chunk. We will declare
`x` as an "input" by putting it there, like this:

```{r metadata}
inputObjects = bindrows(
  expectsInput(objectName = "x", objectClass = "numeric", 
               desc = "The inputs for the linear model", sourceURL = NA)
)
```

## `outputObjects`

Next, scroll down to `outputObjects` and `createsOutput()`. We will
declare `model` as an "output" by putting it there. Don't forget the
**comma at the end of each `createsOutput()`** as each is an argument to
`bindrows` (unless it is the last one).

```{r}
outputObjects = bindrows(
  createsOutput(objectName = "model", objectClass = "lm", 
                desc = "A linear model object from the equation (x ~ y)")
)
```

## Sharing inputs and outputs

You may have noticed that the `init` event is now placed into a function
called `doEvent.My_linear_model.init` and it has an argument `sim`. If
you are familiar with making functions in `R`, this is just a named
argument `"sim"`. This means that we can use `sim` inside the function.
We don't know what `sim` is yet, and we don't know how to use it fully
yet. But we do know that we have added `sim$` to the `init` event. We
also see that there is a `return(sim)` added at the bottom of the event
function.

::: {.callout-note appearance="simple" icon="false"}
**An event occurs in a special function that starts with `doEvent.`**.
But, since it is "in a function", each event has all the features of a
function:

-   **arguments** -- specifically `sim` can be used
-   **something returned** -- in this case, the `simList`. `return(sim)`
    must always be present - it is by default, but don't delete it!
-   **it can be run**-- but don't worry about running it; SpaDES runs it
    when it is time.
:::

::: {.callout-note appearance="simple" icon="false"}
**The `simList`**

The
[`simList`](https://spades-core.predictiveecology.org/reference/simList-class.html)
is the data structure that is the foundation of `SpaDES`. It can be used
*like a list*; accessing objects can be done with `$` or `[["model"]]`,
for example.

In any function that has an argument `sim`, we pass the `simList`, so we
can access the `simList` with `sim$` from inside such a function.

See @sec-simlist for more details about the `simList`.
:::

To share objects between modules, we *must* assign them to the `sim`
**and** make sure that `return(sim)` is at the end of the function.

Now we have a module that creates one object, `model` and puts them
inside `sim`. This all happens in the event called `init`.

<!--maybe unnecessary?-->

**Next**: add the visualization module with metadata

## Visualization module

We remake the second module from last chapter. But this time we will
look at and update the metadata.

```{r newModule2}
#| eval: true

nm2 <- "visualize"
newModule(nm2, path = modulePath, open = FALSE,
          events = list(
            init = {
              plot(sim$model)
            }
          )
)
```

### Outputs of one module are Inputs of another

Here we start to see the "shared" objects. The module we just made above
`createsOutput` of `model`. But this new `visualization` module will
`expectInput` of `model`. So, we can copy the same description if it is
the same.

```{r metadata2}
inputObjects = bindrows(
  expectsInput(objectName = "model", objectClass = "lm", 
               desc = "A linear model object from the equation (x ~ y)", sourceURL = NA)
)
```

## Default Values

Recall, we don't have a value for `x`. This means that if you run the
following, you will get an error, unlike in the previous chapter where
we had `x` defined in the `init` event.

```{r}
simInitAndSpades(modules = c(nm1, nm2), 
                 paths = list(modulePath = modulePath))
```

Just like functions in R, we can supply default values for our
**inputs**. We put these in a function at the bottom called
`.inputObjects`. See @sec-moduleinputs for a model detailed explanation
of module inputs and how to deal with them.

Copy this to the module, replacing the contents of the template
`.inputObjects` function.

```{r}
.inputObjects <- function(sim) {
  if (!suppliedElsewhere("x", sim))
    sim$x <- rnorm(10, mean = 20, sd = 2)
  return(invisible(sim))
}
```

`!suppliedElsewhere("x", sim)` will check if `x` is in `sim` and if not,
will run the subsequent code lines (see
[`?suppliedElsewhere`](https://rdrr.io/cran/SpaDES.core/man/suppliedElsewhere.html)).

## Run the new module

Now, we have **inputs** and **outputs** defined, our code has been
places in 2 spots (events), and we have default value for `x`.

```{r}
simInitAndSpades(modules = c(nm1, nm2), 
                 paths = list(modulePath = modulePath))
```

We now have a SpaDES module that has metadata, generates random starting
data (if the user doesn't supply an alternative), fits a linear model,
outputs that model, and plots the fit.

## Questions

1.  What are some things we "gained" from putting our simple 3 lines of
code into a module?
-   We can turn off plotting easily. Set `.plotInitialTime = NA` in
the `simInitAndSpades` call.
2.  What are some things we "lost"?
-   More complicated. (overkill for these 3 lines?)
3.  What if we used an R package that wasn't in the base packages list?
-   See
[`?defineModule`](https://rdrr.io/cran/SpaDES.core/man/defineModule.html)
for all the metadata items. Specifically, see `reqdPkgs`.
4.  What is the `sim`? See
[`?'.simList-class'`](https://rdrr.io/cran/SpaDES.core/man/simList-class.html)

## Challenge yourself {#sec-moduleFilesAndMetadata-challengeYourself}

1. Fill in the metadata from the Challenges you did in previous chapter.

2. Look at the other elements of the metadata and cross reference them with 
[`?defineModule`](https://rdrr.io/cran/SpaDES.core/man/defineModule.html)

3. Look at the `Rmd` file of one of the modules that has been built (recall the message after you call `newModule`), where you have filled in the metadata. Try to build it and look at the automatic tables that get built from the metadata.

## See also

@sec-modseventsfuns on Modules, Events and Functions

@sec-moduleinputs on module inputs

@sec-simlist on the `simList`

[`?defineModule`](https://rdrr.io/cran/SpaDES.core/man/defineModule.html) describes all the metadata entries.

[`?expectsInput`](https://rdrr.io/cran/SpaDES.core/man/expectsInput.html)

[`?createsOutput`](https://rdrr.io/cran/SpaDES.core/man/createsOutput.html)

[`?simInitAndSpades`](https://rdrr.io/cran/SpaDES.core/man/simInitAndSpades.html)

[`?newModule`](https://rdrr.io/cran/SpaDES.core/man/newModule.html)

[`?SpaDES.project::setupProject`](https://spades-project.predictiveecology.org/reference/setupProject.html)

[`?SpaDES.core::simInit`](https://rdrr.io/cran/SpaDES.core/man/simInit.html)

[`?SpaDES.core::simInitAndSpaDES`](https://rdrr.io/cran/SpaDES.core/man/simInitAndSpaDES.html)
