---
author: "Eliot McIntire"
date: last-modified
execute:
  echo: true
  cache: false
  tidy: false
  warning: false
  message: false
  error: false
editor_options:
  chunk_output_type: console
bibliography: references/references.bib
---

# Modules, Events and Functions {#sec-modseventsfuns}

::: {.callout-tip appearance="simple"}
See [Barebones R script] for the code shown in this chapter
:::

```{r setup}
#| include: false
#| purl: false

knitr::opts_chunk$set(tidy = FALSE, 
                      eval = FALSE,
                      warning = FALSE, 
                      message = FALSE, 
                      error = FALSE)

# truncate text output
hook_output <- knitr::knit_hooks$get("output")

knitr::knit_hooks$set(output = function(x, options) {
  if (!is.null(n <- options$outlines)) {
    x <- xfun::split_lines(x)
    if (length(x) > n) {
      # truncate the output
      x <- c(head(x, n), "....\n")
    }
    x <- paste(x, collapse = "\n")
  }
  hook_output(x, options)
})

Require::Require(c("reproducible"), install = FALSE)
```

A **module** is a collection of R scripts structured in a particular
way. A module is very similar in structure to an R package, in the sense
that it defines a collection of functions to be used, so will be
familiar if you know what packages look like.

**Events** are ways to name chunks of code that can be run in a
particular sequence or at a particular time.

**Functions** are the basic building blocks in R and other languages. We
work with all three of these to make robust and re-useable workflows.

Modules encapsulate events, which encapsulate functions.

## Modules

Modules include the following elements:

-   a function call to `defineModule` that defines the metadata
    (mandatory)
-   a function definition for `doEvent.`*moduleName* (mandatory)

There are many optional pieces too. The default template produces many
of these optional pieces, which means it is "noisy". This also means we
can ignore most of it for now.

Optional pieces include:

-   other functions in the R folder or the main *moduleName*`.R` file
-   a documentation file (*moduleName*.rmd)

These are all contained within a file structure like this, with other
optional files:

```         
/moduleRepository
  |_ moduleName/
      |_ R/                     # contains additional/optional .R (helper) files
      |_ data/                  # directory for all included data
          |_ CHECKSUMS.txt      # contains checksums for data files
      |_ tests/                 # contains (optional) unit tests for module code
      |_ citation.bib           # bibtex citation for the module
      |_ LICENSE.txt            # describes module's legal usage
      |_ moduleName.R           # module code file (incl. metadata)
      |_ moduleName.Rmd         # documentation, usage info, etc.
```

To make a new module, see: @sec-moduleintro.

## Events

Events are named chunks of code that can be scheduled to be run once or
many times. These are scheduled with `scheduleEvent()`. There are
several commonly occurring module types that can be grouped based on the
events that they contain (see @sec-moduletypes).

To see how to schedule events, see: @sec-schedulingEvents.

## Functions

Essentially, everything in R is or uses functions. Modules define
functions (`doEvent.*moduleName*`), events call specific functions (we
some times call these "event functions"), and functions can be defined
within modules, R packages, or user code.

### Adding functions

Any function can be written and defined in any `.R` file in the `R` folder, just like an R package. They can also be placed in the main module script (the one named `<moduleName>.R`). The default template includes several functions. 

In this example, instead of writing the code that does what we want inside the `doEvent` function itself, lets use the `Init` function. We move the code from the "init" event into a function, then call that function.

```{r useAFunction,eval=FALSE}
doEvent.My_linear_model.init <- function(sim, eventTime, eventType, priority) {
  sim <- Init(sim)
  return(sim)
}

Init <- function(sim) {
  y <- sim$x + rnorm(10)
  sim$model <- lm(y ~ sim$x)
  return(invisible(sim))
}
```

We can extend this to any number of functions. Notice, that functions can have any arguments. They don't have to have `sim`. The critical point to retain is that the `doEvent` function must return `sim`. We can also write documentation using `roxygen2` tags (though converting this to normal R documentation is still experimental within a SpaDES module).

Copy these three functions to your module, **replacing the existing functions with these ones** (for `doEvent.My_linear_model.init` and `Init`). `generateY` is completely new, so it won't replace anything.

```{r useAFunction2,eval=FALSE}
doEvent.My_linear_model.init <- function(sim, eventTime, eventType, priority) {
  sim <- Init(sim)
  return(sim)
}

# Use this inside the `doEvent.My_linear_model.init` function
Init <- function(sim) {
  y <- generateY(sim$x)
  sim$model <- lm(y ~ sim$x)
  return(sim)
}

#' A function that generates random error around an `x`
#' 
#' @param x Any numeric vector of length 10 
generateY <- function(x) {
  x + rnorm(10)
}

```


## Module types {#sec-moduletypes}

SpaDES doesn't have explicit module types. Rather, by convention, we
associate different modules with generic things they do. A fairly
comprehensive list of modules types that we create are below. We will revisit this later in @sec-continuousWorkflows. 

### Static

**Static** modules can be defined as modules that "run once". This means
that they may have only one event. Or a sequence of events that occur
one after the other with no rescheduling.

These could include: 

-   Data preparation modules - one (maybe just the
    "init" event) or few events and their primary goal is to get and deal
    with data; 

-   GIS modules that do a number of GIS operations to get data
    into the necessary formats;

-   Data Visualization modules that specialize
    in creating a set of visuals from a known set of inputs.

### Dynamic

**Dynamic** modules are modules that have *events that recur*. There are
at least 2 types of such models: those that have **cyclic
dependencies**, i.e., its outputs are also its inputs (possibly with
other modules in between) and those that do not.

-   Landscape simulation modules (e.g., wildfire, vegetation change)

-   Wildlife population modules with Markov dependency (e.g., population
    matrix models)
    
-   Wildlife population modules without Markov-dependency (e.g.,
    population models that only depend on habitat covariates)
    
-   Data visualization modules that get used e.g., annually after other
    modules.

In @barros2023 we classified modules with respect to *what* the modules
try to accomplish:

-   "data/calibration modules" prepare model inputs and parameters

-   "prediction/simulation modules" generate predictions using either
    static or dynamic mechanisms

-   "validation modules" evaluate predictions against independent data.

There are no strict rules to classify a SpaDES module, just as there are
no strict rules to classify an R script.

## See also

@sec-schedulingEvents on event scheduling

[`?scheduleEvent`](https://rdrr.io/cran/SpaDES.core/man/scheduleEvent.html)

[`?P`](https://rdrr.io/cran/SpaDES.core/man/params.html)

[`?time`](https://rdrr.io/cran/SpaDES.core/man/simList-accessors-times.html)

[`?start`](https://rdrr.io/cran/SpaDES.core/man/simList-accessors-times.html)

[`?end`](https://rdrr.io/cran/SpaDES.core/man/simList-accessors-times.html)

## More learning on this subject

[My First
Module](https://spades-workshops.predictiveecology.org/articlesMay2018/MyFirstModule.html)

[Creating a seed dispersal
module](https://spades-workshops.predictiveecology.org/articles/02c-Convert_R_code_to_SpaDES_module.html)


## Barebones R script

```{r}
#| eval: true
#| echo: false
#| purl: false

fileName <- file.path("R/Chapter_scripts", sub("rmarkdown", "R", knitr::current_input()))
```

```{r file = fileName}
#| eval: false
#| echo: true
#| purl: false

```
