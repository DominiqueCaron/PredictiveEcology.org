---
author: "Eliot McIntire"
date: last-modified
editor_options:
  chunk_output_type: console
execute:
  eval: false
  tidy: false
  warning: false
  message: false
  error: false
---

# Scheduling Events {#sec-schedulingEvents}

```{r setup}
#| include: false
#| eval: true

## truncate text output
hook_output <- knitr::knit_hooks$get("output")

knitr::knit_hooks$set(output = function(x, options) {
  if (!is.null(n <- options$outlines)) {
    x <- xfun::split_lines(x)
    if (length(x) > n) {
      # truncate the output
      x <- c(head(x, n), "....\n")
    }
    x <- paste(x, collapse = "\n")
  }
  hook_output(x, options)
})

# Require::Require(c("ggplot2", "SpaDES.core"), install = FALSE)
library("ggplot2")
```

Here, we will talk about **scheduling events** in a SpaDES module using
a function called
[`SpaDES.core ::scheduleEvents()`](https://rdocumentation.org/packages/SpaDES.core/versions/2.0.5/topics/scheduleEvent).
Please see @sec-moduleintro for how to create a simple module and @sec-modseventsfuns 
for an overview of what events are before
attempting this section.

::: {.callout-tip appearance="simple"}
## Repeated? When?

When starting to build a module or an event, we ask 2 key questions:

**1. Do I need to repeat this operation?**

**2. If yes, how often and/or when?**

Once we answer these, we can use the function `scheduleEvents` to set
them up in whatever sequence we want.
:::

Scheduling events allows us to control when things happen in a sequence.
This can be as simple as "this module will just do one thing" to "this
module will do several things, some of which repeat".

Below, we will use a simple example where there is one thing that
happens once and one thing that happens several times. In "normal"
R-speak, *we will write a loop*.

We return to the example in @sec-moduleintro, but this time, we will add
a *predict* step from the linear model, with updated values of the `y`.
In this simple example, we will pretend that each prediction is "one
year into the future" and that our `y` will slowly get bigger.

```{r}
#| eval: true

# .inputObjects  #####
x <- rnorm(10)

# Init #####
y <- x + rnorm(10)
# fit a linear model
out <- lm(y ~ x)
pred <- list()

# Prediction #####
startYear <- 2023
years <- startYear:(startYear + 10) + 1
for (year in years - startYear) {
  pred[[year]] <- predict(out, newdata = data.frame(y = rnorm(10) + year))
}

# Plot #####
predictions <- data.frame(year = rep(years, each = 10), prediction = unlist(pred))
# plot the predictions
ggplot(predictions, aes(x = year, y = prediction, colour = year)) + 
  geom_point() + geom_smooth()
```

## Convert to a module

In the above code, there are 4 sections. These will each be copied into
the SpaDES module below, in their respective sections. We have added 1
new section, called "Prediction".

```{r newodule}
SpaDES.core::newModule(name = "scheduling", path = "~/SpaDES_book/scheduling")
```

Open the module file, which will be printed in the console. Scroll down
to the `Init` function and copy the `Init`, the `.inputObjects`, and the
`Plot` parts in the code above into the new module, as we did in
@sec-moduleintro.

We must make the same decisions about "local objects" (objects that are
OK not to be kept for later) and about "global objects" (those that we
want to keep). These *global* objects get put into `sim`. Your new
module should have these 3 new sections/functions:

```{r}
Init <- function(sim) {
  y <- sim$x + rnorm(10)
  # fit a linear model
  sim$out <- lm(y ~ sim$x)
  sim$pred <- list()
}

plotFun <- function(sim) {
  sim$predictions <- data.frame(year = rep(sim$years, each = 10), prediction = unlist(sim$pred))
  # plot the predictions
  sim$gg <- ggplot(sim$predictions, aes(x = year, y = prediction, colour = year)) + geom_point() + geom_smooth()
  print(sim$gg)
}

.inputObjects <- function(sim) {
  sim$x <- rnorm(10)
}
```

## New Event Function -- Prediction

The new part is the `for` loop. This part takes new covariates (new
values for `y`), emulating "predicted" covariates, and derives a newly
predicted `x`, which we then keep as the *predicted* `x` values each
year.

We'll use `scheduleEvent()` below to do this iteration. For now, copy
the `Prediction` part into a new function:

```{r}
Prediction <- function(sim) {
  startYear <- 2023
  sim$years <- startYear:(startYear + 10) + 1
  for (year in sim$years - startYear) {
    sim$pred[[year]] <- predict(sim$out, newdata = data.frame(y = rnorm(10) + year))
  }
  return(invisible(sim))
}
```

## Scheduling

Now we need to tell SpaDES when to execute and when to iterate each of
the steps or "events". The `Init` we do once, at the start. The `plotFn`
we do once, but this time it is at the "end". The `.inputObjects` always
only happens once and "before the start" (`Init`) -- it is scheduled
automatically so nothing to do here. The last part (i.e., the prediction
event) must happen 10 times, and it must start after `Init` and before
the `plotFn`.

### doEvent

There is a special function in a `SpaDES` module called `doEvent()`.
SpaDES calls this function once, passing the argument `event = "init"`.
That means that R will enter into this function only once and run only
the `init` part, unless we specifically tell it to do more, using the
`scheduleEvent` function.

We place this function anywhere we want inside `doEvent`, in general. In
this example, we will place it in a few places.

#### In the `init` event

We look at the `init` event (code inside `event = "init"`) and we see 2
`scheduleEvent` calls that come with the template. We will use those to
learn. In each "event", we often see one part that "does something" and
another part that "schedules something".

In the default template, we "do" the `Init` function and we schedule
`plot` and `save`. We can delete the `save` event, as we won't do that
here. But we will replace it with "schedule prediction".

See
[`?start`](https://rdrr.io/cran/SpaDES.core/man/simList-accessors-times.html),
[`?scheduleEvent`]()https://rdrr.io/cran/SpaDES.core/man/scheduleEvent.html,
[`?P`](https://rdrr.io/cran/SpaDES.core/man/params.html)

```{r defaultInit}
sim <- Init(sim)

# schedule future event(s)
sim <- scheduleEvent(sim, P(sim)$.plotInitialTime, "scheduling", "plot")
# sim <- scheduleEvent(sim, P(sim)$.saveInitialTime, "scheduling", "save")

# here we create a new event type == "predictions" and we schedule it for `start(sim)`
sim <- scheduleEvent(sim, start(sim), "scheduling", "predictions") 
```

Copy the above code chunk to the `init` section so that it looks like
this:

```{r newInit}
switch(
  eventType,
  init = {
    sim <- Init(sim)
    
    # schedule future event(s)
    sim <- scheduleEvent(sim, P(sim)$.plotInitialTime, "scheduling", "plot")
    
    # here we create a new event type == "predictions" and we schedule it for `start(sim)`
    sim <- scheduleEvent(sim, start(sim), "scheduling", "predictions") 
  },
  ...
)
```

### The new event

We will add code to make a new event, called `"predictions"` (the name
must match what we wrote in the `scheduleEvent` above). In this event,
we "do" the prediction, then we schedule the next prediction at "time
plus 1"

See `?SpaDES.core::times()`.

::: {.callout-tip appearance="simple"}
## Time in `SpaDES`

It is useful to understand `time` in SpaDES. Time has units (e.g.,
"year") which is defined by the modules metadata `timeunit`. So, if
`time(sim)` is `1` or `2024`, that would be in `year` units, if the
module is in `year`. To know what "time" it is in a module, the easiest
function is `time(sim)`. That will give you the "time".

Time, in SpaDES, is a way of ordering events. If one event happens at
time 2024, and another event happens at 2025, then the 2024 event will
happen first.

The other two useful functions are `start(sim)` and `end(sim)`, which
will give you the starting time of the `spades` call and ending time
respectfully. These would have been specified in `simInit`.
:::

```{r predictionEvent}
switch(
  eventType,
  init = {...},
  predictions = {
    # do the Prediction
    sim <- Prediction(sim)
    
    # schedule the next Prediction
    sim <- scheduleEvent(sim, time(sim) + 1, "scheduling", "predictions") 
  },
  ...
)
```

::: {.callout-tip appearance="simple"}
## Top-down vs Bottom-up workflow sequencing

In a "top-down" workflow, we could imagine something like:

```{r, eval=FALSE}
scheduleEvent(sim, time(sim) + 1, "predictions")
scheduleEvent(sim, time(sim) + 2, "predictions")
scheduleEvent(sim, time(sim) + 3, "predictions")
```

This would schedule 3 *predictions*, during the next three "time steps".
This may be very clear, but it would be difficult to do this for dozens
of years (could be done with a for-loop).

A "bottom up" approach is to schedule the *predictions* event once, then
each time that *predictions* event occurs, reschedule it.

```{r,eval=FALSE}
init = {
  scheduleEvent(sim, time(sim), "predictions")
}

predictions = {
  scheduleEvent(sim, time(sim) + 1, "predictions")
}
```

Each time the *predictions* event happens, it will reschedule itself
forever! Very simple. The workflow sequence emerges from the
self-scheduling.
:::

### Double check existing events

If we ran the above changes, we would see an error because `plotFn` is,
by default, scheduled to run at the time that is specified by
`.plotInitialTime`, which by default is `start(sim)`. We have no data
yet at that time. So, we will choose to schedule `plotFn` to run at
`end(sim)`:

```{r}
scheduleEvent(sim, end(sim), "scheduling", "plot")
```

### Update module metadata

Like in @sec-moduleFilesAndMetadata, we have to update the module
metadata... what the inputs, outputs, parameters *are*. `SpaDES` will
not error if the metadata are not correct, but it will try to point out
the problems.

Here's an example:

```{r}
createsOutput(objectName = "predictions", objectClass = "data.frame", 
              desc = "Table of predictions and years")
```

## Run

The resulting module can now be run.

```{r run}
SpaDES.core::simInitAndSpades(modules = "scheduling", paths = list(modulePath = "~/SpaDES_book/scheduling"))
```

A complete version of this new module can be found at
[scheduling.R](https://github.com/PredictiveEcology/PredictiveEcology.org/blob/training-book/tutos/scheduling/scheduling/scheduling.R).
You can copy this over top of the new module that you created here,
i.e., keep the same folder structure.

## Questions

1.  how are some ways that `scheduleEvent` is different from a "loop"?

    -   We can change the "step" length between events.
    
    -   We can interweave events, e.g., a fire event then a tree growth
        event

<!-- -->

2.  When is a loop better than scheduling?

    -   Loops are much faster than scheduling.
    
    -   But really, avoid loops in R if you can help it

<!-- -->

3.  Chances are that the first versions of this module didn't work. How
    do you fix it?
    
    -   [Learn how to debug in R and
        SpaDES](https://github.com/PredictiveEcology/SpaDES/wiki/Debugging)


## Try on your own

-   Try creating a new parameter that controls the frequency of predictions.
    
    Here's a clue:
    ```
    predictions = {
      scheduleEvent(sim, time(sim) + P(sim)$predFreq, "predictions")
    }    
    ```


## See also

@sec-modseventsfuns on Modules, Events and Functions

[`?scheduleEvent`](https://rdrr.io/cran/SpaDES.core/man/scheduleEvent.html)

[`?P`](https://rdrr.io/cran/SpaDES.core/man/params.html)

[`?time`](https://rdrr.io/cran/SpaDES.core/man/simList-accessors-times.html)

[`?start`](https://rdrr.io/cran/SpaDES.core/man/simList-accessors-times.html)

[`?end`](https://rdrr.io/cran/SpaDES.core/man/simList-accessors-times.html)

## More learning on this subject

[My First
Module](https://spades-workshops.predictiveecology.org/articlesMay2018/MyFirstModule.html)

[Creating a seed dispersal
module](https://spades-workshops.predictiveecology.org/articles/02c-Convert_R_code_to_SpaDES_module.html)
