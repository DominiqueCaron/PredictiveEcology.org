{
  "hash": "c4247d9903fe3c7fc3b9f24cda645d2f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'New Module - Introduction'\nformat: \n  html:\n    page-layout: full\ncomments: false\neditor_options: \n  chunk_output_type: console\n---\n\n\nSpaDES modules are comprised of R code that has metadata and the gets put into functions. With this in mind, we can start with some simple R code.\n\nWe will start by thinking about metadata: *What is metadata?*\n\nWe can examine the following code chunk. First, we ask: what are the **inputs** and the **outputs**?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create some data\nx <- y + rnorm(10)\n# fit a linear model\nout <- lm(x ~ y)\n\n# plot the fit\nplot(out)\n```\n:::\n\n\nThe **inputs** to this chunk are just one: the object `y`. This code will not work (i.e., it will cause an error) if `y` is not defined. The **outputs** are `x` and `out`. Both of these are created within this chunk.\n\nNext, *what are the package dependencies?*. We see that there are two functions: `rnorm` and `lm`. We don't know what packages they are in, so we can find out by typing them at the R prompt. At the bottom, it says that the function `rnorm` is in the `stats` package. Fortunately for us, this is a default (\"base\") package in R and it is always pre-loaded. So, nothing to do here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> rnorm\nfunction (n, mean = 0, sd = 1) \n...\n<environment: namespace:stats>\n```\n:::\n\n\nSo, our metadata are:\n\n-   Inputs: `y`\n-   Outputs: `x`, `out`\n-   Package dependencies: Base packages only\n\nWe will next put them into the correct places in the new SpaDES module.\n\n### Make the module\n\nNow we use the `SpaDES` function `newModule` to make a new module. (see )\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSpaDES.core::newModule(name = \"My_linear_model\", path = \".\")\n```\n:::\n\n\nThis will create a new folder with several files in it. See `?newModule` for details. For now, run the above and open the `.R` that is created.\n\n### Edit metadata\n\nScroll down to where it says `inputObjects` and `expectsInputs`. We will put `y` there.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninputObjects = bindrows(\n    expectsInput(objectName = \"y\", objectClass = \"numeric\", desc = \"The inputs for the linear model\", sourceURL = NA)\n  )\n```\n:::\n\n\nNext, scroll down to where it says `outputObjects` and `createsOutput`. We will put `x` and `out` there. Don't forget a comma at the end of each `createsOutput` as these are arguments to `bindrows`\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutputObjects = bindrows(\n    createsOutput(objectName = \"x\", objectClass = \"numeric\", desc = \"The randomly created varible that is used as a response variable\"),\n    createsOutput(objectName = \"out\", objectClass = \"lm\", desc = \"A linear model object from the equation (x ~ y)\")\n  )\n```\n:::\n\n\n### Put code in `Init` function\n\nFirst, we move the first two lines of code into a function. We will choose the `Init` function. We will discuss why in a bit.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nInit <- function(sim) {\n  x <- y + rnorm(10)\n  out <- lm(x ~ y)\n  return(invisible(sim))\n}\n```\n:::\n\n\n### Sharing inputs and outputs\n\nYou may have noticed that the `Init` function template defines a function with a `sim` argument. This is an object we haven't learned about yet; we will just think of it as a list where we can put objects we want to share with other modules or \"just keep them for later\", such as our **inputs** and **outputs**.\n\nTo share these objects, we assign them to the `sim` list using the normal R notations. We have to make this modification 5 times for every instance of our **inputs** and **outputs**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nInit <- function(sim) {\n  sim$x <- sim$y + rnorm(10)\n  sim$out <- lm(sim$x ~ sim$y)\n  return(invisible(sim))\n}\n```\n:::\n\n\nNow we have a module that creates two objects, `x` and `out` and puts them in the `sim` objects. This all happens in a function called `Init`. Next: the `plot(out)`\n\n### Events\n\nWe can look at our 3 lines of example and think, \"this is 2 steps: a first that does the model and a second that plots it\" (of course, you can divide this up in several ways; we will go with this for now.).\n\nWe can call the 2 steps, **events** and imagine we could run them in sequence... first, lets put the `plot` in a function. We will choose the `plotFun` function. We will also add the `sim$` because the `out` will be shared because it is in the `sim` \"list\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotFun <- function(sim) {\n  plot(sim$out)\n  return(invisible(sim))\n}\n```\n:::\n\n\nThe template already has some default code that actually puts the events in an order without us needing to do anything. It also has a parameter that determines whether the plot will happen or not. We will just accept the defaults for now.\n\n### Default Values\n\nRecall, we don't have a value for `y`. This means that if you run the following, you will get an error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSpaDES.core::simInitAndSpades(modules = \"My_linear_model\", paths = list(modulePath = \"tutos/NewModuleIntro\"))\n```\n:::\n\n\nJust like functions in R, we can supply default values for our **inputs**. We put these in a function at the bottom called `.inputObjects`.\n\nCopy this to the module, replacing the `.inputObjects` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.inputObjects <- function(sim) {\n  if (!suppliedElsewhere(\"y\", sim))\n    sim$y <- rnorm(10, mean = 20, sd = 2)\n  return(invisible(sim))\n}\n```\n:::\n\n\n## Run the new module\n\nNow, we have **inputs** and **outputs** defined, our code has been place in 2 spots, and we have default value for `y`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSpaDES.core::simInitAndSpades(modules = \"My_linear_model\", paths = list(modulePath = \"tutos/NewModuleIntro\"))\n```\n:::\n\n\nWe now have a SpaDES module that has metadata, generates random starting data (if the user doesn't supply an alternative), fits a linear model, outputs that model, and plots the fit.\n\n## Questions\n\n1.  What are some things we \"gained\" from putting our simple 3 lines of code into a module?\n\n-   We can turn off plotting easily. Set `.plotInitialTime = NA` in the `simInitAndSpades` call.\n\n2.  What are some things we \"lost\"?\n\n-   More complicated. (overkill for these 3 lines?)\n\n3.  What if we used an R package that wasn't in the base packages list?\n\n-   See `?defineModule` for all the metadata items. Specifically, see `reqdPkgs`.\n\n4.  What is the `sim`? See `?simList`\n\n## See also\n\nSee also: `?expectsInput`, `?createsOutput`, `?simInitAndSpades`, `?newModule`\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}