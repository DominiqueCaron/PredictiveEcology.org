[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Robust and nimble scientific workflows, using SpaDES",
    "section": "",
    "text": "Preface\nThis book is a work in progress. Please visit this again as chapters are being added and modified.\nThe approaches presented here use the SpaDES family of packages and associated packages, like reproducible and Require, that we have developed to face a variety of issues that we experienced during our own journeys as modellers and, more generally, scientists.\nMany of these issues we faced because most of us were ecologists by training (not computer scientists, not engineers, etc.), who lacked a strong programming foundation. So, we expect many who have other backgrounds and maybe very strong programming skills to find this set of solutions foreign and perhaps unnecessary, limited, or over-complicated for many applications outside the realm of ecological sciences. We certainly don’t expect NASA scientists to overhaul their own workflows and follow ours – but feel free too and send us your feedback!\nThis book is therefore focused on the many ways that models and data, including the data generated through models, can be used for decision making, reproducibility of publications, and reused across different applications and modelling contexts, etc. By working towards a set of standards for our data and modeling workflows, our science can become more nimble. We can thus pivot and update as issues come up.\nWe hope that many ecologists and those in related sciences (e.g. forestry, wildlife management, etc.), academics or practitioners, can appreciate the value of aligning their work with the R3T1, PERFICT2 and nimbleness principles and find these solutions useful. Mostly we hope that those that work with ecosystems can embrace these tools to work towards expanding the abilities of the community to become robust to any scrutiny we face.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Robust and nimble scientific workflows, using SpaDES",
    "section": "",
    "text": "Repeatability, Reproducibility, Reusability and Transparency↩︎\nPredict regularly from models that are Evaluated, Reusable, Freely accessible, and Interoperable, and that are part of Continuous workflows that are Tested regularly (McIntire et al. 2022).↩︎",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Why SpaDES?\nSpaDES is a set of R packages that facilitate implementing nimble workflows that follow in the principles of repeatability, reproducibility, reusability and transparency (R3T), via the creation and use of highly modular code that has metadata attached.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#why-spades",
    "href": "intro.html#why-spades",
    "title": "Introduction",
    "section": "",
    "text": "Modularity\nModular code for ecological analyses has been long proposed (Reynolds and Acock 1997). Modularity means that scripts can be broken up into themes that bundled into meaningful chunks that can be easily moved, swapped, replaced or scrapped easily. A nice example of this is Barros et al. (2023) where a module was included or removed to identify the value of “adding more complexity”. One simple conclusion followed Occam’s Razor: simpler data and models predicted simpler characteristics of the forest more accurately than the complex data and models. In other words, adding complexity to a model made the model perform worse for some characteristics.\n\n\nMetadata\nMetadata in a SpaDES context includes identifying what objects  are expected by a chunk of code and what objects are created by a chunk of code: the inputs and outputs. This forces a user to understand their code and its linkages, and it allows R to know how to connect this chunk of code with others. Importantly, it allows SpaDES to chain modules such that the workflow structure can be defined from the bottom-up, rather than top-down.\n\n\nNimbleness\nTogether SpaDES’s modularity, standardized structure and metatada, improve workflow nimbleness, where we can weave together new Results that use new data, updated data, a new module, a new study area, a new visualization, address new stakeholder’s needs and more.\n\nAren’t packages and functions sufficient?\nScientists have embraced the idea of modular code by creating and using functions, often bundled into packages, e.g., R packages. This is analogous to the Methods section of a journal paper: i.e., the methods (functions) describe how you will do something. The use of packages in this way has massively accelerated Ecology and other data sciences.\nHowever, even if you know all the functions that a paper used, this in itself is not sufficient to reproduce the Results. SpaDES modules can be thought of the recipe needed to make the Results. In other words, a SpaDES module enables a developer to bundle the functions in a specific order so that one can recreate the steps to make the Results. A user can then use the module directly, rather instead of trying to recreate the necessary sequence of functions.\n\n\n\nFunctions and modules as key tools to achieve workflow nimbleness. From McIntire et al. (2022).\n\n\n\n\n\nI use targets for my workflows. How does SpaDES differ?\ntargets is an R package (descendant of drake), very similar to GNU Make, that facilitates building data analyses pipelines.\nThere are two major differences between targets and the SpaDES approach:\n\ntargets is “top-down”, SpaDES is “bottom-up” – with targets, the workflow is entirely defined by the script developer (as in Make). This is, they define the connections and the sequence between each “target” (the code sections that call functions and execute operations), when they will be iterated and for “how many times”. Re-arranging “targets” sequences and iterations may therefore be hard, if the “target” code is not well known/understood.\nSpaDES is meant to enable mixing-and-matching different modules that share the same inputs/outputs easily – i.e. without having to have deep knowledge of the module code. SpaDES will read each module’s metadata and from it deduce the sequence in which modules need to be chained. SpaDES will also iterate module code when necessary, following the developer’s “scheduling” instructions. The workflow sequence, therefore, arises from the set of modules that is being used1.\nSpaDES has “embedded” metadata – or at least it makes the developer think about it2. Each module is defined by listing not only the inputs and outputs, but also their descriptions and types of object class, the module’s description, its operating time scale, package and module dependencies, and much more. Some of the metadata is essential to chain modules (lists of inputs and outputs), some is not but can greatly facilitate workflow setup (e.g. declaring module dependencies), while other metadata is simply good to have (e.g. a description of the module).\n\nFinally, both targets and SpaDES have embedded caching mechanisms, which in SpaDES can be controlled at several levels (by the user, inside the module code, etc.) – see 10  Introduction to Cache on SpaDES caching mechanisms.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#spades-applied-ecology",
    "href": "intro.html#spades-applied-ecology",
    "title": "Introduction",
    "section": "SpaDES & applied ecology",
    "text": "SpaDES & applied ecology\nSpaDES development was, and continues to be, strongly motivated by our attempts to answer important issues in applied ecology.\n\n\n\n\n\n\nThe three big problems in applied ecology\n\n\n\nApplied ecology – the application of ecological science to questions related to the effects of human activities on ecosystems – is challenged and motivated by three main problems:\n\nmany species are declining or uncontrollably increasing\nmany ecological processes (like fire, food web dynamics, productivity) are changing\nconservation and management problems require trans-disciplinary solutions\n\n\n\nAlongside these problems, ecologists must grapple with new expectations for how they do their work to inform these problems.\n\nNew expectations\nApplied ecologists of the 21st century are expected more and more to uphold standards of nimbleness, broad participation and scrutiny.\nAnalyses must be able to respond quickly to new data, new insights, new drivers, and new management needs; projects must include knowledge and participation from outside the scientific community and be relevant to non-scientific audiences; and they must accept and embrace scientific and non-scientific scrutiny.\nThese expectations are not independent of each other. Greater nimbleness allows for easier participation by others and scrutiny benefits from the participation of a broad range of specialists and non-specialists.\nMeeting these expectations requires the R3T:\n\nrepeatability – analyses must be able to produce the same results, when using the exact same context (e.g. same user, same machine setup);\nreproducibility – analyses must be able to produce the same results by others and into the future;\nreusability – the methodology must be easy to transfer and expand in a different context;\ntransparency – analyses must be able to be inspected, understood, and scrutinized by many eyes;\n\nbut also\n\nforecasting – analyses must demonstrate that they are proving reliable insights into the future, not just the past or theoretical expectation;\nvalidation – analyses must clearly demonstrate why they should be trusted and used;\nopen-data/open-models – raw data, parameters, model algorithms have to be (freely) accessible as much as possible;\ntesting – models and predictions should be continuously tested.\n\nTogether these 10 requirements (and a little more) are encompassed by the PERFICT principles for applied ecological modelling (McIntire et al. 2022).\n\n\n\n\n\n\nPERFICT\n\n\n\n\nPredict regularly from models that are\nEvaluated,\nReusable,\nFreely accessible, and\nInteroperable, and that are part of\nContinuous workflows that are\nTested regularly\n\n\n\nIt can be very challenging to fulfill these expectations, especially for non-programmers.\nSpaDES aims to help (applied) ecologists “get there” by relieving ecologists from needing to know/learn advanced computer programming (e.g. developing caching mechanisms) and offering tools that will enable them to develop PERFICT workflows.\n\n\n\n\n\nIt does so by harnessing the flexibility of R, the contributions of its vast community and knowing what tools applied ecologists (and modellers) often need.\n\n\n\n\n\n\nTip 1: reproducible::prepInputs a tool that will make your life easier\n\n\n\nApplied ecologists often need to get a raw spatial layer from somewhere (locally, a data repository), make it conform to a given study area and even change it to a given spatial projection or resolution.\nThey also often need to do this for many layers.\nreproducible::prepInputs facilitates this process in a single function call by having the ability to:\n\ndownload from a data repository URL;\nspatially process the data according to a polygon or raster template\n\nIt also caches these operations, so taht they don’t need to be repeated unnecessarily.\nThis can save hours of learning to master caching and GIS algorithms (or avoid using flawed approaches) for many ecologists!\n\n\nThe SpaDES set of R packages is full of tools like prepInputs (Tip 1).\nThis book is intended to show applied ecologists (and whoever else!) the approaches that we use to bring our work closer to the PERFICT principles, better meet the expectations, and better address the problems.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#our-challenge",
    "href": "intro.html#our-challenge",
    "title": "Introduction",
    "section": "Our challenge",
    "text": "Our challenge\nWith the limited training provided in this book, applied ecologists can work towards creating PERFICT workflows. Embracing the transparency and nimbleness it provides, we can pivot more rapidly to the current management needs. When we are asked at the end of a 3-year project, “can we redo everything because we have a new stakeholder who feels that our assumptions are wrong?”, our answer should be “yes”.\n\n\n\n\nBarros, Ceres, Yong Luo, Alex M. Chubaty, Ian M. S. Eddy, Tatiane Micheletti, Céline Boisvenue, David W. Andison, Steven G. Cumming, and Eliot J. B. McIntire. 2023. “Empowering Ecological Modellers with a PERFICT Workflow: Seamlessly Linking Data, Parameterisation, Prediction, Validation and Visualisation.” Methods in Ecology and Evolution 14 (1): 173–88. https://doi.org/10.1111/2041-210X.14034.\n\n\nMcIntire, Eliot J. B., Alex Chubaty, Steve Cumming, David Andison, Ceres Barros, Céline Boisvenue, Samuel Hache, Yong Luo, Tatiane Micheletti, and Frances Stewart. 2022. “PERFICT: A Re-Imagined Foundation for Predictive Ecology.” Ecology Letters. https://doi.org/10.22541/au.163252535.52485317/v1.\n\n\nReynolds, James F., and Basil Acock. 1997. “Modularity and Genericness in Plant and Ecosystem Models.” Ecological Modelling 94 (1): 7–16. https://doi.org/10.1016/S0304-3800(96)01924-2.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "Introduction",
    "section": "",
    "text": "Note that SpaDES still allows a user to impose module sequencing if they wish to.↩︎\nSpaDES won’t force most metadata to be filled, so it’s at the discretion of the module developer how much detail they want to provide.↩︎",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "settingUp.html",
    "href": "settingUp.html",
    "title": "Setting up your computer and system",
    "section": "",
    "text": "This brief section shows how to set up R, RStudio, SpaDES, and pre-install R packages necessary to run all chapter code, if you need to do so.",
    "crumbs": [
      "Setting up your computer and system"
    ]
  },
  {
    "objectID": "installRandSpatialPkgs.html",
    "href": "installRandSpatialPkgs.html",
    "title": "1  Installing R and Spatial Packages",
    "section": "",
    "text": "1.1 Install R",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Installing R and Spatial Packages</span>"
    ]
  },
  {
    "objectID": "installRandSpatialPkgs.html#install-r",
    "href": "installRandSpatialPkgs.html#install-r",
    "title": "1  Installing R and Spatial Packages",
    "section": "",
    "text": "1.1.1 Windows\n\nDownload and run the R installer (as administrator!).\nDownload and install the Rtools version that matches the installed R version. Be sure to check the “add Rtools to PATH” option during installation if necessary (Rtools v4.0).\n\n\n\n1.1.2 macOS\n\nDownload and run the R installer from https://cran.r-project.org/bin/macosx.\nInstall Xcode commandline tools from the terminal:\n\nxcode-select --install\n\nInstall homebrew from the terminal (instructions at https://brew.sh/)\nInstall GDAL and other spatial packages (instructions at https://www.alexchubaty.com/post/2020-01-08-using-latest-gdal-macos-redux/)\nInstall OpenMP support for data.table:\n\nbrew update && brew install llvm\n\nInstall GLPK (needed for full igraph functionality; used with SpaDES.core::moduleGraph):\n\nbrew install glpk\nThen, in R, install igraph from source so it is compiled with GLPK:\ninstall.packages(\"igraph\", type = \"source\")\n\n\n1.1.3 Linux\nInstall via apt or yum depending on your distribution. Instructions for Ubuntu 18.04 LTS are shown below.\n\nInstall R and its development libraries:\n\nsudo apt install r-base r-base-dev\n\nInstall java and configure R to use it:\n\nsudo apt build-dep -y r-cran-rjava\nsudo R CMD javareconf\n\nInstall dependencies for spatial and other packages:\n\nsudo apt build-dep -y r-cran-tkrplot\n\nsudo apt-get install -y \\\nccache \\\ngdal-bin \\\ngit \\\nlibcairo2-dev \\\nlibcurl4-gnutls-dev \\\nlibgdal-dev \\\nlibgeos-dev \\\nlibgit2-dev \\\nlibgmp-dev \\\nlibjq-dev \\\nlibmagick++-dev \\\nlibproj-dev \\\nlibprotobuf-dev \\\nlibprotoc-dev \\\nlibssh2-1-dev \\\nlibssl-dev \\\nlibudunits2-dev \\\nlibv8-dev \\\nlibxml2-dev \\\nlibxt-dev \\\npandoc \\\npandoc-citeproc \\\nprotobuf-compiler \\\npython-gdal \\\npython3-gdal \\\ncurl \\\nr-cran-littler",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Installing R and Spatial Packages</span>"
    ]
  },
  {
    "objectID": "installRandSpatialPkgs.html#troubleshooting",
    "href": "installRandSpatialPkgs.html#troubleshooting",
    "title": "1  Installing R and Spatial Packages",
    "section": "1.2 Troubleshooting",
    "text": "1.2 Troubleshooting\nFor Mac users, it may be helpful to use brew doctor:\nbrew doctor\nIf you are still not able with the above instructions, you may be able to follow these more in-depth instructions.",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Installing R and Spatial Packages</span>"
    ]
  },
  {
    "objectID": "installRandSpatialPkgs.html#see-also",
    "href": "installRandSpatialPkgs.html#see-also",
    "title": "1  Installing R and Spatial Packages",
    "section": "1.3 See also",
    "text": "1.3 See also\nHands on programming with R",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Installing R and Spatial Packages</span>"
    ]
  },
  {
    "objectID": "PackagesForBook.html",
    "href": "PackagesForBook.html",
    "title": "2  Pre-installing R packages for book",
    "section": "",
    "text": "2.1 Installation code\nIf you can run the following code, then you will be able to run code in any of the chapters in this book. This code begins by installing SpaDES.project and its dependencies, then uses setupProject to download and install a list of R packages hosted on GitHub and a single SpaDES module (Biomass-core) which has over 130 package dependencies.\nCode\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\ninstall.packages(c(\"Require\", \"SpaDES.project\"), repos = repos)\n\nlibrary(SpaDES.project)\n\nout &lt;- setupProject(\n  packages = \"PredictiveEcology/PredictiveEcology.org@training-book/training/R/pkgList.R\",\n  options = list(repos = repos),\n  name = \"Introduction\",\n  modules = \"PredictiveEcology/Biomass_core@main\"\n)\nNote that setupProject will change your working directory to ./Introduction. If that is not where you want to keep working, restart R and make sure you set your working directory to where you want it to be (if restarting is not sufficient).",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Pre-installing R packages for book</span>"
    ]
  },
  {
    "objectID": "PackagesForBook.html#code-explained",
    "href": "PackagesForBook.html#code-explained",
    "title": "2  Pre-installing R packages for book",
    "section": "2.2 Code explained",
    "text": "2.2 Code explained\nIf you care to know what the code is “doing”, read on.\nThe setupProject call above internally uses Require to download and install any missing packages. Although the packages themselves are installed in a folder inside ./Introduction/ (the project folder) (see .libPaths() after running the code), Require caches the downloaded package installation files in a user-accessible folder (so independent from any project).\nThis means that, should you, e.g., switch projects and attempt to reinstall the same or a subset of these packages, setupProject (via Require) would access the package cache and reinstall them in whatever new project folder library. This is much faster than downloading the packages again.\nThe same is true should you lose internet connection, since the downloads do not need to happen again.",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Pre-installing R packages for book</span>"
    ]
  },
  {
    "objectID": "PackagesForBook.html#see-also",
    "href": "PackagesForBook.html#see-also",
    "title": "2  Pre-installing R packages for book",
    "section": "2.3 See also",
    "text": "2.3 See also\nChapter 3 on R package installation troubleshooting",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Pre-installing R packages for book</span>"
    ]
  },
  {
    "objectID": "PackagesForBook.html#footnotes",
    "href": "PackagesForBook.html#footnotes",
    "title": "2  Pre-installing R packages for book",
    "section": "",
    "text": "See this introduction to R3T workflows.↩︎",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Pre-installing R packages for book</span>"
    ]
  },
  {
    "objectID": "TroubleshootingPackageInstallation.html",
    "href": "TroubleshootingPackageInstallation.html",
    "title": "3  Troubleshooting R package installation",
    "section": "",
    "text": "3.1 General diagnosing tools\nThe following help diagnose many of the issues mentioned below.",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Troubleshooting R package installation</span>"
    ]
  },
  {
    "objectID": "TroubleshootingPackageInstallation.html#general-diagnosing-tools",
    "href": "TroubleshootingPackageInstallation.html#general-diagnosing-tools",
    "title": "3  Troubleshooting R package installation",
    "section": "",
    "text": "loadedNamespaces() shows which packages are actually loaded\nsessionInfo() shows several other things as well, including package versions. Very useful when called after restarting R to see if there are any packages being pre-loaded\npackageVersion(\"&lt;packagename&gt;\") shows which version of the package your session currently has access to (already loaded or on disk in the library but not yet loaded). It might not necessarily correspond to the installed version.",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Troubleshooting R package installation</span>"
    ]
  },
  {
    "objectID": "TroubleshootingPackageInstallation.html#cant-install-a-package",
    "href": "TroubleshootingPackageInstallation.html#cant-install-a-package",
    "title": "3  Troubleshooting R package installation",
    "section": "3.2 Can’t install a package",
    "text": "3.2 Can’t install a package\n\n3.2.1 Package has already been loaded\nSome packages have files that cannot be deleted if they are being used in the current or another R session. This is primarily true for packages with compiled code. This will create several cascading problems, even after restarting the current R session.\n\n3.2.1.1 Potential solutions\n\nRestart R – The number one solution for many problems is to restart R. If using RStudio, the keyboard shortcut is commonly CTRL-SHIFT-F10.\nClose other R or RStudio sessions – If you have more than one session open, each one may have packages loaded. That means you can’t install (update), delete or uninstall a package that has already been loaded elsewhere.\nClose RStudio and install in a separate R session – By default, RStudio pre-loads packages before user input. This is convenient under some conditions, but is very difficult to deal with when it doesn’t work correctly – e.g. when these packages need to be updated. You may have to close RStudio, open a separate R session (without RStudio) and install the packages there.\nUpdate packages in user library – Package versions may collide between the user library and the project library. Try to update the packages in the user library. To determine where this is, you can try:\nuserLib &lt;- Sys.getenv(\"R_LIBS_USER\")\nthen update the packages there:\nupdate.packages(userLib, ask = FALSE)\nTurn off R diagnostics – Alternatively (or in complement) to the solution above, you can turn off R code diagnostics (temporarily or permanently), in your RStudio’s Global Options. This can greatly reduce the number of pre-loaded packages at the expense of losing some RStudio functionality. Via RStudio GUI:\n\n\nGo to Tools &gt; Global Options &gt; Code\n\nOpen the Diagnostics tab, and uncheck “Show diagnostics for R”\n\nRestart R after doing the above. Try the package installations again. If they fail again, see other solutions and try them.\n\n\n\nTurning of R diagnostics with RStudio – a potential solution to prevent RStudio from pre-loading several R packages.\n\n\nAlternatively, you can:\n\n\nCode\ninstall.packages(\"RStudio.prefs\")\nRStudio.prefs::use_RStudio_prefs(\nshow_diagnostics_r = FALSE\n)\n\n\n\n\nTurn off previous R session reloading – If R is reloading a previously saved session (loading an .Rdata file) this may also be loading the packages attached to this previous session. You can turn off this feature off (temporarily or permanently), in your RStudio’s Global Options. Via the RStudio GUI:\n\nGo to Tools &gt; Global Options &gt; General and uncheck “Restore .RData into workspace at startup:`\n\n\n\n\nTurning of restoring previous R session with RStudio – a potential solution to prevent R from loading R packages used in a previous session.\n\n\n\n\n\n\n3.2.2 00LOCK folder issues\nOnce a package installation failure happened and interrupted the process, there may be a 00LOCK folder that R cannot remove, nor overwrite. R can’t install anything until that 00LOCK folder is removed.\n\n3.2.2.1 Potential solutions\n\nDelete 00LOCK folder(s) – The error message of the package installation failure will indicate if this is the issue and tell you where the 00LOCK folder is located. Make sure all other R sessions are closed and that the current session is restarted (and possibly closed), before deleting the 00LOCK folder. Then try installing the package again. If you can’t delete it, ensure RStudio and R are completely closed and possibly other software such as Git version control software (e.g. GitKraken, Bitbucket).\n\n\n\n\n3.2.3 Missing dependencies\nAlthough this happens less and less because functions like install.packages now default to installing package dependencies, it can still happen that one of the target package’s dependencies is missing or failed to install. The error message will indicate which one, but bear in mind that when installing many packages/dependencies, the reason why the dependency wasn’t installed may be buried in previous messages and warnings. So read the installation output carefully.\n\n3.2.3.1 Potential solutions\nThe solution will depend on the reason why the dependency package failed to install. See solutions in Package has already been loaded and 00LOCK folder issues.\n\n\n\n3.2.4 Package version cannot be met or found\nWhen Require is used to install packages1, it uses various caching mechanisms. If a package can’t be found, or there is an unexplainable installation failure clearing the package cache may fix it.\n\n3.2.4.1 Potential solutions\nTry purging the cache with one or more of these:\n\n\nCode\n## Can't find the package remotely\nRequire::purgeCache()\n\n## Can't install a particular package, e.g., ggplot2\nRequire::clearRequirePackageCache(packages = \"ggplot2\")\n\n## The above didn't work, clear ALL packages from local cache\nRequire::purgeCache(packages = TRUE)",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Troubleshooting R package installation</span>"
    ]
  },
  {
    "objectID": "TroubleshootingPackageInstallation.html#installed-a-package-but-it-isnt-showing-up",
    "href": "TroubleshootingPackageInstallation.html#installed-a-package-but-it-isnt-showing-up",
    "title": "3  Troubleshooting R package installation",
    "section": "3.3 Installed a package, but it isn’t showing up",
    "text": "3.3 Installed a package, but it isn’t showing up\n\n3.3.1 You installed it to a different library\nAs people migrate to using “project” libraries, i.e., a unique R package library for each project, sometimes, the user library (the one that you get by default with a normal R installation) can cause problems.\n\n3.3.1.1 Potential solutions\n\nBecome aware of user vs. project library – .libPaths() is your friend. It tells you what folder the current R session is using as a package library. The default place for a personal library in R depends on operating system. For windows, it is something like:\n\n\n\nCode\n&gt; Sys.getenv(\"R_LIBS_USER\") [1] \"C:\\\\Users\\\\emcintir\\\\AppData\\\\Local/R/win-library/4.4\"}\n\n\nFor Linux, it is something like:\n\n\nCode\n&gt; Sys.getenv(\"R_LIBS_USER\") [1] \"/home/emcintir/R/x86_64-pc-linux-gnu-library/4.3\"}\n\n\nIf you have a project-specific library, including if you use SpaDES.project or renv, .libPaths() will point to somewhere else. For SpaDES.project it will be something like:\n\n\nCode\n# Windows \n&gt; .libPaths() [1] \"C:/Users/emcintir/AppData/Roaming/R/data/R/SpaDES.project/packages/x86_64-w64-mingw32/4.4\"  \n\n# Linux \n&gt; .libPaths() [1] \"/home/emcintir/.local/share/R/SpaDES.project/packages/x86_64-pc-linux-gnu/4.3\"}\n\n\nWhen you install a package, ensure it was installed in the correct location.\n\n\n\n3.3.2 Package loaded in RAM collides with package on disk\nIf you previously loaded a package via e.g., library(ggplot2), then you happen to update it to a newer version, the newer version will be on disk in your library, but packageVersion(\"ggplot2\") will show the older one. Restart R and it will be solved.",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Troubleshooting R package installation</span>"
    ]
  },
  {
    "objectID": "TroubleshootingPackageInstallation.html#see-also",
    "href": "TroubleshootingPackageInstallation.html#see-also",
    "title": "3  Troubleshooting R package installation",
    "section": "3.4 See also",
    "text": "3.4 See also\nAn alternative way to address package management is using the renv package. Some people have great success with this. Some of us find it not very amenable to modular workflows.",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Troubleshooting R package installation</span>"
    ]
  },
  {
    "objectID": "TroubleshootingPackageInstallation.html#footnotes",
    "href": "TroubleshootingPackageInstallation.html#footnotes",
    "title": "3  Troubleshooting R package installation",
    "section": "",
    "text": "For instance, SpaDES.project functions and SpaDES.core::simInit() internally use Require to install package dependencies specified by the user or modules.↩︎",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Troubleshooting R package installation</span>"
    ]
  },
  {
    "objectID": "SpaDESbasics.html",
    "href": "SpaDESbasics.html",
    "title": "SpaDES 101",
    "section": "",
    "text": "The following chapters cover the basics of working with SpaDES.\nWe introduce fundamental pieces of SpaDES workflows, namely modules, events and functions. We show how to create simple modules and link them in simple workflows, the “simulation” object – the simList – module metadata and an introduction to caching mechanisms in SpaDES.\nBy the end of this chapter you should understand how SpaDES modules are comprised of events that are automatically scheduled and run by the SpaDES.core::simInit and SpaDES.core::spades functions (or SpaDES.core::simInitAndSpades which groups the previous two).\n\n\n\nThree modules, caribou, vegetation and harvest, each with two events that are scheduled in a yearly or monthly sequence",
    "crumbs": [
      "SpaDES 101"
    ]
  },
  {
    "objectID": "NewModuleIntro.html",
    "href": "NewModuleIntro.html",
    "title": "4  Introduction to SpaDES Modules",
    "section": "",
    "text": "4.1 Some R code to convert\nCode\n# create some data\nx &lt;- rnorm(10)\ny &lt;- x + rnorm(10)\n# fit a linear model\nmodel &lt;- lm(y ~ x)\n\n# plot the fit\nplot(model)\nLooking at this code above, we can imagine that the first 3 lines are conceptually different – fit a dummy model – from the last line – visualize it. Let’s put these into 2 “modules”, and then run them in sequence.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "NewModuleIntro.html#create-a-module",
    "href": "NewModuleIntro.html#create-a-module",
    "title": "4  Introduction to SpaDES Modules",
    "section": "4.2 Create a module",
    "text": "4.2 Create a module\nWe use the SpaDES.core function newModule() to make a new module.\nStep 1 – move the code to an “init” event. This “init” event is a convention that SpaDES uses. A module must always have an “init” event. This is the only code that is “definitely run” in a module.\n\n\nCode\nRequire::Require(c(\"reproducible\", \"SpaDES.core (&gt;= 2.1.5)\"), \n                 repos = c(\"https://predictiveecology.r-universe.dev\", getOption(\"repos\")))\n\n# make a module\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nSpaDES.core::newModule(name = \"My_linear_model\", \n                       path = modulePath, \n                       open = FALSE,\n                       events = list(\n                         init = {\n                           x &lt;- rnorm(10)\n                           y &lt;- x + rnorm(10)\n                           # fit a linear model\n                           model &lt;- lm(y ~ x)\n                         }\n                       ))\n\n\nYou may get a warning related with the testthat R package not being available. This is fine.1\nKeeping objects\nFor now, we just say, if you want to keep an object, assign it to “sim”. We will explain this in much more detail later. Here, we want to keep the model that we fit. But we don’t care about the x and y. So we assign the model to sim.\n\n\nCode\n# make a module\nSpaDES.core::newModule(name = \"My_linear_model\", \n                       path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           x &lt;- rnorm(10)\n                           y &lt;- x + rnorm(10)\n                           # fit a linear model\n                           sim$model &lt;- lm(y ~ x)     #  &lt;--------- change to sim$\n                         }\n                       ))\n\n\nHow would we run this “init” event? We use simInit, which parses the code (like loading a library or sourcing a function) then spades, which executes it.\n\n\nCode\nout &lt;- simInit(modules = \"My_linear_model\", \n               paths = list(modulePath = modulePath))\nout &lt;- spades(out)\n\n\nWe can look at the output:\n\n\nCode\nout$model\n\n\nWe can also look at “what ran”… or in other words, what was our workflow. Of course, this will just be one “user-created” event (there are 4 “SpaDES-created” events … we may use them later, ignore for now)\n\n\nCode\ncompleted(out)\n\n\nWe have our first “simple workflow”! 1 chunk of code :)\n\n\n\n\n\n\nsimInit() before spades()\n\n\n\nSpaDES.core::simInit() always has to be called before SpaDES.core::spades().\nsimInit() will initialise the workflow simList object that spades() uses to execute the workflow.\nSee Chapter 7 for more detail about the simList\n\n\n\n4.2.1 Add a second module\nOur next step is to divide the pieces into conceptual chunks. Let’s now create a new module for the plot … a “visualization module”.\n\n\nCode\nSpaDES.core::newModule(\"visualize\", path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           plot(sim$model)\n                         }\n                       )\n)\n\n\nAnd now we run both together. We name them both in the module argument. We are using simInitAndSpades which is a shortcut to running the two functions separately.\n\n\nCode\nout2 &lt;- simInitAndSpades(module = c(\"My_linear_model\", \"visualize\"), \n                         paths = list(modulePath = modulePath))\n\n\nWe can look at the output again:\n\n\nCode\nout2$model\n\ncompleted(out2)\n\n\nThis time, there is an extra event that happened. We now have a workflow of 2 events.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "NewModuleIntro.html#try-on-your-own",
    "href": "NewModuleIntro.html#try-on-your-own",
    "title": "4  Introduction to SpaDES Modules",
    "section": "4.3 Try on your own",
    "text": "4.3 Try on your own\n\nMake a new module. Make it really simple. Run it with simInitAndSpades as in the above examples.\n\nUse sim$ for an object that will be outputted.\n\nMake a second new module that uses the sim$ object.\n\nAdd another new object in sim$\n\nMake a third new module that uses the sim$ object from the 2nd module.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "NewModuleIntro.html#see-also",
    "href": "NewModuleIntro.html#see-also",
    "title": "4  Introduction to SpaDES Modules",
    "section": "4.4 See also",
    "text": "4.4 See also\nsimList accessors\n?simInitAndSpades\n?newModule",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "NewModuleIntro.html#barebones-r-script",
    "href": "NewModuleIntro.html#barebones-r-script",
    "title": "4  Introduction to SpaDES Modules",
    "section": "4.5 Barebones R script",
    "text": "4.5 Barebones R script\n\n\nCode\n# create some data\nx &lt;- rnorm(10)\ny &lt;- x + rnorm(10)\n# fit a linear model\nmodel &lt;- lm(y ~ x)\n\n# plot the fit\nplot(model)\n\nRequire::Require(c(\"reproducible\", \"SpaDES.core (&gt;= 2.1.5)\"), \n                 repos = c(\"https://predictiveecology.r-universe.dev\", getOption(\"repos\")))\n\n# make a module\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nSpaDES.core::newModule(name = \"My_linear_model\", \n                       path = modulePath, \n                       open = FALSE,\n                       events = list(\n                         init = {\n                           x &lt;- rnorm(10)\n                           y &lt;- x + rnorm(10)\n                           # fit a linear model\n                           model &lt;- lm(y ~ x)\n                         }\n                       ))\n\n# make a module\nSpaDES.core::newModule(name = \"My_linear_model\", \n                       path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           x &lt;- rnorm(10)\n                           y &lt;- x + rnorm(10)\n                           # fit a linear model\n                           sim$model &lt;- lm(y ~ x)     #  &lt;--------- change to sim$\n                         }\n                       ))\n\nout &lt;- simInit(modules = \"My_linear_model\", \n               paths = list(modulePath = modulePath))\nout &lt;- spades(out)\n\nout$model\n\ncompleted(out)\n\nSpaDES.core::newModule(\"visualize\", path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           plot(sim$model)\n                         }\n                       )\n)\n\nout2 &lt;- simInitAndSpades(module = c(\"My_linear_model\", \"visualize\"), \n                         paths = list(modulePath = modulePath))\n\nout2$model\n\ncompleted(out2)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "NewModuleIntro.html#footnotes",
    "href": "NewModuleIntro.html#footnotes",
    "title": "4  Introduction to SpaDES Modules",
    "section": "",
    "text": "We use the testthat package to automate module and code testing. By default, newModule() creates a tests folder inside the module folder that is designed to be used with testthat , hence the warning if this package has not been installed.↩︎",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introduction to SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html",
    "href": "MetaDataAndModuleFiles.html",
    "title": "5  Module Files and Metadata",
    "section": "",
    "text": "5.1 Continue example – a linear model\nWe will start by thinking about metadata: What is metadata?\nSlightly modifying the example, we remove the line with x &lt;- rnorm(10). This will make the code chunk not work because it needs the x to run the next line. We can examine the following code chunk. First, we ask: what are the inputs and the outputs?\nCode\n# create some data\ny &lt;- x + rnorm(10)\n# fit a linear model\nmodel &lt;- lm(y ~ x)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#input-expectations-output-creations-and-required-packages",
    "href": "MetaDataAndModuleFiles.html#input-expectations-output-creations-and-required-packages",
    "title": "5  Module Files and Metadata",
    "section": "5.2 Input Expectations, Output Creations and Required Packages",
    "text": "5.2 Input Expectations, Output Creations and Required Packages\n\n5.2.1 Inputs and Outputs\nWe use the terms expectsInput and createsOutput to describe the inputs and outputs in the metadata. This makes it clear that the metadata do not specify which they will go get; rather, it makes it clear that it doesn’t matter where the inputs are coming from. They could come from one of three sources: a user, another module, or defaults that the developer sets up. Likewise, the module specifies which outputs it creates, without specifying “for what other module”.\nThe inputs to this chunk are just one: the object x. This code will not work (i.e., it will cause an error) if x is not defined. We can say that this code chunk “expects” x as an input.\nThe outputs are y and model. We can say that this code chunk “creates” y and model as outputs. However, we had said in Chapter 4 that we would only be interested in keeping model. So, we will continue with only one output, model.\n\n\n5.2.2 Required Packages\nNext, what are the package dependencies?. We call this reqdPkgs in the SpaDES metadata. We see that there are three functions: rnorm, lm and plot. We don’t know what packages they are in, so we can find out by typing them at the R prompt. At the bottom of the function, it says that the function rnorm is in the stats package. Fortunately for us, this is a default (“base”) package in R and it is always pre-loaded. So, nothing to do here.\n\n\nCode\n&gt; rnorm function (n, mean = 0, sd = 1)  ... \n&lt;environment: namespace:stats&gt;}\n\n\nSo, our expectations, creations and dependencies are:\n\nInputs: x\nOutputs: model\nPackage dependencies: Base packages only\n\nWe will next put them into the correct places in the new SpaDES module.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#module-files",
    "href": "MetaDataAndModuleFiles.html#module-files",
    "title": "5  Module Files and Metadata",
    "section": "5.3 Module files",
    "text": "5.3 Module files\nMake the module again (see Chapter 4). This time we will add sim$ for the x as we are now interested in the fact that it might be coming from outside this module.\n\n\nCode\nRequire::Require(c(\"reproducible\", \"SpaDES.core\"), repos = c(\"https://predictiveecology.r-universe.dev\", getOption(\"repos\")))\n\n# make a module\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nSpaDES.core::newModule(name = \"My_linear_model\", path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           y &lt;- sim$x + rnorm(10)      # &lt;--------- add sim$ here\n                           # fit a linear model\n                           sim$model &lt;- lm(y ~ sim$x)  # &lt;--------- add sim$ here\n                         }\n                       ))\n\n\n\n\n\n\n\n\nnewModule() is not part of the “workflow”\n\n\n\nBe aware that every time newModule() is run with the same name and path arguments, it will overwrite your module folder/files.\nAs such, it is not meant to be part of a workflow. It is meant to provide the user with a tool to create module templates (once), which will then be changed as the module code develops.\n\n\nWhere is this module code? In the previous chapter, we didn’t look or care where the module code was.\nnewModule actually creates a new folder, with the name as provided by the argument, in the folder specified with path. This folder has several files in it. See ?newModule for details. For now, run the above and open the My_linear_model.R script that it creates.\nWhen we make a module, we get a message stating where the module code is. From here, open the file, e.g., by copy-pasting the file path (pick the .R file NOT the .Rmd file for now).\nYou can also set newModule(..., open = TRUE) to have RStudio open the .R and .Rmd files automatically.\n\n\n\n\n\n\nOpening a module file\nFrom here onward, we will need to manually open the module code file.\nEvery SpaDES module is defined by having at least 1 file that is named with &lt;modulePath&gt;/&lt;moduleName&gt;/&lt;moduleName&gt;.R. Even though we can do a lot with newModule(), we will need to get used to opening, examining and changing the code in the module code file.\n\n\n\nWe will look at a few elements on the module R script in this chapter.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#inputobjects",
    "href": "MetaDataAndModuleFiles.html#inputobjects",
    "title": "5  Module Files and Metadata",
    "section": "5.4 inputObjects",
    "text": "5.4 inputObjects\nScroll down to inputObjects and expectsInputs(). This is where we will put our inputs that we noticed in our code chunk. We will declare x as an “input” by putting it there, like this:\n\n\nCode\ninputObjects = bindrows(\n  expectsInput(objectName = \"x\", objectClass = \"numeric\", \n               desc = \"The inputs for the linear model\", sourceURL = NA)\n)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#outputobjects",
    "href": "MetaDataAndModuleFiles.html#outputobjects",
    "title": "5  Module Files and Metadata",
    "section": "5.5 outputObjects",
    "text": "5.5 outputObjects\nNext, scroll down to outputObjects and createsOutput(). We will declare model as an “output” by putting it there. Don’t forget the comma at the end of each createsOutput() as each is an argument to bindrows (unless it is the last one).\n\n\nCode\noutputObjects = bindrows(\n  createsOutput(objectName = \"model\", objectClass = \"lm\", \n                desc = \"A linear model object from the equation (x ~ y)\")\n)\n\n\nNote that each input and output object gets a expectsInput or createsOutput entry, respectively.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#default-values",
    "href": "MetaDataAndModuleFiles.html#default-values",
    "title": "5  Module Files and Metadata",
    "section": "5.6 Default Values",
    "text": "5.6 Default Values\nRecall, we don’t have a value for x, unlike in the previous chapter where we had x defined in the init event. This means that if you run the following, you will get an error.\n\n\nCode\nout &lt;- simInit(modules = \"My_linear_model\", paths = list(modulePath = modulePath))\nout &lt;- spades(out)\n\n# or \nout &lt;- simInitAndSpades(modules = \"My_linear_model\", paths = list(modulePath = modulePath))\n\nout$model\n\n\nJust like functions in R, we can supply default values for our module inputs. We put these in a function at the bottom called .inputObjects(). See Chapter 6 for a model detailed explanation of module inputs and how to deal with them.\nCopy this to the module, replacing the template .inputObjects() function.\n\n\nCode\n.inputObjects &lt;- function(sim) {\n  if (!suppliedElsewhere(\"x\", sim))\n    sim$x &lt;- rnorm(10, mean = 20, sd = 2)\n  return(invisible(sim))\n}\n\n\n!suppliedElsewhere(\"x\", sim) will check if x is in sim and if not, will run the subsequent code lines (see ?suppliedElsewhere).\nAfter saving the module R script, we can run the module and inspect the output\n\n\nCode\nout &lt;- simInitAndSpades(modules = \"My_linear_model\", paths = list(modulePath = modulePath))\n\nout$model",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#sharing-inputs-and-outputs",
    "href": "MetaDataAndModuleFiles.html#sharing-inputs-and-outputs",
    "title": "5  Module Files and Metadata",
    "section": "5.7 Sharing inputs and outputs",
    "text": "5.7 Sharing inputs and outputs\nYou may have noticed that the init event is now placed into a function called doEvent.My_linear_model.init and it has an argument sim. If you are familiar with making functions in R, this is just a named argument \"sim\". This means that we can use sim inside the function. We don’t know what sim is yet, and we don’t know how to use it fully yet. But we do know that we have added sim$ to the init event. We also see that there is a return(sim) added at the bottom of the event function.\n\n\n\n\n\n\nAn event occurs in a special function that starts with doEvent.. But, since it is “in a function”, each event has all the features of a function:\n\narguments – specifically sim can be used\nsomething returned – in this case, the simList. return(sim) must always be present - it is by default, but don’t delete it!\nit can be run– but don’t worry about running it; SpaDES runs it when it is time.\n\n\n\n\n\n\n\n\n\n\nThe simList\nThe simList is the data structure that is the foundation of SpaDES. It can be used like a list; accessing objects can be done with $ or [[\"object_name\"]], for example, and objects are manipulated as they would normally – e.g. if DF is a data.frame one would use sim$DF[1, 3] to extract the value on the first row and third column.\nIn any function that has an argument sim, we pass the simList, so we can access it with sim$ from inside such a function.\nSee Chapter 7 for more details about the simList.\n\n\n\nTo share objects between modules, we must assign them to the sim and make sure that return(sim) is at the end of the function.\nNow we have a module that creates one object, model and puts them inside sim. This all happens in the event called init.\nNext: add the visualization module with metadata",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#adding-a-new-module-visualization-module",
    "href": "MetaDataAndModuleFiles.html#adding-a-new-module-visualization-module",
    "title": "5  Module Files and Metadata",
    "section": "5.8 Adding a new module: visualization module",
    "text": "5.8 Adding a new module: visualization module\nWe remake the second module from last chapter. But this time we will look at and update the metadata.\n\n\nCode\nnewModule(\"visualize\", path = modulePath, open = FALSE,\n          events = list(\n            init = {\n              plot(sim$model)\n            }\n          )\n)\n\n\n\n5.8.1 Outputs of one module are Inputs of another\nHere we start to see the “shared” objects. The module we just made above createsOutput of model. But this new visualization module will expectInput of model. So, we can copy the same description if it is the same.\n\n\nCode\ninputObjects = bindrows(\n  expectsInput(objectName = \"model\", objectClass = \"lm\", \n               desc = \"A linear model object from the equation (x ~ y)\", sourceURL = NA)\n)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#run-the-new-module",
    "href": "MetaDataAndModuleFiles.html#run-the-new-module",
    "title": "5  Module Files and Metadata",
    "section": "5.9 Run the new module",
    "text": "5.9 Run the new module\nNow, we have inputs and outputs defined, our code has been places in 2 spots (events), and we have default value for x.\n\n\nCode\nsimInitAndSpades(modules = c(\"My_linear_model\", \"visualize\"), \n                 paths = list(modulePath = modulePath))\n\n\nWe now have a SpaDES module that has metadata, generates random starting data (if the user doesn’t supply an alternative), fits a linear model, outputs that model, and plots the fit.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#questions",
    "href": "MetaDataAndModuleFiles.html#questions",
    "title": "5  Module Files and Metadata",
    "section": "5.10 Questions",
    "text": "5.10 Questions\n\nWhat are some things we “gained” from putting our simple 3 lines of code into a module?\n\nWe can turn off plotting easily. Set .plotInitialTime = NA in the simInitAndSpades call.\n\nWhat are some things we “lost”?\n\nMore complicated. (overkill for these 3 lines?)\n\nWhat if we used an R package that wasn’t in the base packages list?\n\nSee ?defineModule for all the metadata items. Specifically, see reqdPkgs.\n\nWhat is the sim? See ?'.simList-class'",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#try-on-your-own",
    "href": "MetaDataAndModuleFiles.html#try-on-your-own",
    "title": "5  Module Files and Metadata",
    "section": "5.11 Try on your own",
    "text": "5.11 Try on your own\n\nFill in the metadata from the Challenges you did in previous chapter.\nLook at the other elements of the metadata and cross reference them with ?defineModule\nLook at the Rmd file of one of the modules that has been built (recall the message after you call newModule), where you have filled in the metadata. Try to build it and look at the automatic tables that get built from the metadata.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#common-mistakes",
    "href": "MetaDataAndModuleFiles.html#common-mistakes",
    "title": "5  Module Files and Metadata",
    "section": "5.12 Common mistakes",
    "text": "5.12 Common mistakes\nSome common mistakes/bugs that module developers encounter:\n\nObject doesn’t exist/is NULL. Errors like the ones below are usually the result of not providing default values for an input in the simList (via .inputObjects()), the user/another module not providing values for that object, or forgetting to assign an object to the simList (i.e. sim$y &lt;- &lt;...&gt;) See Chapter 6.\nError in model.frame.default(formula = y ~ sim$x, drop.unused.levels = TRUE) : \ninvalid type (NULL) for variable 'sim$x'\n\nError in eval(predvars, data, env) : object 'y' not found\nParsing errors. These happen when simInit has issues reading the module R script (or other associated scripts) and are usually easy to debug by reading the error message. For instance, the one below indicates that lines 43, 44, have a problem, which is a missing comma after the “)”. Error in parse(filename) :      C:&lt;modulePath&gt;/My_linear_model/My_linear_model.R:44:3: unexpected symbol     43:   )     44:   outputObjects       ^\nEnvironment- and simList-related error. If the simList (sim) is not returned at the end of a function that takes it as an argument – e.g. an event function, the .inputObjects() function… – it will either be lost or changed into something unexpected. Below are two examples of errors that may announce this problem.\nError in &lt;...&gt;\nsim must be a simList\n\nError in as.environment(pos) : invalid 'pos' argument",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#see-also",
    "href": "MetaDataAndModuleFiles.html#see-also",
    "title": "5  Module Files and Metadata",
    "section": "5.13 See also",
    "text": "5.13 See also\nChapter 8 on Modules, Events and Functions\nChapter 6 on how to provide Module Inputs\nChapter 7 on the simList\n?defineModule describes all the metadata entries.\n?expectsInput\n?createsOutput\n?simInitAndSpades\n?newModule\n?SpaDES.project::setupProject\n?SpaDES.core::simInit\n?SpaDES.core::simInitAndSpaDES",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#barebones-r-script",
    "href": "MetaDataAndModuleFiles.html#barebones-r-script",
    "title": "5  Module Files and Metadata",
    "section": "5.14 Barebones R script",
    "text": "5.14 Barebones R script\n\n\nCode\n# create some data\ny &lt;- x + rnorm(10)\n# fit a linear model\nmodel &lt;- lm(y ~ x)\n\n\n\nRequire::Require(c(\"reproducible\", \"SpaDES.core\"), repos = c(\"https://predictiveecology.r-universe.dev\", getOption(\"repos\")))\n\n# make a module\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nSpaDES.core::newModule(name = \"My_linear_model\", path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           y &lt;- sim$x + rnorm(10)      # &lt;--------- add sim$ here\n                           # fit a linear model\n                           sim$model &lt;- lm(y ~ sim$x)  # &lt;--------- add sim$ here\n                         }\n                       ))\n\n\n\n\n\nout &lt;- simInit(modules = \"My_linear_model\", paths = list(modulePath = modulePath))\nout &lt;- spades(out)\n\n# or \nout &lt;- simInitAndSpades(modules = \"My_linear_model\", paths = list(modulePath = modulePath))\n\nout$model\n\n\n\nout &lt;- simInitAndSpades(modules = \"My_linear_model\", paths = list(modulePath = modulePath))\n\nout$model\n\nnewModule(\"visualize\", path = modulePath, open = FALSE,\n          events = list(\n            init = {\n              plot(sim$model)\n            }\n          )\n)\n\n\n\nsimInitAndSpades(modules = c(\"My_linear_model\", \"visualize\"), \n                 paths = list(modulePath = modulePath))",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "ModuleInputs.html",
    "href": "ModuleInputs.html",
    "title": "6  Providing Module Inputs",
    "section": "",
    "text": "6.1 How to supply Inputs\nThere are several ways to get objects into the simList:\nUltimately, it is the last of these that is the power of SpaDES. i.e., modularity.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Providing Module Inputs</span>"
    ]
  },
  {
    "objectID": "ModuleInputs.html#how-to-supply-inputs",
    "href": "ModuleInputs.html#how-to-supply-inputs",
    "title": "6  Providing Module Inputs",
    "section": "",
    "text": "User passes during simInit:\nusing the objects argument (if it is an object);\nusing the inputs argument (if it is from disk);\nusing the params argument;\nDeveloper creates defaults and specifies them in defineParameter() and .inputObjects;\nA different module creates them prior to the running of this module.\n\n\n\n6.1.1 During simInit\nA user can directly pass objects into the simInit and these will be put into the simList\n\n\nCode\na &lt;- 1\nsim &lt;- SpaDES.core::simInit(objects = list(a = a))\nsim$a\n\n\n[1] 1\n\n\nor do pass them via an .rds file\n\n\nCode\nb &lt;- 1\ntf &lt;- tempfile(fileext = \".rds\")\nsaveRDS(b, file = tf)\nsim &lt;- SpaDES.core::simInit(inputs = data.frame(object = \"b\", file = tf))\nsim$b\n\n\n[1] 1\n\n\nBecause parameters are usually module-specific, and need to be passed to with reference to a module. “Global” parameters are the exception to this rule:\n\n\nCode\nc &lt;- 1\nsim &lt;- SpaDES.core::simInit(params = list(.globals = list(c = c)))\nSpaDES.core::params(sim)$.globals$c\n\n\n[1] 1\n\n\nTo pass parameters to a module, we go back to out simple module and make a minor change:\n\n\nCode\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nSpaDES.core::newModule(name = \"My_linear_model\", path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           x &lt;- rnorm(P(sim)$length)\n                           y &lt;- x + rnorm(P(sim)$length)\n                           # fit a linear model\n                           model &lt;- lm(y ~ x)\n                         }\n                       ))\n\n\nNow we open My_linear_model.R and add the following\n\n\nCode\ndefineParameter(\"length\", \"integer\", 10L, 5L, 100L,\n                \"Number of values to generate\")\n\n\n… to the module metadata section for parameters. Remember to save the file after you’re done.\n\n\nCode\ndefineModule(\n  &lt;...&gt;\n    parameters = bindrows(\n      # here\n      &lt;...&gt;\n    )\n  &lt;...&gt;\n)\n\n\nNow run the the module:\n\n\nCode\nout2 &lt;- SpaDES.core::simInitAndSpades(modules = \"My_linear_model\",\n                                      paths = list(modulePath = modulePath))\nparams(out2)   # can you find the length parameter?\n\n\n\n\n6.1.2 .inputObjects\nFor every Input that is specified in the metadata, the module developer has the option of specifying a default. In R, functions can be given defaults when they are defined like this:\n\n\nCode\nrnormMean5 &lt;- function(n = 1) { # the n = 1 is the default value\n  rnorm(n = n, mean = 5)\n}\nrnormMean5() # can be run without any arguments\n\n\n[1] 2.771965\n\n\nThis works for only the simplest cases. In the case of a module, objects can be arbitrarily complicated and so this approach will not be suitable.\nInstead, there is a function that is called every time a module is initialized (i.e. by simInit()) where a developer can put anything they want to specify as defaults. It is generally most useful to use if (!SpaDES.core::suppliedElsewhere(\"obj\", sim)) i.e., if the object isn’t in sim, then give it a value.\n\n\nCode\n.inputObjects &lt;- function(sim) {\n  \n  if (!suppliedElsewhere(\"y\", sim)) {\n    sim$y &lt;- rnorm(100)\n  }\n  \n  return(invisible(sim))\n}\n\n\n\n6.1.2.1 Advanced .inputObjects example\nIn the Biomass_core module (this is an implementation of the LANDIS-II Biomass Succession Extension v3.2), there are many Inputs as defined in the metadata. The module needs each one of these to work.\nThe developers have created a .inputObjects function that will fill in these Inputs with defaults if the user hasn’t supplied them (using !SpaDES.core::suppliedElsewhere()).\nWe will look at a few examples in this module: Biomass_core::.inputObjects.\n\nsome GIS tests that evaluate whether 2 objects are in the same CRS (i.e., they need to be the same projection, etc., for this module to work)\nif an object is missing, it may make sense to fill in the details with parameters from the Internet.\nan object called studyArea. The developer tests whether it exists and creates an error if it does not exist.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Providing Module Inputs</span>"
    ]
  },
  {
    "objectID": "ModuleInputs.html#questions",
    "href": "ModuleInputs.html#questions",
    "title": "6  Providing Module Inputs",
    "section": "6.2 Questions",
    "text": "6.2 Questions\n\nIn .inputObjects, why don’t we just write if (!is.null(sim$y))? See ?SpaDES.core::suppliedElsewhere\n\n\nIt turns out that other modules may create this object “after” this module is run, and this test will fail.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Providing Module Inputs</span>"
    ]
  },
  {
    "objectID": "ModuleInputs.html#try-on-your-own",
    "href": "ModuleInputs.html#try-on-your-own",
    "title": "6  Providing Module Inputs",
    "section": "6.3 Try on your own",
    "text": "6.3 Try on your own\n\nUsing the My_linear_model shown above, try running simulations where you pass different values to the length parameter\nTip: have a look at the params argument of SpaDES.core::simInitAndSpades()",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Providing Module Inputs</span>"
    ]
  },
  {
    "objectID": "ModuleInputs.html#see-also",
    "href": "ModuleInputs.html#see-also",
    "title": "6  Providing Module Inputs",
    "section": "6.4 See also",
    "text": "6.4 See also\n?SpaDES.core::expectsInputs\n?SpaDES.core::suppliedElsewhere\n?SpaDES.core::defineParameter\n?SpaDES.core::simInit\n?SpaDES.core::simInitAndSpades",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Providing Module Inputs</span>"
    ]
  },
  {
    "objectID": "ModuleInputs.html#barebones-r-script",
    "href": "ModuleInputs.html#barebones-r-script",
    "title": "6  Providing Module Inputs",
    "section": "6.5 Barebones R script",
    "text": "6.5 Barebones R script\n\n\nCode\na &lt;- 1\nsim &lt;- SpaDES.core::simInit(objects = list(a = a))\nsim$a\n\nb &lt;- 1\ntf &lt;- tempfile(fileext = \".rds\")\nsaveRDS(b, file = tf)\nsim &lt;- SpaDES.core::simInit(inputs = data.frame(object = \"b\", file = tf))\nsim$b\n\nc &lt;- 1\nsim &lt;- SpaDES.core::simInit(params = list(.globals = list(c = c)))\nSpaDES.core::params(sim)$.globals$c\n\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nSpaDES.core::newModule(name = \"My_linear_model\", path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           x &lt;- rnorm(P(sim)$length)\n                           y &lt;- x + rnorm(P(sim)$length)\n                           # fit a linear model\n                           model &lt;- lm(y ~ x)\n                         }\n                       ))\n\n\n\n\n\nout2 &lt;- SpaDES.core::simInitAndSpades(modules = \"My_linear_model\",\n                                      paths = list(modulePath = modulePath))\nparams(out2)   # can you find the length parameter?\n\nrnormMean5 &lt;- function(n = 1) { # the n = 1 is the default value\n  rnorm(n = n, mean = 5)\n}\nrnormMean5() # can be run without any arguments",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Providing Module Inputs</span>"
    ]
  },
  {
    "objectID": "simList.html",
    "href": "simList.html",
    "title": "7  The simList - What is it?",
    "section": "",
    "text": "7.1 Where does simList come from?\nThere is only one way in SpaDES.core to create a simList:",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#where-does-simlist-come-from",
    "href": "simList.html#where-does-simlist-come-from",
    "title": "7  The simList - What is it?",
    "section": "",
    "text": "using simInit() creates a simList object.1",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#how-can-we-specify-a-simlist",
    "href": "simList.html#how-can-we-specify-a-simlist",
    "title": "7  The simList - What is it?",
    "section": "7.2 How can we specify a simList?",
    "text": "7.2 How can we specify a simList?\nA simList object is simply a structured data type containing various elements.\nThe main components of a simList are:\n\nA list of modules used;\nThe event queue;\nA description of the data (object) dependencies.\n\nWe can examine the simList object structure in the usual R fashion by printing (showing) it, or by using str():\n\n\nCode\nemptySim &lt;- SpaDES.core::simInit()\nemptySim  # same as show(emptySim)\nstr(emptySim)\n\n\n\n\n\n\n\n\nsimLists are S4 objects, so we can use getSlots() and slotNames() to examine the object.\nSee also ?'simList-class'",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#accessing-the-parts-of-a-simlist",
    "href": "simList.html#accessing-the-parts-of-a-simlist",
    "title": "7  The simList - What is it?",
    "section": "7.3 Accessing the parts of a simList",
    "text": "7.3 Accessing the parts of a simList\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe simList can be imagined as a file cabinet where all the simulation details and objects (i.e. the parameters, inputs and outputs declared by each module) are stored neatly and in an easily accessible way.\n\n\n\n\n\n\n\n\n\n\n7.3.1 Initialize/create and inspect an empty simList object\n\n\nCode\nemptySim &lt;- simInit()\n\n\n\nWhat are the names of each of the slots in the simList?\nWhat do each of these slots contain?\nHint: see ?'simList-class'\n\n\n\nCode\nstr(emptySim)\nslotNames(emptySim)\ngetSlots('simList')\n?`simList-class`\n\n\n\n7.3.1.1 simList accessor functions\nsimList accessor functions are used to determine the following:\n\nthe modules included in the simulation and their package dependencies;\nthe global parameter values used;\nthe module-specific parameter values used;\nthe simulation start, end and current times;\nthe time units used by the modules in the simulation;\nthe scheduled and completed event queues;\nthe objects (functions, data, etc.) used in the simulation;\nthe file paths used for simulation inputs and outputs.\n\nWe will try this with the simple linear module first, for which we’ve already defined default values for the input object x (see Chapter 5).\n\n\nCode\n# Get the sample modules that come with SpaDES.core\n\nmodulePath &lt;- getSampleModules(tempdir())\n# options(spades.loadReqdPkgs = FALSE) # we don't need to check for packages in this example\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nmySim &lt;- simInit(params = list(\"My_linear_model\" = list(length = 20)),\n                 modules = \"My_linear_model\",\n                 paths = list(modulePath = modulePath))\nevents(mySim)\n\n# b is in the .xData slot\nmySim$x\nmySim@.xData$x\n\n# all functions below come from SpaDES.core::\n# list modules used in the simulation\nmodules(mySim)\n\n# list module dependencies and packages used\ndepends(mySim)\npackages(mySim)\n\n# list global and module-specific param values\nparams(mySim)\nP(mySim)       # bonus: how do params() and P() differ?\n\n# list start and end times\ntimes(mySim)\nstart(mySim)\nend(mySim)\n## and the 'current' time\ntime(mySim)\n\n# get the simulation and module timeunits\ntimeunit(mySim)\ntimeunits(mySim)\n\n# get the scheduled and completed event queues\nevents(mySim)\ncompleted(mySim)\n\n# list the objects (functions, data, etc.) stored in the simList\nobjects(mySim)\n\n# list the file paths used in the simulation\npaths(mySim)\ninputPath(mySim)\noutputPath(mySim)\n\n\nNow run the simulation\n\n\nCode\nmySimOut &lt;- reproducible::Copy(mySim) # make a deep copy of the simList\nmySimOut &lt;- spades(mySimOut)\n\n\n\n\n\n\n\n\nsimNew &lt;- sim doesn’t copy\n\n\n\nIf you don’t know what an environment is in R, it is OK. The most important feature of an environment is that it employs pass-by-reference, which means it is not copied when it is “assigned” somewhere. This makes SpaDES fast enough to use for huge workflows.\n\n\nCode\nsim &lt;- simInit()\nsim$a &lt;- 1\nsimNew &lt;- sim\nsimNew$a &lt;- 2\n\n# what value will this have?\nsim$a\n\n\n\n\n\n\n\n7.3.2 Compare the simList before and after spades()\n\n\nCode\ntimes(mySim)\ntimes(mySimOut)\n\nobjects(mySim)\nobjects(mySimOut)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#try-on-your-own",
    "href": "simList.html#try-on-your-own",
    "title": "7  The simList - What is it?",
    "section": "7.4 Try on your own",
    "text": "7.4 Try on your own\n\nRepeat the above with more complex modules. Use the accessor functions to look at what inside the simList and try passing different parameter values or inputs.\n\n\nCode\nmodulePath &lt;- getSampleModules(tempdir())\n# options(spades.loadReqdPkgs = FALSE) # we don't need to check for packages in this example\nmySim &lt;- simInit(modules = dir(modulePath[1:3]),\npaths = list(modulePath = modulePath),\nobjects = list(b = 1))\nsimOut &lt;- spades(mySim)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#see-also",
    "href": "simList.html#see-also",
    "title": "7  The simList - What is it?",
    "section": "7.5 See also",
    "text": "7.5 See also\nEnvironments - Advanced R\n?'simList-class'\n?SpaDES.core::envir\n?SpaDES.core::simInit\n?SpaDES.core::spades",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#barebones-r-script",
    "href": "simList.html#barebones-r-script",
    "title": "7  The simList - What is it?",
    "section": "7.6 Barebones R script",
    "text": "7.6 Barebones R script\n\n\nCode\n# this is in the .GlobalEnv\na &lt;- 1\nenvironment()  ## the current environment is .GlobalEnv\nglobalenv()  ## the same\n\nls(envir = environment())\n\nRequire::Require(c(\"reproducible\", \"SpaDES.core  (&gt;= 2.1.5)\"),\n                 repos = c(\"https://predictiveecology.r-universe.dev\", getOption(\"repos\")))\n\nsim &lt;- simInit()\nsim$a &lt;- 1\nsim$b &lt;- sim$a + 2\nsim$b\nSpaDES.core::envir(sim)\n\nsim &lt;- simInit()\nis(sim, \"environment\")\n# [1] TRUE\n\nemptySim &lt;- SpaDES.core::simInit()\nemptySim  # same as show(emptySim)\nstr(emptySim)\n\n\n\n\n\nemptySim &lt;- simInit()\n\nstr(emptySim)\nslotNames(emptySim)\ngetSlots('simList')\n?`simList-class`\n\n# Get the sample modules that come with SpaDES.core\n\nmodulePath &lt;- getSampleModules(tempdir())\n# options(spades.loadReqdPkgs = FALSE) # we don't need to check for packages in this example\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nmySim &lt;- simInit(params = list(\"My_linear_model\" = list(length = 20)),\n                 modules = \"My_linear_model\",\n                 paths = list(modulePath = modulePath))\nevents(mySim)\n\n# b is in the .xData slot\nmySim$x\nmySim@.xData$x\n\n# all functions below come from SpaDES.core::\n# list modules used in the simulation\nmodules(mySim)\n\n# list module dependencies and packages used\ndepends(mySim)\npackages(mySim)\n\n# list global and module-specific param values\nparams(mySim)\nP(mySim)       # bonus: how do params() and P() differ?\n\n# list start and end times\ntimes(mySim)\nstart(mySim)\nend(mySim)\nand the 'current' time\ntime(mySim)\n\n# get the simulation and module timeunits\ntimeunit(mySim)\ntimeunits(mySim)\n\n# get the scheduled and completed event queues\nevents(mySim)\ncompleted(mySim)\n\n# list the objects (functions, data, etc.) stored in the simList\nobjects(mySim)\n\n# list the file paths used in the simulation\npaths(mySim)\ninputPath(mySim)\noutputPath(mySim)\n\nmySimOut &lt;- reproducible::Copy(mySim) # make a deep copy of the simList\nmySimOut &lt;- spades(mySimOut)\n\nsim &lt;- simInit()\nsim$a &lt;- 1\nsimNew &lt;- sim\nsimNew$a &lt;- 2\n\n# what value will this have?\nsim$a\n\ntimes(mySim)\ntimes(mySimOut)\n\nobjects(mySim)\nobjects(mySimOut)\n\nmodulePath &lt;- getSampleModules(tempdir())\n# options(spades.loadReqdPkgs = FALSE) # we don't need to check for packages in this example\nmySim &lt;- simInit(modules = dir(modulePath[1:3]),\npaths = list(modulePath = modulePath),\nobjects = list(b = 1))\nsimOut &lt;- spades(mySim)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#footnotes",
    "href": "simList.html#footnotes",
    "title": "7  The simList - What is it?",
    "section": "",
    "text": "Note that simInitAndSpades calls simInit internally↩︎",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html",
    "href": "ModulesAndEvents.html",
    "title": "8  Modules, Events and Functions",
    "section": "",
    "text": "8.1 Modules\nModules include the following elements:\nThere are many optional pieces too. The default template produces many of these optional pieces, which means it is “noisy”. This also means we can ignore most of it for now.\nOptional pieces include:\nThese are all contained within a file structure like this, with other optional files:\nTo make a new module, see: Chapter 4.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#modules",
    "href": "ModulesAndEvents.html#modules",
    "title": "8  Modules, Events and Functions",
    "section": "",
    "text": "a function call to defineModule that defines the metadata (mandatory)\na function definition for doEvent.moduleName (mandatory)\n\n\n\n\nother functions in the R folder or the main moduleName.R file\na documentation file (moduleName.rmd)\n\n\n/moduleRepository\n  |_ moduleName/\n      |_ R/                     # contains additional/optional .R (helper) files\n      |_ data/                  # directory for all included data\n          |_ CHECKSUMS.txt      # contains checksums for data files\n      |_ tests/                 # contains (optional) unit tests for module code\n      |_ citation.bib           # bibtex citation for the module\n      |_ LICENSE.txt            # describes module's legal usage\n      |_ moduleName.R           # module code file (incl. metadata)\n      |_ moduleName.Rmd         # documentation, usage info, etc.\n\n\n\n\n\n\n\nHow to decide whether to make a module, or expand an existing one?\n\n\n\nThere’s no fixed rule about when it is best to create a module vs. expand another existing module. This decision will depend on various factors, but at least two questions should be considered when making a decision:\n\nIs the additional code a very small operation, or something that will never be disassociated from a current module? If the answer is “yes”, then perhaps expanding the existing module is the way to go.\nCan we foresee that swapping between algorithms/approaches will be desired in the future? E.g., knowing that an ordinary least square regression could, in the future, be swapped by a mixed effects model to compare model performance – i.e. both approaches are valid and we want eventually to have both. If the answer is “yes”, then creating a new module will allow greater flexibility in the future.\n\nWe usually see “data preparation” and “model calibration” steps as semi-independent from “prediction/simulation steps” and have typically created “data preparation”/“calibration” modules to keep these steps separate, and to allow swapping between different approaches to preparing inputs for a model.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#events",
    "href": "ModulesAndEvents.html#events",
    "title": "8  Modules, Events and Functions",
    "section": "8.2 Events",
    "text": "8.2 Events\nEvents are named chunks of code that can be scheduled to be run once or many times. These are scheduled with scheduleEvent(). There are several commonly occurring module types that can be grouped based on the events that they contain (see Section 8.4).\nTo see how to schedule events, see: Chapter 9.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#functions",
    "href": "ModulesAndEvents.html#functions",
    "title": "8  Modules, Events and Functions",
    "section": "8.3 Functions",
    "text": "8.3 Functions\nEssentially, everything in R is or uses functions. Modules define events (doEvent.*moduleName*), events call specific functions (we some times call the main function an event calls an “event function”, but there can be other nested functions within these), and functions can be defined within modules, R packages, or user code contained in .R scripts inside the module’s R/ folder.\nWe would not define functions in the .GlobalEnv.\n\n8.3.1 Adding functions\nAny function can be written and defined in any .R file in the R folder, just like an R package. They can also be placed in the main module script (the one named &lt;moduleName&gt;.R). The default template includes several functions.\nIn this example, instead of writing the code that does what we want inside the doEvent function itself, lets use the Init function. We move the code from the “init” event into a function, then call that function.\n\n\nCode\ndoEvent.My_linear_model.init &lt;- function(sim, eventTime, eventType, priority) {\n  sim &lt;- Init(sim)\n  return(invisible(sim))\n}\n\nInit &lt;- function(sim) {\n  y &lt;- sim$x + rnorm(10)\n  sim$model &lt;- lm(y ~ sim$x)\n  return(invisible(sim))\n}\n\n\nWe can extend this to any number of functions. Notice, that functions can have any arguments. They don’t have to have sim. The critical point to retain is that the doEvent function must return sim. We can also write documentation using roxygen2 tags (though converting this to normal R documentation is still experimental within a SpaDES module).\nCopy these three functions to your module, replacing the existing functions with these ones (for doEvent.My_linear_model.init and Init). generateY is completely new, so it won’t replace anything.\n\n\nCode\ndoEvent.My_linear_model.init &lt;- function(sim, eventTime, eventType, priority) {\n  sim &lt;- Init(sim)\n  return(invisible(sim))\n}\n\n# Use this inside the `doEvent.My_linear_model.init` function\nInit &lt;- function(sim) {\n  y &lt;- generateY(sim$x)\n  sim$model &lt;- lm(y ~ sim$x)\n  return(invisible(sim))\n}\n\n#' A function that generates random error around an `x`\n#' \n#' @param x Any numeric vector of length 10 \ngenerateY &lt;- function(x) {\n  x + rnorm(10)\n}",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#sec-moduletypes",
    "href": "ModulesAndEvents.html#sec-moduletypes",
    "title": "8  Modules, Events and Functions",
    "section": "8.4 Module types",
    "text": "8.4 Module types\nSpaDES doesn’t have explicit module types. Rather, by convention, we associate different modules with generic things they do. A fairly comprehensive list of modules types that we create are below. We will revisit this later in [Part 3](ContinuousWorkflows.qmd). \n\n8.4.1 Static\nStatic modules can be defined as modules that “run once”. This means that they may have only one event. Or a sequence of events that occur one after the other with no rescheduling.\nThese could include:\n\nData preparation modules - one (maybe just the “init” event) or few events and their primary goal is to get and deal with data;\nGIS modules that do a number of GIS operations to get data into the necessary formats;\nData Visualization modules that specialize in creating a set of visuals from a known set of inputs.\n\n\n\n8.4.2 Dynamic\nDynamic modules are modules that have events that recur. There are at least 2 types of such models: those that have cyclic dependencies, i.e., its outputs are also its inputs (possibly with other modules in between) and those that do not.\n\nLandscape simulation modules (e.g., wildfire, vegetation change)\nWildlife population modules with Markov dependency (e.g., population matrix models)\nWildlife population modules without Markov-dependency (e.g., population models that only depend on habitat covariates)\nData visualization modules that get used e.g., annually after other modules.\n\nIn Barros et al. (2023) we classified modules with respect to what the modules try to accomplish:\n\n“data/calibration modules” prepare model inputs and parameters\n“prediction/simulation modules” generate predictions using either static or dynamic mechanisms\n“validation modules” evaluate predictions against independent data.\n\nThere are no strict rules to classify a SpaDES module, just as there are no strict rules to classify an R script.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#where-modules-live",
    "href": "ModulesAndEvents.html#where-modules-live",
    "title": "8  Modules, Events and Functions",
    "section": "8.5 Where modules “live”",
    "text": "8.5 Where modules “live”\nModules can live only locally (e.g. in a computer), but in the spirit of the PERFICT principles (see Section 2.1 in the Introduction) we like our modules to be shareable.\nThe best way to share modules is to host them on GitHub repositories, as SpaDES tools have been developed to download modules from GitHub.\nMost SpaDES modules known to us are hosted in their own GitHub repositories (preferred), or bundled in GitHub repositories with several modules (e.g. Castor modules and SCFM modules).",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#see-also",
    "href": "ModulesAndEvents.html#see-also",
    "title": "8  Modules, Events and Functions",
    "section": "8.6 See also",
    "text": "8.6 See also\nChapter 9 on event scheduling\n?scheduleEvent\n?P\n?time\n?start\n?end",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#more-learning-on-this-subject",
    "href": "ModulesAndEvents.html#more-learning-on-this-subject",
    "title": "8  Modules, Events and Functions",
    "section": "8.7 More learning on this subject",
    "text": "8.7 More learning on this subject\nMy First Module\nCreating a seed dispersal module",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#barebones-r-script",
    "href": "ModulesAndEvents.html#barebones-r-script",
    "title": "8  Modules, Events and Functions",
    "section": "8.8 Barebones R script",
    "text": "8.8 Barebones R script\n\n\n\n\nBarros, Ceres, Yong Luo, Alex M. Chubaty, Ian M. S. Eddy, Tatiane Micheletti, Céline Boisvenue, David W. Andison, Steven G. Cumming, and Eliot J. B. McIntire. 2023. “Empowering Ecological Modellers with a PERFICT Workflow: Seamlessly Linking Data, Parameterisation, Prediction, Validation and Visualisation.” Methods in Ecology and Evolution 14 (1): 173–88. https://doi.org/10.1111/2041-210X.14034.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "Scheduling.html",
    "href": "Scheduling.html",
    "title": "9  Scheduling Events",
    "section": "",
    "text": "9.1 Convert to a module\nIn the above code, there are 4 sections. These will each be copied into the SpaDES module below, in their respective sections. We have added 1 new section, called “Prediction”.\nCode\nSpaDES.core::newModule(name = \"scheduling\", path = \"~/SpaDES_book/scheduling\")\nOpen the module file, which will be printed in the console. Scroll down to the Init function and copy the Init, the .inputObjects(), and the Plot parts in the code above into the new module, as we did in Chapter 4.\nWe must make the same decisions about “local objects” (objects that are OK not to be kept for later) and about “global objects” (those that we want to keep). These global objects get put into sim. Your new module should have these 3 new sections/functions:\nCode\nInit &lt;- function(sim) {\n  y &lt;- sim$x + rnorm(10)\n  # fit a linear model\n  sim$out &lt;- lm(y ~ sim$x)\n  sim$pred &lt;- list()\n  \n  return(invisible(sim))\n}\n\nplotFun &lt;- function(sim) {\n  sim$predictions &lt;- data.frame(year = rep(sim$years, each = 10), prediction = unlist(sim$pred))\n  # plot the predictions\n  sim$gg &lt;- ggplot(sim$predictions, aes(x = year, y = prediction, colour = year)) + geom_point() + geom_smooth()\n  print(sim$gg)\n  \n  return(invisible(sim))\n}\n\n.inputObjects &lt;- function(sim) {\n  sim$x &lt;- rnorm(10)\n  \n  return(invisible(sim))\n}",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#convert-to-a-module",
    "href": "Scheduling.html#convert-to-a-module",
    "title": "9  Scheduling Events",
    "section": "",
    "text": "9.1.1 Update module metadata\nLike in Chapter 5, we also have to update the module metadata… what the inputs, outputs, parameters are. SpaDES will not error if the metadata are not correct, but it will try to point out the problems.\nHere’s an example:\n\n\nCode\ncreatesOutput(objectName = \"predictions\", objectClass = \"data.frame\", \n              desc = \"Table of predictions and years\")\n\n\nMake sure the inputs (x) and all outputs (predictions, gg, pred and out) are all declared.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#new-event-function-prediction",
    "href": "Scheduling.html#new-event-function-prediction",
    "title": "9  Scheduling Events",
    "section": "9.2 New Event Function – Prediction",
    "text": "9.2 New Event Function – Prediction\nThe new part is the for loop. This part takes new covariates (new values for y), emulating “predicted” covariates, and derives a newly predicted x, which we then keep as the predicted x values each year.\nWe’ll use scheduleEvent() below to do this iteration. For now, copy the Prediction part into a new function:\n\n\nCode\nPrediction &lt;- function(sim) {\n  startYear &lt;- 2023\n  sim$years &lt;- startYear:(startYear + 10) + 1\n  for (year in sim$years - startYear) {\n    sim$pred[[year]] &lt;- predict(sim$out, newdata = data.frame(y = rnorm(10) + year))\n  }\n  return(invisible(sim))\n}\n\n\nNote the new output years, which should also be added to the metadata.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#scheduling",
    "href": "Scheduling.html#scheduling",
    "title": "9  Scheduling Events",
    "section": "9.3 Scheduling",
    "text": "9.3 Scheduling\nNow we need to tell SpaDES when to execute and when to iterate each of the steps or “events”. The init we do once, at the start. The .inputObjects always only happens once and “before the start” (init) – it is scheduled automatically so nothing to do here. The last part (i.e., the prediction event) must happen 10 times, and it must start after init and before the plot. The plot we do once.\n\n9.3.1 doEvent.*() and scheduleEvent()\nThere is a special function defined in a SpaDES module called doEvent.*() (it usually is appended with the module name: doEvent.&lt;module_name&gt;()). SpaDES calls this function several times and executes it’s code depending on the values of the eventTime and eventType arguments.\nBy default the only mandatory event executed by spades is the init1, unless we specifically tell it to do more, using the SpaDES.core::scheduleEvent() function and declaring more values for the event argument (i.e. more events).\n\n\n\n\n\n\nOrder of event code (not to confuse with event execution)\n\n\n\nEvents do not have to be defined in any particular order in the doEvent.&lt;module_name&gt;() function, as their order of execution is solely determined by scheduling (scheduleEvent()) or, for some events, imposed by simInit() and spades() (e.g., .inputObjects() and init are always executed first).\nSimilarly, the order in which functions used by events appear in the module R script is arbitrary.\n\n\nscheduleEvent() is the “scheduler” function. Using the arguments eventTime and eventType, we define when and what event to schedule, respectively. eventPriority can be specified to determine which event should occur first, when two are scheduled for the same time2. Finally, moduleName and sim always have to be passed.\nWe place scheduleEvent() anywhere we want inside each event’s code in doEvent.*(). In this example, we will place it in a few places:\n\n9.3.1.1 In the init event\nWe look at the init event (code inside event = \"init\") and we see 2 scheduleEvent calls that come with the template. We will use those to learn. In each “event”, we often see one part that “does something” and another part that “schedules something”.\nIn the default template, we “do” the Init function and we schedule plot and save. We can delete the save event, as we won’t do that here. But we will replace it with “schedule prediction”.\nSee ?start, ?scheduleEvent, ?P\n\n\nCode\nsim &lt;- Init(sim)\n\n# schedule future event(s)\nsim &lt;- scheduleEvent(sim, P(sim)$.plotInitialTime, \"scheduling\", \"plot\")\n\n# here we create a new event type == \"predictions\" and we schedule it for `start(sim)`\nsim &lt;- scheduleEvent(sim, start(sim), \"scheduling\", \"predictions\") \n\n\nCopy the above code chunk to the init section so that it looks like this:\n\n\nCode\nswitch(\n  eventType,\n  init = {\n    sim &lt;- Init(sim)\n    \n    # schedule future event(s)\n    sim &lt;- scheduleEvent(sim, P(sim)$.plotInitialTime, \"scheduling\", \"plot\")\n    \n    # here we create a new event type == \"predictions\" and we schedule it for `start(sim)`\n    sim &lt;- scheduleEvent(sim, start(sim), \"scheduling\", \"predictions\") \n  },\n  ...\n)\n\n\n\n\n\n\n\n\nMatch scheduleEvent() arguments to event names\n\n\n\nThe name of an event is defined as argument values for doEvent.&lt;module_name&gt;(..., eventType):\n\n\nCode\ndoEvent.scheduling = function(sim, eventTime, eventType) {\n  switch(\n    eventType,\n    init = {    # &lt;----- \"init\" is the eventType/name\n     &lt;...&gt;\n    },\n    predictions = {  # &lt;----- \"predictions\" is another eventType/name\n      &lt;...&gt;\n    },\n    warning(noEventWarning(sim))\n  )\n  return(invisible(sim))\n}\n\n\nIt must match what is provided to scheduleEvent(..., eventType).\n\n\n\n\n\n9.3.2 The new events\nWe will add code to make two new events, called \"predictions\" and \"plot\" (the name must match what we wrote in the scheduleEvent() above). In these events, we “do” the prediction, schedule the next prediction at “time plus 1”, and plot.\nSee ?SpaDES.core::times().\n\n\n\n\n\n\nTime in SpaDES\n\n\n\nIt is useful to understand time in SpaDES. Time has units (e.g., “year”) which is defined by the modules metadata timeunit. So, if time(sim) is 1 or 2024, that would be in year units, if the module is in year. To know what “time” it is in a module, the easiest function is time(sim). That will give you the “time”.\nTime, in SpaDES, is a way of ordering events. If one event happens at time 2024, and another event happens at 2025, then the 2024 event will happen first.\nThe other two useful functions are start(sim) and end(sim), which will give you the starting time of the spades call and ending time respectfully. These would have been specified in simInit.\n\n\n\n\nCode\nswitch(\n  eventType,\n  init = {...},\n  predictions = {\n    # do the Prediction\n    sim &lt;- Prediction(sim)\n    \n    # schedule the next Prediction\n    sim &lt;- scheduleEvent(sim, time(sim) + 1, \"scheduling\", \"predictions\") \n  },\n  plot = {\n    # do the plot\n    sim &lt;- plotFun(sim)\n  },\n  ...\n)\n\n\n\n\n\n\n\n\nTop-down vs Bottom-up workflow sequencing\n\n\n\nIn a “top-down” workflow, we could imagine something like:\n\n\nCode\nscheduleEvent(sim, time(sim) + 1, \"predictions\")\nscheduleEvent(sim, time(sim) + 2, \"predictions\")\nscheduleEvent(sim, time(sim) + 3, \"predictions\")\n\n\nThis would schedule 3 predictions, during the next three “time steps”. This may be very clear, but it would be difficult to do this for dozens of years (could be done with a for-loop).\nA “bottom up” approach is to schedule the predictions event once during init, then each time that predictions event occurs, reschedule it:\n\n\nCode\ninit = {\n  ...\n  scheduleEvent(sim, start(sim), \"predictions\")   # schedule first occurrence of \"predictions\"\n},\npredictions = {\n  ...\n  scheduleEvent(sim, time(sim) + 1, \"predictions\")  # re-schedule \"predictions\"\n}\n\n\nEach time the predictions event happens, it will reschedule itself forever! Very simple. The workflow sequence emerges from the self-scheduling.\n\n\n\n\n9.3.3 Double check existing events\nIf we ran the above changes, we would see an error because plotFun was scheduled to run at the time that is specified by .plotInitialTime, which by default is start(sim). We have no data yet at that time. So, we will choose to schedule plotFun to run at end(sim):\n\n\nCode\nscheduleEvent(sim, end(sim), \"scheduling\", \"plot\")\n\n\n\n\n\n\n\n\nEvents and event functions – not to be confused\n\n\n\nThe name of an event and of the function that an event calls (the “event function”) need not (and should not, to avoid confusion) be the same.\nIn the examples above the predictions event called the Prediction() event function and the plot event called the plotFun() function.\nConventionally, event names have been all lowercase; but this highly depends on developer coding style and the module.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#run",
    "href": "Scheduling.html#run",
    "title": "9  Scheduling Events",
    "section": "9.4 Run",
    "text": "9.4 Run\nThe resulting module can now be run.\n\n\nCode\nSpaDES.core::simInitAndSpades(modules = \"scheduling\", paths = list(modulePath = \"~/SpaDES_book/scheduling\"))\n\n\nA complete version of this new module can be found at scheduling.R. You can copy this over top of the new module that you created here, i.e., keep the same folder structure.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#questions",
    "href": "Scheduling.html#questions",
    "title": "9  Scheduling Events",
    "section": "9.5 Questions",
    "text": "9.5 Questions\n\nhow are some ways that scheduleEvent is different from a “loop”?\n\nWe can change the “step” length between events.\nWe can interweave events, e.g., a fire event then a tree growth event\n\nWhen is a loop better than scheduling?\n\nLoops are much faster than scheduling.\nBut really, avoid loops in R if you can help it\n\nChances are that the first versions of this module didn’t work. How do you fix it?\n\nLearn how to debug in R and SpaDES",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#try-on-your-own",
    "href": "Scheduling.html#try-on-your-own",
    "title": "9  Scheduling Events",
    "section": "9.6 Try on your own",
    "text": "9.6 Try on your own\n\nTry creating a new parameter that controls the frequency of predictions.\nHere’s a clue:\npredictions = {\n  scheduleEvent(sim, time(sim) + P(sim)$predFreq, \"predictions\")\n}",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#common-mistakes",
    "href": "Scheduling.html#common-mistakes",
    "title": "9  Scheduling Events",
    "section": "9.7 Common mistakes",
    "text": "9.7 Common mistakes\n\nUndefined event type. This is a warning, rather than an error, that is issued when an event is being scheduled with scheduleEvent(), but has not been defined in doEvent.&lt;module_name&gt;(). Check spelling and make sure all scheduled events appear in doEvent.&lt;module_name&gt;().\nEvent not being scheduled/executed. If an event doesn’t appear printed in spades() messages during workflow execution or in the event queues shown by events() or completed(), double check:\n\nwhether the first occurrence of the event is being scheduled by the init event;\nif the chosen time for the first occurrence is correct;\nwhether the event is rescheduling itself appropriately;\nwhether the name of the event and module are spelled correctly in scheduleEvent();\nwhether the event has been defined in doEvent.&lt;module_name&gt;().",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#see-also",
    "href": "Scheduling.html#see-also",
    "title": "9  Scheduling Events",
    "section": "9.8 See also",
    "text": "9.8 See also\nChapter 8 on Modules, Events and Functions\n?scheduleEvent\n?P\n?time\n?start\n?end\n?switch",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#more-learning-on-this-subject",
    "href": "Scheduling.html#more-learning-on-this-subject",
    "title": "9  Scheduling Events",
    "section": "9.9 More learning on this subject",
    "text": "9.9 More learning on this subject\nMy First Module\nCreating a seed dispersal module",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#barebones-r-script",
    "href": "Scheduling.html#barebones-r-script",
    "title": "9  Scheduling Events",
    "section": "9.10 Barebones R script",
    "text": "9.10 Barebones R script\n\n\nCode\n# .inputObjects  #####\nx &lt;- rnorm(10)\n\n# Init #####\ny &lt;- x + rnorm(10)\n# fit a linear model\nout &lt;- lm(y ~ x)\npred &lt;- list()\n\n# Prediction #####\nstartYear &lt;- 2023\nyears &lt;- startYear:(startYear + 10) + 1\nfor (year in years - startYear) {\n  pred[[year]] &lt;- predict(out, newdata = data.frame(y = rnorm(10) + year))\n}\n\n# Plot #####\npredictions &lt;- data.frame(year = rep(years, each = 10), prediction = unlist(pred))\n# plot the predictions\nggplot(predictions, aes(x = year, y = prediction, colour = year)) + \n  geom_point() + geom_smooth()\n\nSpaDES.core::newModule(name = \"scheduling\", path = \"~/SpaDES_book/scheduling\")\n\nInit &lt;- function(sim) {\n  y &lt;- sim$x + rnorm(10)\n  # fit a linear model\n  sim$out &lt;- lm(y ~ sim$x)\n  sim$pred &lt;- list()\n}\n\nplotFun &lt;- function(sim) {\n  sim$predictions &lt;- data.frame(year = rep(sim$years, each = 10), prediction = unlist(sim$pred))\n  # plot the predictions\n  sim$gg &lt;- ggplot(sim$predictions, aes(x = year, y = prediction, colour = year)) + geom_point() + geom_smooth()\n  print(sim$gg)\n}\n\n.inputObjects &lt;- function(sim) {\n  sim$x &lt;- rnorm(10)\n}\n\nPrediction &lt;- function(sim) {\n  startYear &lt;- 2023\n  sim$years &lt;- startYear:(startYear + 10) + 1\n  for (year in sim$years - startYear) {\n    sim$pred[[year]] &lt;- predict(sim$out, newdata = data.frame(y = rnorm(10) + year))\n  }\n  return(invisible(sim))\n}\n\nsim &lt;- Init(sim)\n\n# schedule future event(s)\nsim &lt;- scheduleEvent(sim, P(sim)$.plotInitialTime, \"scheduling\", \"plot\")\n# sim &lt;- scheduleEvent(sim, P(sim)$.saveInitialTime, \"scheduling\", \"save\")\n\n# here we create a new event type == \"predictions\" and we schedule it for `start(sim)`\nsim &lt;- scheduleEvent(sim, start(sim), \"scheduling\", \"predictions\") \n\nswitch(\n  eventType,\n  init = {\n    sim &lt;- Init(sim)\n    \n    # schedule future event(s)\n    sim &lt;- scheduleEvent(sim, P(sim)$.plotInitialTime, \"scheduling\", \"plot\")\n    \n    # here we create a new event type == \"predictions\" and we schedule it for `start(sim)`\n    sim &lt;- scheduleEvent(sim, start(sim), \"scheduling\", \"predictions\") \n  },\n  ...\n)\n\nswitch(\n  eventType,\n  init = {...},\n  predictions = {\n    # do the Prediction\n    sim &lt;- Prediction(sim)\n    \n    # schedule the next Prediction\n    sim &lt;- scheduleEvent(sim, time(sim) + 1, \"scheduling\", \"predictions\") \n  },\n  ...\n)\n\nscheduleEvent(sim, time(sim) + 1, \"predictions\")\nscheduleEvent(sim, time(sim) + 2, \"predictions\")\nscheduleEvent(sim, time(sim) + 3, \"predictions\")\n\ninit = {\n  scheduleEvent(sim, time(sim), \"predictions\")\n}\n\npredictions = {\n  scheduleEvent(sim, time(sim) + 1, \"predictions\")\n}\n\nscheduleEvent(sim, end(sim), \"scheduling\", \"plot\")\n\ncreatesOutput(objectName = \"predictions\", objectClass = \"data.frame\", \n              desc = \"Table of predictions and years\")\n\nSpaDES.core::simInitAndSpades(modules = \"scheduling\", paths = list(modulePath = \"~/SpaDES_book/scheduling\"))",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#footnotes",
    "href": "Scheduling.html#footnotes",
    "title": "9  Scheduling Events",
    "section": "",
    "text": "although others appear in the template .R generated by newModule() .↩︎\nby default, all events get equal relative priority, and the one scheduled first will happen first.↩︎",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "ContinuousWorkflows.html",
    "href": "ContinuousWorkflows.html",
    "title": "Working with Continuous Workflows",
    "section": "",
    "text": "SpaDES and Continuous Workflows\nSpaDES allows us to implement feature 3 (hierarchical caching) of Tip 1 because we can Cache at many levels: functions, events, modules, meta-modules, or entire projects. As we are developing inside a project, we can be working on a step inside a module that relies on previous “upstream” modules, but those modules can run very fast, so we can be quickly where we need to be, without breaking the workflow.\nThinking about this situation, we can now re-visit the idea of “Module Types” (introduced in 8.4 Module types) in terms of how they might depend on each other and certain types of inputs, and the types of outputs they produce.",
    "crumbs": [
      "Working with Continuous Workflows"
    ]
  },
  {
    "objectID": "ContinuousWorkflows.html#module-types-revisited",
    "href": "ContinuousWorkflows.html#module-types-revisited",
    "title": "Working with Continuous Workflows",
    "section": "Module Types (Revisited)",
    "text": "Module Types (Revisited)\nSpaDES doesn’t have an explicit module types. Rather, by convention, we associate different modules with generic things they do. A fairly comprehensive list of modules types that we create are:\n\nData Munging – uses prepInputs and outputs clean, usable data for a project, mostly specifies createsOutputs\nParameterization – uses data from e.g., a Data Munging module and uses statistics on data. This would be recognizable as a complete ecological study for publication.\nCalibration – similar to Parameterization but uses repeated simulation to estimate parameters.\nStudy Area specifics – creates outputs that are very idiosyncratic to a study area\nStatic Forecasting – creates outputs at different times, that are not used by itself\nDynamic Forecasting – creates outputs at different times, that are also its own inputs\nValidation – takes many repeated inputs, often many replicates\nVisualization – takes inputs from one or many replicated module runs and build rich visuals\nPost-Processing – takes inputs from one or many replicated module runs and builds data analytics. These may be similar to Validation\n\nThus, the differences are about how the inputObjects and outputObjects are specified and designed.\n\n\n\n\nJanssen, Marco A., Calvin Pritchard, and Allen Lee. 2020. “On Code Sharing and Model Documentation of Published Individual and Agent-Based Models.” Environmental Modelling & Software 134 (December): 104873. https://doi.org/10.1016/j.envsoft.2020.104873.\n\n\nSharma, Nitesh Kumar, Ram Ayyala, Dhrithi Deshpande, Yesha M Patel, Viorel Munteanu, Dumitru Ciorba, Andrada Fiscutean, et al. 2023. “Analytical Code Sharing Practices in Biomedical Research.” bioRxiv, August, 2023.07.31.551384. https://doi.org/10.1101/2023.07.31.551384.",
    "crumbs": [
      "Working with Continuous Workflows"
    ]
  },
  {
    "objectID": "Caching.html",
    "href": "Caching.html",
    "title": "10  Introduction to Cache",
    "section": "",
    "text": "10.1 How to use Cache\nThe Cache function can be used with any function. A user can wrap it around another function call, use the base pipe operator |&gt; or specify the function and function arguments as arguments to Cache. The following calls are the same, and thus the 2nd and 3rd will result in the identical output to the first:\nCode\nlibrary(reproducible)\nreproducible::Cache(rnorm(1))\n\n\n[1] -0.6206162\nattr(,\".Cache\")\nattr(,\".Cache\")$newCache\n[1] TRUE\n\nattr(,\"tags\")\n[1] \"cacheId:422bae4ed2f770cc\"\nattr(,\"call\")\n[1] \"\"\n\n\nCode\nrnorm(1) |&gt;\n  reproducible::Cache()\n\n\n[1] -0.6206162\nattr(,\".Cache\")\nattr(,\".Cache\")$newCache\n[1] FALSE\n\nattr(,\"tags\")\n[1] \"cacheId:422bae4ed2f770cc\"\nattr(,\"call\")\n[1] \"\"\n\n\nCode\nreproducible::Cache(rnorm,\n                    n = 1)\n\n\n[1] -0.6206162\nattr(,\".Cache\")\nattr(,\".Cache\")$newCache\n[1] FALSE\n\nattr(,\"tags\")\n[1] \"cacheId:422bae4ed2f770cc\"\nattr(,\"call\")\n[1] \"\"\nSee ?reproducible::Cache for many more examples.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#when-to-use-cache",
    "href": "Caching.html#when-to-use-cache",
    "title": "10  Introduction to Cache",
    "section": "10.2 When to use Cache",
    "text": "10.2 When to use Cache\nThe most obvious case to use Cache is when the calculation is expensive. For example, GIS operations are commonly time consuming. In the example below, we will use terra::project three times, with timings.\n\n10.2.1 From disk\n\n\nCode\n# Data setup\nlibrary(terra)\ntmpDir &lt;- file.path(tempdir(), \"reproducible_examples\", \"Cache\")\ndir.create(tmpDir, recursive = TRUE)\n\nx &lt;- y &lt;- 2001\nras &lt;- terra::rast(terra::ext(0, x, 0, y), vals = sample(1:(x*y)), res = 1)\nterra::crs(ras) &lt;- \"+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +datum=WGS84\"\nnewCRS &lt;- \"+init=epsg:4326\" # A longlat crs\n\n# Call slow operation: project\n# No Cache\nsystem.time(map1 &lt;- terra::project(ras, newCRS)) # Warnings due to new PROJ\n\n\n   user  system elapsed \n   1.91    0.06    2.00 \n\n\nCode\n# With Cache -- a little slower the first time because saving to disk\nsystem.time(map2 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\n\n   user  system elapsed \n  18.57    0.56   19.17 \n\n\nCode\n# faster the second time; improvement depends on size of object and time to run function\nsystem.time(map3 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\n\n   user  system elapsed \n   1.58    0.12    1.72 \n\n\nIn this example, the object map3 gets cached, along with the evaluation of the function terra::project and its arguments (ras and newCRS). If either the function or supplied arguments change, Cache repeats the operation and re-caches the output in a new cache entry.\n\n\n10.2.2 From disk and memory\nWe can set an option so that objects will also be saved to disk as normal, but they will also be saved as RAM objects – “memoising”.\n\n\nCode\noptOrig &lt;- options(\"reproducible.useMemoise\" = TRUE)\nsystem.time(map4 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\n\n   user  system elapsed \n   1.32    0.06    1.41 \n\n\nCode\nsystem.time(map5 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\n\n   user  system elapsed \n   0.14    0.03    0.19 \n\n\nCode\noptions(optOrig)",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#sec-cachewhere",
    "href": "Caching.html#sec-cachewhere",
    "title": "10  Introduction to Cache",
    "section": "10.3 Where does the cache live?",
    "text": "10.3 Where does the cache live?\nBy default, on a temporary folder which does not persist between R sessions. To see where this folder is run:\n\n\nCode\noptions(\"reproducible.cachePath\")\n\n\n$reproducible.cachePath\n[1] \"C:\\\\Users\\\\cbarros\\\\AppData\\\\Local\\\\Temp\\\\RtmpqA2PkG/reproducible/cache\"\n\n\nFor a persisting cache, we should change to a permanent folder path. This can be done by in two ways:\n\n\nCode\nCache(rnorm(1), \n      cachePath = \"~/SpaDES_book/cache\")\noptions(\"reproducible.cachePath\")   ## still the temporary directory\n\n\noptions(\"reproducible.cachePath\" = \"~/SpaDES_book/cache\")\nCache(rnorm(1))\n\n\nThe second, using options sets the cachePath for any subsequent Cache call.\n\n\n\n\n\n\nIn a SpaDES workflow context, the cached directory can be set by passing the list(..., cachePath = &lt;a_path&gt;)1 to the paths argument in setupProject, simInit or simInitAndSpaDES.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#caching-examples",
    "href": "Caching.html#caching-examples",
    "title": "10  Introduction to Cache",
    "section": "10.4 Caching examples",
    "text": "10.4 Caching examples\n\n10.4.1 Basic cache use with tags\nWe can add tags to identify the Cache call.\n\n\nCode\nranNumsA &lt;- Cache(rnorm, 4, userTags = c(\"random number generator\"))\n\nshowCache(userTags = \"random number generator\")\n\n\n             cacheId                  tagKey                   tagValue\n              &lt;char&gt;                  &lt;char&gt;                     &lt;char&gt;\n 1: ad0ea27476c50b66 random number generator    random number generator\n 2: ad0ea27476c50b66                function                      rnorm\n 3: ad0ea27476c50b66                   class                    numeric\n 4: ad0ea27476c50b66             object.size                       1008\n 5: ad0ea27476c50b66                accessed 2024-06-21 20:31:06.275774\n 6: ad0ea27476c50b66                 inCloud                      FALSE\n 7: ad0ea27476c50b66                fromDisk                      FALSE\n 8: ad0ea27476c50b66              resultHash                           \n 9: ad0ea27476c50b66       elapsedTimeDigest           0.007800817 secs\n10: ad0ea27476c50b66     elapsedTimeFirstRun          0.0001580715 secs\n11: ad0ea27476c50b66          otherFunctions                    execute\n12: ad0ea27476c50b66          otherFunctions               process_file\n13: ad0ea27476c50b66          otherFunctions              process_group\n14: ad0ea27476c50b66          otherFunctions                 call_block\n15: ad0ea27476c50b66          otherFunctions                 block_exec\n16: ad0ea27476c50b66          otherFunctions                      eng_r\n17: ad0ea27476c50b66          otherFunctions               in_input_dir\n18: ad0ea27476c50b66          otherFunctions                     in_dir\n19: ad0ea27476c50b66          otherFunctions                  timing_fn\n20: ad0ea27476c50b66          otherFunctions                     handle\n21: ad0ea27476c50b66               preDigest         n:7eef4eae85fd9229\n22: ad0ea27476c50b66               preDigest      mean:c40c00762a0dac94\n23: ad0ea27476c50b66               preDigest        sd:853b1797f54b229c\n24: ad0ea27476c50b66               preDigest      .FUN:4f604aa46882b368\n             cacheId                  tagKey                   tagValue\n                   createdDate\n                        &lt;char&gt;\n 1: 2024-06-21 20:31:06.277134\n 2: 2024-06-21 20:31:06.277134\n 3: 2024-06-21 20:31:06.277134\n 4: 2024-06-21 20:31:06.277134\n 5: 2024-06-21 20:31:06.277134\n 6: 2024-06-21 20:31:06.277134\n 7: 2024-06-21 20:31:06.277134\n 8: 2024-06-21 20:31:06.277134\n 9: 2024-06-21 20:31:06.277134\n10: 2024-06-21 20:31:06.277134\n11: 2024-06-21 20:31:06.277134\n12: 2024-06-21 20:31:06.277134\n13: 2024-06-21 20:31:06.277134\n14: 2024-06-21 20:31:06.277134\n15: 2024-06-21 20:31:06.277134\n16: 2024-06-21 20:31:06.277134\n17: 2024-06-21 20:31:06.277134\n18: 2024-06-21 20:31:06.277134\n19: 2024-06-21 20:31:06.277134\n20: 2024-06-21 20:31:06.277134\n21: 2024-06-21 20:31:06.277134\n22: 2024-06-21 20:31:06.277134\n23: 2024-06-21 20:31:06.277134\n24: 2024-06-21 20:31:06.277134\n                   createdDate",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#clean-up-cache",
    "href": "Caching.html#clean-up-cache",
    "title": "10  Introduction to Cache",
    "section": "10.5 Clean up cache",
    "text": "10.5 Clean up cache\nWe can use either clearCache, keepCache, or cc to remove things from the Cache database. clearCache removes everything that matches the query. keepCache keeps everything that matches the query. cc removes the most recent entry (i.e., it is a shorthand for a commonly used option).\n\n\nCode\n# Two different funcxtions\na &lt;- rnorm(1) |&gt; Cache()\nb &lt;- runif(1) |&gt; Cache()\n\n# Clear only the first one\nclearCache(userTags = \"rnorm\", ask = FALSE)\na2 &lt;- rnorm(1) |&gt; Cache()\nb2 &lt;- runif(1) |&gt; Cache()\n\n# b2 and b are still identical; a and a2 are not\na == a2 # FALSE\n\n\n[1] FALSE\n\n\nCode\nb == b2 # TRUE\n\n\n[1] TRUE\n\n\nCode\n# This time keep ONLY the rnorm\nkeepCache(userTags = \"rnorm\", ask = FALSE)\n\n\n             cacheId              tagKey                   tagValue\n              &lt;char&gt;              &lt;char&gt;                     &lt;char&gt;\n 1: 422bae4ed2f770cc            function                      rnorm\n 2: 422bae4ed2f770cc               class                    numeric\n 3: 422bae4ed2f770cc         object.size                        984\n 4: 422bae4ed2f770cc            accessed 2024-06-21 20:31:06.605013\n 5: 422bae4ed2f770cc             inCloud                      FALSE\n 6: 422bae4ed2f770cc            fromDisk                      FALSE\n 7: 422bae4ed2f770cc          resultHash                           \n 8: 422bae4ed2f770cc   elapsedTimeDigest           0.007511854 secs\n 9: 422bae4ed2f770cc elapsedTimeFirstRun          0.0001630783 secs\n10: 422bae4ed2f770cc      otherFunctions                    execute\n11: 422bae4ed2f770cc      otherFunctions               process_file\n12: 422bae4ed2f770cc      otherFunctions              process_group\n13: 422bae4ed2f770cc      otherFunctions                 call_block\n14: 422bae4ed2f770cc      otherFunctions                 block_exec\n15: 422bae4ed2f770cc      otherFunctions                      eng_r\n16: 422bae4ed2f770cc      otherFunctions               in_input_dir\n17: 422bae4ed2f770cc      otherFunctions                     in_dir\n18: 422bae4ed2f770cc      otherFunctions                  timing_fn\n19: 422bae4ed2f770cc      otherFunctions                     handle\n20: 422bae4ed2f770cc           preDigest         n:853b1797f54b229c\n21: 422bae4ed2f770cc           preDigest      mean:c40c00762a0dac94\n22: 422bae4ed2f770cc           preDigest        sd:853b1797f54b229c\n23: 422bae4ed2f770cc           preDigest      .FUN:4f604aa46882b368\n             cacheId              tagKey                   tagValue\n                   createdDate\n                        &lt;char&gt;\n 1: 2024-06-21 20:31:06.606392\n 2: 2024-06-21 20:31:06.606392\n 3: 2024-06-21 20:31:06.606392\n 4: 2024-06-21 20:31:06.606392\n 5: 2024-06-21 20:31:06.606392\n 6: 2024-06-21 20:31:06.606392\n 7: 2024-06-21 20:31:06.606392\n 8: 2024-06-21 20:31:06.606392\n 9: 2024-06-21 20:31:06.606392\n10: 2024-06-21 20:31:06.606392\n11: 2024-06-21 20:31:06.606392\n12: 2024-06-21 20:31:06.606392\n13: 2024-06-21 20:31:06.606392\n14: 2024-06-21 20:31:06.606392\n15: 2024-06-21 20:31:06.606392\n16: 2024-06-21 20:31:06.606392\n17: 2024-06-21 20:31:06.606392\n18: 2024-06-21 20:31:06.606392\n19: 2024-06-21 20:31:06.606392\n20: 2024-06-21 20:31:06.606392\n21: 2024-06-21 20:31:06.606392\n22: 2024-06-21 20:31:06.606392\n23: 2024-06-21 20:31:06.606392\n                   createdDate\n\n\nCode\na3 &lt;- rnorm(1) |&gt; Cache()\nb3 &lt;- runif(1) |&gt; Cache()\n\n# b2 and b are still identical; a and a2 are not\na2 == a3 # TRUE\n\n\n[1] TRUE\n\n\nCode\nb2 == b3 # FALSE\n\n\n[1] FALSE",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#nested-caching",
    "href": "Caching.html#nested-caching",
    "title": "10  Introduction to Cache",
    "section": "10.6 Nested Caching",
    "text": "10.6 Nested Caching\nNested caching is when Caching of a function occurs inside an outer function, which is itself cached. This is a critical element to working within a reproducible work flow. Ideally, at all points in a development cycle, it should be possible to get to any line of code starting from the very initial steps, running through everything up to that point, in less than a few seconds. If the workflow can be kept very fast like this, it will be very likely to work at any point it is tested.\nIn the example here, we run an outer function that calls an inner function. If we decide to change the outer function along the way, and the inner function is unaffected, then we can still recover the cached version of the inner call.\nWarning this will not necessarily work the other way, i.e., if inner is changed, we won’t notice until we clearCache and rerun.\n\n\nCode\n# Make 2 functions\ninner &lt;- function(mean) {\n  d &lt;- 1\n  Cache(rnorm(3, mean = mean))\n}\nouter &lt;- function(n) {\n  Cache(inner(0.1))\n}\n\n# Call outer function\nCache(outer(n = 2))\n\n\n[1] 1.2429132 0.9079636 0.4121525\nattr(,\".Cache\")\nattr(,\".Cache\")$newCache\n[1] TRUE\n\nattr(,\"tags\")\n[1] \"cacheId:aa5fa876944e27be\"\nattr(,\"call\")\n[1] \"\"\n\n\nCode\n# Change outer function\nouter &lt;- function(n) {\n  a &lt;- 0.1\n  Cache(inner(a))\n}\n\n# Still recovers inner \nCache(outer(n = 2))\n\n\n[1] 1.2429132 0.9079636 0.4121525\nattr(,\".Cache\")\nattr(,\".Cache\")$newCache\n[1] TRUE\n\nattr(,\"tags\")\n[1] \"cacheId:293cb55e4c25d110\"\nattr(,\"call\")\n[1] \"\"\n\n\nCode\n# BUT if we change the inner, it won't work\ninner &lt;- function(mean) {\n  d &lt;- 2                        # Changed d\n  Cache(rnorm(3, mean = mean))\n}\nCache(outer(n = 2))\n\n\n[1] 1.2429132 0.9079636 0.4121525\nattr(,\".Cache\")\nattr(,\".Cache\")$newCache\n[1] FALSE\n\nattr(,\"tags\")\n[1] \"cacheId:293cb55e4c25d110\"\nattr(,\"call\")\n[1] \"\"",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#best-practices",
    "href": "Caching.html#best-practices",
    "title": "10  Introduction to Cache",
    "section": "10.7 Best practices",
    "text": "10.7 Best practices\nIn general, we have found that use of Cache to be beneficial when used as following:\n\nSlow functions get cached. “Slow” can be “slower than using Cache”\nRegularly clearCache(ask = FALSE), e.g., at the end of a day or week of work, then let it run.\n\nSome of our team regularly add:\n\nIf using SpaDES, use cache at the event level, if the event is non-stochastic\nDon’t cache a simInit call – instead implement internal caching in the modules and use event caching. See vignette(topic = \"iii-cache\", package = \"SpaDES.core\")",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#see-also",
    "href": "Caching.html#see-also",
    "title": "10  Introduction to Cache",
    "section": "10.8 See also",
    "text": "10.8 See also\nSpaDES.core vignette on caching",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#barebones-r-script",
    "href": "Caching.html#barebones-r-script",
    "title": "10  Introduction to Cache",
    "section": "10.9 Barebones R script",
    "text": "10.9 Barebones R script\n\n\nCode\nlibrary(reproducible)\nreproducible::Cache(rnorm(1))\n\nrnorm(1) |&gt;\n  reproducible::Cache()\n\n# Data setup\nlibrary(terra)\ntmpDir &lt;- file.path(tempdir(), \"reproducible_examples\", \"Cache\")\ndir.create(tmpDir, recursive = TRUE)\nx &lt;- y &lt;- 2001\nras &lt;- terra::rast(terra::ext(0, x, 0, y), vals = sample(1:(x*y)), res = 1)\nterra::crs(ras) &lt;- \"+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +datum=WGS84\"\nnewCRS &lt;- \"+init=epsg:4326\" # A longlat crs\n\n# Call slow operation: project\n# No Cache\nsystem.time(map1 &lt;- terra::project(ras, newCRS)) # Warnings due to new PROJ\n\n# With Cache -- a little slower the first time because saving to disk\nsystem.time(map2 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\n# faster the second time; improvement depends on size of object and time to run function\nsystem.time(map3 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\noptOrig &lt;- options(\"reproducible.useMemoise\" = TRUE)\nsystem.time(map4 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\nsystem.time(map5 &lt;- terra::project(ras, newCRS) |&gt; Cache())\noptions(optOrig)\n\nranNumsA &lt;- Cache(rnorm, 4, userTags = c(\"random number generator\"))\n\nshowCache(userTags = \"random number generator\")\n\n# Two different funcxtions\na &lt;- rnorm(1) |&gt; Cache()\nb &lt;- runif(1) |&gt; Cache()\n\n# Clear only the first one\nclearCache(userTags = \"rnorm\", ask = FALSE)\na2 &lt;- rnorm(1) |&gt; Cache()\nb2 &lt;- runif(1) |&gt; Cache()\n\n# b2 and b are still identical; a and a2 are not\na == a2 # FALSE\nb == b2 # TRUE\n\n# This time keep ONLY the rnorm\nkeepCache(userTags = \"rnorm\", ask = FALSE)\na3 &lt;- rnorm(1) |&gt; Cache()\nb3 &lt;- runif(1) |&gt; Cache()\n\n# b2 and b are still identical; a and a2 are not\na2 == a3 # TRUE\nb2 == b3 # FALSE\n\n# Make 2 functions\ninner &lt;- function(mean) {\n  d &lt;- 1\n  Cache(rnorm(3, mean = mean))\n}\nouter &lt;- function(n) {\n  Cache(inner(0.1))\n}\n\n# Call outer function\nCache(outer(n = 2))\n\n# Change outer function\nouter &lt;- function(n) {\n  a &lt;- 0.1\n  Cache(inner(a))\n}\n\n# Still recovers inner \nCache(outer(n = 2))\n\n# BUT if we change the inner, it won't work\ninner &lt;- function(mean) {\n  d &lt;- 2                        # Changed d\n  Cache(rnorm(3, mean = mean))\n}\nCache(outer(n = 2))",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#footnotes",
    "href": "Caching.html#footnotes",
    "title": "10  Introduction to Cache",
    "section": "",
    "text": "where ... are other paths, like modulePath .↩︎",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "prepInputs.html",
    "href": "prepInputs.html",
    "title": "11  reproducible::prepInputs for Data",
    "section": "",
    "text": "11.1 prepInputs\nThis function can be used to prepare R objects from remote or local data sources. The object of this function is to provide a reproducible version of a series of commonly used steps for getting, loading, and processing data.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#simplest-case-a-url",
    "href": "prepInputs.html#simplest-case-a-url",
    "title": "11  reproducible::prepInputs for Data",
    "section": "11.2 Simplest case: a url",
    "text": "11.2 Simplest case: a url\nIf we can point directly to a file on a cloud location, prepInputs does its thing, getting the local file.\n\n\nCode\nRequire::Require(c(\"terra\", \"reproducible\"), \n                 repos = c(getOption(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))))\nurl &lt;- \"https://github.com/tati-micheletti/host/raw/master/data/rasterTest.tif\"\nras &lt;- prepInputs(url = url, destinationPath = \"~/SpaDES_book/data/prepInputs\")\n\nterra::plot(ras)",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#case-in-an-archive-like-zip",
    "href": "prepInputs.html#case-in-an-archive-like-zip",
    "title": "11  reproducible::prepInputs for Data",
    "section": "11.3 Case: in an archive (like zip)",
    "text": "11.3 Case: in an archive (like zip)\nOften, cloud-stored files are in an archive, like a zip or tar.gz. These can be handled automatically with prepInputs. By default, it will try to extract all files from the archive, and load one of them into R:\n\n\nCode\nurl &lt;- \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\"\nshpEcozone &lt;- prepInputs(url = url, destinationPath = \"~/SpaDES_book/data/prepInputs\")\nterra::plot(shpEcozone[1])",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#case-local-stash-using-reproducible.inputpaths",
    "href": "prepInputs.html#case-local-stash-using-reproducible.inputpaths",
    "title": "11  reproducible::prepInputs for Data",
    "section": "11.4 Case: local stash using reproducible.inputPaths",
    "text": "11.4 Case: local stash using reproducible.inputPaths\nIf we want to use the same file in many projects, we can obviously just download it again in each project, using the same lines of prepInputs. However, we can setup a local “stash” of data files. This is a set it and forget it option in reproducible.\n\n\nCode\noptions(reproducible.inputPaths = \"~/data\")\nurl &lt;- \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\"\nshpEcozone &lt;- prepInputs(url = url, destinationPath = \"~/SpaDES_book/data/prepInputs\")\nterra::plot(shpEcozone[1])\n\n\nIf we run this chunk in the same project, results will be like the previous chunk: a vector dataset from the Canadian federal government. BUT, if we run it in a different project, it will check the stashed diretory and won’t need to download it again. Moreover, it will not actually make a copy but a link to the file, so it won’t take extra space on your hard drive.\nIf you are running in a *nix-like system (Mac, Linux, etc.) or you have Git Bash installed, you can see the number of links to a file with ls. The column after the attributes (e.g., drwxr-xr-x), is the number of pointers to a file. Anything more than 1 means that there are several pointers.\nsystem(paste0(\"ls -l\", getOption(\"inputPaths\")))",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#stages-of-prepinputs",
    "href": "prepInputs.html#stages-of-prepinputs",
    "title": "11  reproducible::prepInputs for Data",
    "section": "11.5 Stages of prepInputs",
    "text": "11.5 Stages of prepInputs\nThis function has three stages, using three internal functions:\n\nreproducible::preProcess which is getting data (download, extracting from archives, checksumming)\nreproducible::process loads the data into R (note: user can’t access this directly)\nreproducible::postProcessTo is used with Spatial* and Raster* objects, and crops, reprojects, mask/intersects.\n\npreProcess will be run, if a user supplies url or archive.\nprocess will be run if fun is not NA. It will try to guess fun based on file type if fun is left at the default of NULL.\npostProcessTo will be triggered if the user passes any its aruments (to, maskTo, cropTo) studyArea or rasterToMatch are supplied. Other arguments like method can also be to inner functions (e.g. terra::project) to control spatial operations. See ... in ?postProcessTo.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#with-gis",
    "href": "prepInputs.html#with-gis",
    "title": "11  reproducible::prepInputs for Data",
    "section": "11.6 With GIS",
    "text": "11.6 With GIS\nThe data we download may cover a larger area than our study needs. For example, there may be a provincial or national dataset, but we are only using a part of that. If we create a studyArea, we can use this as part of prepInputs, passing it to to or one of the other *to functions.\n\n11.6.1 Vector data\nThe following will get the national ecozone map, project, crop and mask it to the SK dataset.\n\n\nCode\nSK &lt;- SpaDES.project::setupStudyArea(list(level = 2, NAME_1 = \"Saskatchewan\"))\nshpEcozoneSK &lt;- prepInputs(\n  url = \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\",\n  to = SK, destinationPath = \"~/SpaDES_book/data/prepInputs\"\n)\nterra::plot(shpEcozoneSK[1])\n\n\n\n\n11.6.2 Raster data\nThe following will get a national DEM layer, crop and mask it to the SK dataset. We leave it in the projection it came in at the original source.\n\n\nCode\nurlTif1 &lt;- \"https://geodata.ucdavis.edu/geodata/elv/CAN_elv_msk.zip\"\n# Turns out the previous steps (original data or postProccessed) have an error\ntry(DEMSK &lt;- prepInputs(\n  url = urlTif1,\n  maskTo = shpEcozoneSK, \n  cropTo = shpEcozoneSK,\n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n))\n\nshpEcozoneSK &lt;- fixErrorsIn(shpEcozoneSK)\n# Rerun\nDEMSK &lt;- prepInputs(\n  url = urlTif1,\n  cropTo = shpEcozoneSK,\n  maskTo = shpEcozoneSK, \n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n)\n\nterra::plot(DEMSK)\nterra::plot(shpEcozoneSK[1], add = TRUE, col = \"transparent\")\n\n\nOf course, we may do many other things, including change the resolution of the downloaded object, change the projection, and resolution. prepInputs uses a template raster to know what to project, crop, and mask to\n\n\nCode\nSK &lt;- SpaDES.project::setupStudyArea(list(level = 2, NAME_1 = \"Saskatchewan\", epsg = 5070))\nSKras &lt;- terra::rast(terra::ext(SK), res = 250, val = 1)\nterra::crs(SKras) &lt;- terra::crs(SK)\n\nDEMSK250m &lt;- prepInputs(\n  url = urlTif1,\n  to = SKras,                   # &lt;-   template raster\n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n)\nterra::plot(DEMSK250m)\n\n\nSo, we can easily put these prepInputs calls in our workflows, in any project, with minimal new effort each time.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#caching",
    "href": "prepInputs.html#caching",
    "title": "11  reproducible::prepInputs for Data",
    "section": "11.7 Caching",
    "text": "11.7 Caching\nprepInputs is friendly with Cache and, in addition to the local stashing of a file, caches some internal operations (e.g. prepProcess). GIS operations, however, are not internally cached. Instead the user should use |&gt; Cache() to enable having a workflow that doesn’t need to be broken.\n\n\nCode\nDEMSK250m &lt;- prepInputs(\n  url = urlTif1,\n  to = SKras, \n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n) |&gt; \n  Cache()\n\n# run later... very fast\nDEMSK250m &lt;- prepInputs(\n  url = urlTif1,\n  to = SKras, \n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n) |&gt; \n  Cache()\n\n\nNote that changing the default cachePath is advisable to have persistent caches between R sessions. See Section 10.3 in Chapter 10.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#extending-prepinputs-with-fun",
    "href": "prepInputs.html#extending-prepinputs-with-fun",
    "title": "11  reproducible::prepInputs for Data",
    "section": "11.8 Extending prepInputs with fun",
    "text": "11.8 Extending prepInputs with fun\nIt is impossible for prepInputs to be able to handle all data capturing cases. When customization is needed, a few options are possible.\n\nMake a custom fun argument. Optionally, dlFun can be used to specify how to download the data.\nMake a custom prepInputs_XXX function that calls prepInputs internally.\n\nThe following example uses a custom fun. These examples are fast, so the benefits of caching won’t be as apparent as for when more complex GIS operations are needed, e.g. reprojecting large raster datasets.\n\n\nCode\nLuxembourgFull &lt;- prepInputs(\n dlFun =\n   geodata::gadm(name = \"GADM\", country = \"LUX\", level = 0, path = \"~/SpaDES_book/prepInputs\") # preProcess keeps file from this!\n) |&gt; Cache()\n\nLuxembourgInnerBuffer &lt;- prepInputs(\n  dlFun =\n    geodata::gadm(name = \"GADM\", country = \"LUX\", level = 0, path = \"~/SpaDES_book/prepInputs\") # preProcess keeps file from this!\n  ,\n  fun = {                      # Custom function\n    out &lt;- readRDS(targetFile)\n    out &lt;- terra::vect(out)\n    terra::buffer(out, 5000)\n  }\n) |&gt; Cache()\n\nterra::plot(LuxembourgInnerBuffer)\nterra::plot(Luxembourg, add = TRUE)\n\n\nBy rerunning the previous code, the caching will be in effect. This means that the slow, two-or-more-stage processes of downloading, custom operations, and possibly GIS using `to functions can all be Cached in a single step, resulting in the smallest possible output being saved, i.e., intermediate large objects have only limited “saving”.\nNOTE: Rmarkdown and Quarto both have a form of caching of chunks. This can be effective in some circumstances, but it is somewhat limited (as are all forms of Caching – they will hit their limits somewhere). For instance, they do not deal with the pointers of C++ objects in terra.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#see-also",
    "href": "prepInputs.html#see-also",
    "title": "11  reproducible::prepInputs for Data",
    "section": "11.9 See also",
    "text": "11.9 See also\nThere are many other elements of this function that can be effectively used.\nreproducible::prepInputs\nreproducible::preProcess\nreproducible::postProcessTo",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#barebones-r-script",
    "href": "prepInputs.html#barebones-r-script",
    "title": "11  reproducible::prepInputs for Data",
    "section": "11.10 Barebones R script",
    "text": "11.10 Barebones R script\n\n\nCode\nRequire::Require(c(\"terra\", \"reproducible\"), \n                 repos = c(getOption(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))))\nurl &lt;- \"https://github.com/tati-micheletti/host/raw/master/data/rasterTest.tif\"\nras &lt;- prepInputs(url = url, destinationPath = \"~/SpaDES_book/data/prepInputs\")\n\nterra::plot(ras)\n\nurl &lt;- \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\"\nshpEcozone &lt;- prepInputs(url = url, destinationPath = \"~/SpaDES_book/data/prepInputs\")\nterra::plot(shpEcozone[1])\n\noptions(reproducible.inputPaths = \"~/data\")\nurl &lt;- \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\"\nshpEcozone &lt;- prepInputs(url = url, destinationPath = \"~/SpaDES_book/data/prepInputs\")\nterra::plot(shpEcozone[1])\n\nSK &lt;- SpaDES.project::setupStudyArea(list(level = 2, NAME_1 = \"Saskatchewan\"))\nshpEcozoneSK &lt;- prepInputs(\n  url = \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\",\n  to = SK, destinationPath = \"~/SpaDES_book/data/prepInputs\"\n)\nterra::plot(shpEcozoneSK[1])\n\nurlTif1 &lt;- \"https://geodata.ucdavis.edu/geodata/elv/CAN_elv_msk.zip\"\n# Turns out the previous steps (original data or postProccessed) have an error\ntry(DEMSK &lt;- prepInputs(\n  url = urlTif1,\n  maskTo = shpEcozoneSK, \n  cropTo = shpEcozoneSK,\n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n))\n\nshpEcozoneSK &lt;- fixErrorsIn(shpEcozoneSK)\n# Rerun\nDEMSK &lt;- prepInputs(\n  url = urlTif1,\n  cropTo = shpEcozoneSK,\n  maskTo = shpEcozoneSK, \n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n)\n\nterra::plot(DEMSK)\nterra::plot(shpEcozoneSK[1], add = TRUE, col = \"transparent\")\n\nSK &lt;- SpaDES.project::setupStudyArea(list(level = 2, NAME_1 = \"Saskatchewan\", epsg = 5070))\nSKras &lt;- terra::rast(terra::ext(SK), res = 250, val = 1)\nterra::crs(SKras) &lt;- terra::crs(SK)\n\nDEMSK250m &lt;- prepInputs(\n  url = urlTif1,\n  to = SKras,                   # &lt;-   template raster\n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n)\nterra::plot(DEMSK250m)\n\nDEMSK250m &lt;- prepInputs(\n  url = urlTif1,\n  to = SKras, \n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n) |&gt; \n  Cache()\n\n# run later... very fast\nDEMSK250m &lt;- prepInputs(\n  url = urlTif1,\n  to = SKras, \n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n) |&gt; \n  Cache()\n\nLuxembourgFull &lt;- prepInputs(\n dlFun =\n   geodata::gadm(name = \"GADM\", country = \"LUX\", level = 0, path = \"~/SpaDES_book/prepInputs\") # preProcess keeps file from this!\n) |&gt; Cache()\n\nLuxembourgInnerBuffer &lt;- prepInputs(\n  dlFun =\n    geodata::gadm(name = \"GADM\", country = \"LUX\", level = 0, path = \"~/SpaDES_book/prepInputs\") # preProcess keeps file from this!\n  ,\n  fun = {                      # Custom function\n    out &lt;- readRDS(targetFile)\n    out &lt;- terra::vect(out)\n    terra::buffer(out, 5000)\n  }\n) |&gt; Cache()\n\nterra::plot(LuxembourgInnerBuffer)\nterra::plot(Luxembourg, add = TRUE)",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "debugging.html",
    "href": "debugging.html",
    "title": "12  Debugging SpaDES Modules",
    "section": "",
    "text": "12.1 Debugging with browser()\nbrowser() calls are very useful when you have access to the source code. When inserted inside a function, they will interrupt code execution at that point and allow the user to “enter” the function’s environment in debugging mode – i.e. they will have access to all the objects the function has access to internally.\nLet’s define a simple function and then use it improperly.\nCode\nmyFun &lt;- function(x, y) {\n  out &lt;- sum(x, y)\n  return(out)\n}\n\nmyFun(runif(20), \"A\")\nBecause we have the source code, we can:\nCode\nmyFun &lt;- function(x, y) {\n  browser()\n  out &lt;- sum(x, y)\n  return(out)\n}\n\nmyFun(runif(20), \"A\")\nCode\n# &gt; myFun(runif(20), \"A\")\n# Called from: myFun(runif(20), \"A\")\n# Browse[1]&gt; x\n#  [1] 0.48059327 0.12201652 0.39367787 0.91989186 0.04872701 0.85632846 0.05945062 0.87683559 0.58599446 0.10403352 0.49429023\n#  [12] 0.69785397 0.19622413 0.05559181 0.20329131 0.14909383 0.61400844 0.73638292 0.21185129 0.72534305\n# Browse[1]&gt; y\n#  [1] \"A\"\nFrom the above we would quickly realise we were trying to add a numeric vector with a character vector, which obviously doesn’t work.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "debugging.html#debugging-with-browser",
    "href": "debugging.html#debugging-with-browser",
    "title": "12  Debugging SpaDES Modules",
    "section": "",
    "text": "12.1.1 browser() with a SpaDES module\nGo back to the module My_linear_model created in Chapter 4 and insert a browser() in the init event, save the module and run again.\n\n\nCode\ndoEvent.My_linear_model.init &lt;- function(sim, eventTime, eventType, priority) {\n    browser()\n    x &lt;- rnorm(10)\n    y &lt;- x + rnorm(10)\n    sim$model &lt;- lm(y ~ x)  \n    return(invisible(sim))\n}\n\n\nIf you are using RStudio, it probably opened the module .R script (if not try right-clicking the RStudio window and selecting “Reload”), showing a highlighted browser() line. The R console shows:\n\n\nCode\nout &lt;- simInit(modules = \"My_linear_model\", paths = list(modulePath = modulePath))\nout &lt;- spades(out)\n\n\n\n\nCode\n# No packages to install/update\n# Jun09 00:03:51 simInit Resetting .Random.seed of session because sim$._randomSeed is not NULL. To get a different seed, run: sim$._randomSeed &lt;- NULL to clear it.\n# Jun09 00:03:51 simInit Using setDTthreads(1). To change: 'options(spades.DTthreads = X)'.\n# Jun09 00:03:51 chckpn:init total elpsd: 21 secs | 0 checkpoint init 0\n# Jun09 00:03:51 save  :init total elpsd: 21 secs | 0 save init 0\n# Jun09 00:03:51 prgrss:init total elpsd: 21 secs | 0 progress init 0\n# Jun09 00:03:51 load  :init total elpsd: 21 secs | 0 load init 0\n# Jun09 00:03:51 My_lnr:init total elpsd: 21 secs | 0 My_linear_model init 1\n# Called from: get(moduleCall, envir = fnEnv)(sim, cur[[\"eventTime\"]], cur[[\"eventType\"]])\n\n\nUse ls() to see what objects are in the function environment, then execute code line-by-line with ENTER, F10 or the “Next” button.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "debugging.html#debugging-with-debug-and-debugonce",
    "href": "debugging.html#debugging-with-debug-and-debugonce",
    "title": "12  Debugging SpaDES Modules",
    "section": "12.2 Debugging with debug() and debugonce()",
    "text": "12.2 Debugging with debug() and debugonce()\nIf we don’t have access to the function code (or don’t want to insert a browser()) we can use debug() and debugonce(). The effect will be similar to having a browser() in the first line of a function’s definition.\nHere’s an example:\n\n\nCode\ndebugonce(\"time\")\n\ntime(out) ## then press ENTER to execute each line of code one-by-one\n\n\nundebug(&lt;function_name&gt;) will de-activate debugging for that function.\n\n12.2.1 debugonce() and debug() with a SpaDES module\nThe process would be similar in a module, with the difference that the debug()/debugonce() call would either happen before running the module with spades(), OR from within the module in debugging mode.\n\n\n\n\n\n\nIf debugging module functions, they might not be easily available from the .GlobalEnv since they “live” inside the simList.\nThe easiest way to debug module functions is to\n\nInsert a browser() in that function\n\nOR\n\nInsert a browser() in the module, before the function is called\nCall debugonce(\"&lt;function_name&gt;\")/debug(\"&lt;function_name&gt;\")\nProceed to executing the function\n\n\n\n\nLet’s try it:\n\nExit browser() mode (e.g., enter Q in the R console)\nRemove the browser() from My_linear_model\nRun debugonce(\"lm\").\nRun the simInit() + spades() lines again to re-source module code and run the module OR run restartSpades() which will re-parse the module code and resume the workflow from the top of the event that was interrupted (the init).\n\nWhat objects does ls() show now?\n\nExit debugging mode again\nRe-run restartSpades()\n\nAre you back in debugging mode?\n\n\nNow go through steps 1-6 again, but replace debugonce(\"lm\") with debug(\"lm\") in step 3. What happened in step 6. this time?\n\n\n\n\n\n\nIf debugging functions that are S4 objects, you may need to be aware of which method needs to be debugged before calling debug or debugOnce.\nTry showMethods(\"show\") to see all the methods implemented.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "debugging.html#restartspades",
    "href": "debugging.html#restartspades",
    "title": "12  Debugging SpaDES Modules",
    "section": "12.3 restartSpades()",
    "text": "12.3 restartSpades()\nProbably one of our BFFs (best-friend functions) as SpaDES developpers, it will allow resuming a workflow whose execution was interrupted by an error or the user from the top of the interrupted event, but will first re-parse module code.\nThis means that we can insert a browser() somewhere in the event code, then restartSpades() and debug the event.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "debugging.html#a-note-on-testing-spades-modules",
    "href": "debugging.html#a-note-on-testing-spades-modules",
    "title": "12  Debugging SpaDES Modules",
    "section": "12.4 A note on testing SpaDES modules",
    "text": "12.4 A note on testing SpaDES modules\nModule testing can happen at several levels:\n\nAssertions – tests/checks embedded in module code.\nUnit tests of module functions - individual functions are tested independently of the module.\nSolo-module testing - the module is tested alone with default and non-default input/parameter values.\nIntegration tests - the module is tested in a workflow with other modules, using alone with default and non-default input/parameter values.\n\nAt a minimum, a developer should put in place assertions. These are small checks and tests inserted in the module code that issue meaningful warnings/error messages to users when they fail. Here’s an example of an assertion:\n\n\nCode\nmyFunction &lt;- function(x, ...) {\n  if (!inherits(x, c(\"numeric\", \"integer\"))) {\n    stop(\"x should be a numeric/integer vector\")\n  }\n  mean(x, ...)\n}\n\nmyFunction(LETTERS[1:10])\n# Error in myFunction(LETTERS[1:10]) : x should be a numeric/integer vector\n\n\nUnit tests require “pulling out” the functions in the module and, potentially, testing them in separate testing workflows.\nIntegration tests are implicitly done when modules are put together for particular projects, but this will only cover a specific set of input/parameter values and conditions. Therefore, it is ideal to also do solo-module testing and integration tests that capture a range of module setup conditions.\nThis is time-consuming work, but does pay off in the long-run especially if tests are repeated on a regular basis. For this reason, SpaDES.core::newModule() creates a tests/ folder in the module folder as a reminder to the developer that they should eventually develop tests for their modules.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "debugging.html#try-on-your-own",
    "href": "debugging.html#try-on-your-own",
    "title": "12  Debugging SpaDES Modules",
    "section": "12.5 Try on your own",
    "text": "12.5 Try on your own\n\nTry to debug the first method of the function show(). Here’s a tip: start with showMethods(\"show\").",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "debugging.html#see-also",
    "href": "debugging.html#see-also",
    "title": "12  Debugging SpaDES Modules",
    "section": "12.6 See also",
    "text": "12.6 See also\n?browser()\n?debug()\n?restartSpades()\n?showMethods() – useful to find out what methods of a function you may want to activate debugging for\nAn example of debugging a more complex SpaDES workflow in Section 14.5\nDebugging – Advanced R\nHow to make a reprex",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "debugging.html#barebones-r-script",
    "href": "debugging.html#barebones-r-script",
    "title": "12  Debugging SpaDES Modules",
    "section": "12.7 Barebones R script",
    "text": "12.7 Barebones R script\n\n\nCode\nmyFun &lt;- function(x, y) {\n  out &lt;- sum(x, y)\n  return(out)\n}\n\nmyFun(runif(20), \"A\")\n\nmyFun &lt;- function(x, y) {\n  browser()\n  out &lt;- sum(x, y)\n  return(out)\n}\n\nmyFun(runif(20), \"A\")\n\n\n\n\n\nout &lt;- simInit(modules = \"My_linear_model\", paths = list(modulePath = modulePath))\nout &lt;- spades(out)\n\n\n\ndebugonce(\"time\")\n\ntime(out) ## then press ENTER to execute each line of code one-by-one\n\nmyFunction &lt;- function(x, ...) {\n  if (!inherits(x, c(\"numeric\", \"integer\"))) {\n    stop(\"x should be a numeric/integer vector\")\n  }\n  mean(x, ...)\n}\n\nmyFunction(LETTERS[1:10])\n# Error in myFunction(LETTERS[1:10]) : x should be a numeric/integer vector",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "setupProject.html",
    "href": "setupProject.html",
    "title": "SpaDES workflows and projects",
    "section": "",
    "text": "Some of the SpaDES-verse\nWe can see many of the known modules in the SpaDES-verse and how they interact through their shared inputs and outputs in this interactive figure:\nShow the code\nRequire::Install(c(\"igraph\", \"visNetwork\"))\n\nmodPath &lt;- \"~/SpaDES_book/listModules/\"\naccountsListLong &lt;- c(\"PredictiveEcology\", \"ianmseddy\", \"achubaty\",\n                       \"FOR-CAST\", \"eliotmcintire\", \"tati-micheletti\", \"CeresBarros\")\ngrepListLong &lt;- c(\"Biomass\", \"WBI\", \"LandR\", \"fireSense\", \"CBM\",\n                  \"LandMine\", \"LandWeb\", \"NRV\", #\"scfm\",\n                  \"priority\", \"fire\",\n                  \"dataPrep\", \"DataPrep\", \"RoF\", \"Ontario\", \"ROF\")\nmodsLong &lt;- SpaDES.project::listModules(grepListLong, accounts = accountsListLong,\n                                        excludeStale = FALSE)\nmodsLong &lt;- paste0(modsLong, \"@HEAD\")\n\n# downloads lots of modules\nmods &lt;- SpaDES.project::getModule(modsLong, modulePath = modPath)\n\nDT &lt;- SpaDES.project::moduleDependencies(modsLong, modulePath = modPath)\ngraph &lt;- SpaDES.project::moduleDependenciesToGraph(DT)\n(vn &lt;- SpaDES.project::PlotModuleGraph(graph))\nWe also sometimes represent these as hexes, following the R-package convention:\nThe idea with setupProject is that we can start weaving different groups of modules together. This is what we will do in the next sections.",
    "crumbs": [
      "SpaDES workflows and projects"
    ]
  },
  {
    "objectID": "workflowSimple2.html",
    "href": "workflowSimple2.html",
    "title": "13  Workflows with setupProject",
    "section": "",
    "text": "13.1 SpaDES.project::setupProject\nhttps://spades-project.predictiveecology.org/articles/i-getting-started.html",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "workflowSimple2.html#installation",
    "href": "workflowSimple2.html#installation",
    "title": "13  Workflows with setupProject",
    "section": "13.2 Installation",
    "text": "13.2 Installation\n\n\nCode\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\n# if (!require(\"SpaDES.project\"))\nRequire::Install(c(\"SpaDES.project\", \"SpaDES.core\", \"reproducible\"), repos = repos, dependencies = TRUE)\n\npackagePath = SpaDES.project::.libPathDefault(\"~/SpaDES_book/integratingSpaDESmodules\")\n\n\n\n\nCode\npackagePath = SpaDES.project::.libPathDefault(\"PredictiveEcology.org\")",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "workflowSimple2.html#using-setupproject",
    "href": "workflowSimple2.html#using-setupproject",
    "title": "13  Workflows with setupProject",
    "section": "13.3 Using setupProject",
    "text": "13.3 Using setupProject\nsetupProject does a series of very specific things, in a particular order, so that the chances of package conflicts and user errors are minimized.\nNote how it downloads the listed modules directly from their GitHub repositories (e.g. tati-micheletti/speciesAbundance)\n\n\nCode\n##################### PART II: Download the modules and install the needed packages\nSetup &lt;- SpaDES.project::setupProject(\n  \n  paths = list(projectPath = \"~/SpaDES_book/integratingSpaDESmodules\",\n               packagePath = packagePath),\n  \n  modules = c(\"tati-micheletti/speciesAbundance@main\",\n              \"tati-micheletti/temperature@main\",\n              \"tati-micheletti/speciesAbundTempLM@main\"),\n  \n  times = list(start = 2013,\n               end = 2030),\n  \n  updateRprofile = FALSE\n  \n)\n\n\nThe output of setupProject is a list of argument values that can be passed to simInitAndSpaDES2 (with the “2” it accepts a list of arguments, instead of the arguments themselves).\n\n\nCode\nresults &lt;- SpaDES.core::simInitAndSpades2(Setup)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "workflowSimple2.html#emergent-workflow",
    "href": "workflowSimple2.html#emergent-workflow",
    "title": "13  Workflows with setupProject",
    "section": "13.4 Emergent workflow",
    "text": "13.4 Emergent workflow\nWe can evaluate the sequence of events using completed\n\n\nCode\nSpaDES.core::completed(results)\n\n\n    eventTime         moduleName            eventType eventPriority\n        &lt;num&gt;             &lt;char&gt;               &lt;char&gt;         &lt;num&gt;\n 1:      2013         checkpoint                 init             0\n 2:      2013               save                 init             0\n 3:      2013           progress                 init             0\n 4:      2013               load                 init             0\n 5:      2013   speciesAbundance                 init             1\n 6:      2013        temperature                 init             1\n 7:      2013 speciesAbundTempLM                 init             1\n 8:      2013   speciesAbundance       tableToRasters             5\n 9:      2013   speciesAbundance                 plot             5\n10:      2013        temperature         dataToRaster             5\n11:      2013        temperature             plotting             5\n12:      2013 speciesAbundTempLM        tableBuilding             5\n13:      2014   speciesAbundance       tableToRasters             5\n14:      2014        temperature         dataToRaster             5\n15:      2014 speciesAbundTempLM        tableBuilding             5\n16:      2015   speciesAbundance       tableToRasters             5\n17:      2015        temperature         dataToRaster             5\n18:      2015 speciesAbundTempLM        tableBuilding             5\n19:      2016   speciesAbundance       tableToRasters             5\n20:      2016        temperature         dataToRaster             5\n21:      2016 speciesAbundTempLM        tableBuilding             5\n22:      2017   speciesAbundance       tableToRasters             5\n23:      2017        temperature         dataToRaster             5\n24:      2017 speciesAbundTempLM        tableBuilding             5\n25:      2018   speciesAbundance                 plot             5\n26:      2018   speciesAbundance       tableToRasters             5\n27:      2018        temperature         dataToRaster             5\n28:      2018 speciesAbundTempLM        tableBuilding             5\n29:      2019   speciesAbundance       tableToRasters             5\n30:      2019        temperature         dataToRaster             5\n31:      2019 speciesAbundTempLM        tableBuilding             5\n32:      2020   speciesAbundance       tableToRasters             5\n33:      2020        temperature         dataToRaster             5\n34:      2020 speciesAbundTempLM        tableBuilding             5\n35:      2021   speciesAbundance       tableToRasters             5\n36:      2021        temperature         dataToRaster             5\n37:      2021 speciesAbundTempLM        tableBuilding             5\n38:      2022   speciesAbundance       tableToRasters             5\n39:      2022        temperature         dataToRaster             5\n40:      2022 speciesAbundTempLM        tableBuilding             5\n41:      2023        temperature             plotting             5\n42:      2023        temperature         dataToRaster             5\n43:      2023 speciesAbundTempLM        tableBuilding             5\n44:      2023 speciesAbundTempLM        modelBuilding             5\n45:      2023 speciesAbundTempLM abundanceForecasting             5\n46:      2023 speciesAbundTempLM                 plot             5\n47:      2024        temperature         dataToRaster             5\n48:      2024 speciesAbundTempLM abundanceForecasting             5\n49:      2024 speciesAbundTempLM                 plot             5\n50:      2025        temperature         dataToRaster             5\n51:      2025 speciesAbundTempLM abundanceForecasting             5\n52:      2025 speciesAbundTempLM                 plot             5\n53:      2026        temperature         dataToRaster             5\n54:      2026 speciesAbundTempLM abundanceForecasting             5\n55:      2026 speciesAbundTempLM                 plot             5\n56:      2027        temperature         dataToRaster             5\n57:      2027 speciesAbundTempLM abundanceForecasting             5\n58:      2027 speciesAbundTempLM                 plot             5\n59:      2028        temperature         dataToRaster             5\n60:      2028 speciesAbundTempLM abundanceForecasting             5\n61:      2028 speciesAbundTempLM                 plot             5\n62:      2029        temperature         dataToRaster             5\n63:      2029 speciesAbundTempLM abundanceForecasting             5\n64:      2029 speciesAbundTempLM                 plot             5\n65:      2030        temperature         dataToRaster             5\n66:      2030 speciesAbundTempLM abundanceForecasting             5\n67:      2030 speciesAbundTempLM                 plot             5\n    eventTime         moduleName            eventType eventPriority\n    ._prevEventTimeFinish           clockTime\n                   &lt;POSc&gt;              &lt;POSc&gt;\n 1:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 2:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 3:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 4:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 5:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 6:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 7:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 8:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 9:   2024-06-12 01:40:15 2024-06-12 01:40:15\n10:   2024-06-12 01:40:15 2024-06-12 01:40:15\n11:   2024-06-12 01:40:15 2024-06-12 01:40:15\n12:   2024-06-12 01:40:15 2024-06-12 01:40:15\n13:   2024-06-12 01:40:15 2024-06-12 01:40:15\n14:   2024-06-12 01:40:15 2024-06-12 01:40:15\n15:   2024-06-12 01:40:15 2024-06-12 01:40:15\n16:   2024-06-12 01:40:15 2024-06-12 01:40:15\n17:   2024-06-12 01:40:15 2024-06-12 01:40:15\n18:   2024-06-12 01:40:15 2024-06-12 01:40:15\n19:   2024-06-12 01:40:15 2024-06-12 01:40:15\n20:   2024-06-12 01:40:15 2024-06-12 01:40:15\n21:   2024-06-12 01:40:15 2024-06-12 01:40:15\n22:   2024-06-12 01:40:15 2024-06-12 01:40:15\n23:   2024-06-12 01:40:15 2024-06-12 01:40:15\n24:   2024-06-12 01:40:15 2024-06-12 01:40:15\n25:   2024-06-12 01:40:15 2024-06-12 01:40:15\n26:   2024-06-12 01:40:15 2024-06-12 01:40:15\n27:   2024-06-12 01:40:15 2024-06-12 01:40:15\n28:   2024-06-12 01:40:15 2024-06-12 01:40:15\n29:   2024-06-12 01:40:15 2024-06-12 01:40:15\n30:   2024-06-12 01:40:15 2024-06-12 01:40:15\n31:   2024-06-12 01:40:15 2024-06-12 01:40:15\n32:   2024-06-12 01:40:15 2024-06-12 01:40:15\n33:   2024-06-12 01:40:15 2024-06-12 01:40:15\n34:   2024-06-12 01:40:15 2024-06-12 01:40:15\n35:   2024-06-12 01:40:15 2024-06-12 01:40:15\n36:   2024-06-12 01:40:15 2024-06-12 01:40:15\n37:   2024-06-12 01:40:15 2024-06-12 01:40:15\n38:   2024-06-12 01:40:15 2024-06-12 01:40:15\n39:   2024-06-12 01:40:15 2024-06-12 01:40:15\n40:   2024-06-12 01:40:15 2024-06-12 01:40:15\n41:   2024-06-12 01:40:15 2024-06-12 01:40:15\n42:   2024-06-12 01:40:15 2024-06-12 01:40:15\n43:   2024-06-12 01:40:15 2024-06-12 01:40:15\n44:   2024-06-12 01:40:15 2024-06-12 01:40:16\n45:   2024-06-12 01:40:16 2024-06-12 01:40:16\n46:   2024-06-12 01:40:16 2024-06-12 01:40:16\n47:   2024-06-12 01:40:16 2024-06-12 01:40:16\n48:   2024-06-12 01:40:16 2024-06-12 01:40:16\n49:   2024-06-12 01:40:16 2024-06-12 01:40:16\n50:   2024-06-12 01:40:16 2024-06-12 01:40:16\n51:   2024-06-12 01:40:16 2024-06-12 01:40:16\n52:   2024-06-12 01:40:16 2024-06-12 01:40:16\n53:   2024-06-12 01:40:16 2024-06-12 01:40:16\n54:   2024-06-12 01:40:16 2024-06-12 01:40:16\n55:   2024-06-12 01:40:16 2024-06-12 01:40:16\n56:   2024-06-12 01:40:16 2024-06-12 01:40:16\n57:   2024-06-12 01:40:16 2024-06-12 01:40:16\n58:   2024-06-12 01:40:16 2024-06-12 01:40:16\n59:   2024-06-12 01:40:16 2024-06-12 01:40:16\n60:   2024-06-12 01:40:16 2024-06-12 01:40:16\n61:   2024-06-12 01:40:16 2024-06-12 01:40:16\n62:   2024-06-12 01:40:16 2024-06-12 01:40:16\n63:   2024-06-12 01:40:16 2024-06-12 01:40:16\n64:   2024-06-12 01:40:16 2024-06-12 01:40:17\n65:   2024-06-12 01:40:17 2024-06-12 01:40:17\n66:   2024-06-12 01:40:17 2024-06-12 01:40:17\n67:   2024-06-12 01:40:17 2024-06-12 01:40:17\n    ._prevEventTimeFinish           clockTime\n\n\nWe can also see how modules and objects interact using the functions objectDiagram() and moduleDiagram().\nModules’ diagram showing the interactions among modules:\n\n\nCode\nSpaDES.core::moduleDiagram(results)\n\n\n\n\n\n\n\n\n\nWe can also access any objects and use them. For example, we can look at the forecasted abundances and the difference raster is also possible. This is done by calling the object name from the results list.\n\n\nCode\nterra::plot(rast(results$forecasts))",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "workflowSimple2.html#examples",
    "href": "workflowSimple2.html#examples",
    "title": "13  Workflows with setupProject",
    "section": "13.5 Examples",
    "text": "13.5 Examples\nIn the remaining chapters of this section, we will explore several examples, including learning of several arguments to the function setupProject. But we will start very simple first.",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "workflowSimple2.html#see-also",
    "href": "workflowSimple2.html#see-also",
    "title": "13  Workflows with setupProject",
    "section": "13.6 See also",
    "text": "13.6 See also\nAll Functions in SpaDES.core\n?SpaDES.core::completed",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "workflowSimple2.html#barebones-r-script",
    "href": "workflowSimple2.html#barebones-r-script",
    "title": "13  Workflows with setupProject",
    "section": "13.7 Barebones R script",
    "text": "13.7 Barebones R script\n\n\nCode\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\n# if (!require(\"SpaDES.project\"))\nRequire::Install(c(\"SpaDES.project\", \"SpaDES.core\", \"reproducible\"), repos = repos, dependencies = TRUE)\n\npackagePath = SpaDES.project::.libPathDefault(\"~/SpaDES_book/integratingSpaDESmodules\")\n\npackagePath = SpaDES.project::.libPathDefault(\"PredictiveEcology.org\")\n\n##################### PART II: Download the modules and install the needed packages\nSetup &lt;- SpaDES.project::setupProject(\n  \n  paths = list(projectPath = \"~/SpaDES_book/integratingSpaDESmodules\",\n               packagePath = packagePath),\n  \n  modules = c(\"tati-micheletti/speciesAbundance@main\",\n              \"tati-micheletti/temperature@main\",\n              \"tati-micheletti/speciesAbundTempLM@main\"),\n  \n  times = list(start = 2013,\n               end = 2030),\n  \n  updateRprofile = FALSE\n  \n)\n\nresults &lt;- SpaDES.core::simInitAndSpades2(Setup)\n\nSpaDES.core::completed(results)\n\nSpaDES.core::moduleDiagram(results)\n\nterra::plot(rast(results$forecasts))",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html",
    "href": "LandRDemo_coreVeg.html",
    "title": "14  Forest Landscape Modelling with LandR and setupProject",
    "section": "",
    "text": "14.1 All the steps of an ecological modelling project in a continuous workflow",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#workflow-setup",
    "href": "LandRDemo_coreVeg.html#workflow-setup",
    "title": "14  Forest Landscape Modelling with LandR and setupProject",
    "section": "14.2 Workflow setup",
    "text": "14.2 Workflow setup\n\n\nShow code\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\ninstall.packages(c(\"SpaDES.project\", \"Require\"), repos = repos)\n\n\nlibrary(SpaDES.project)\n\nout &lt;- setupProject(\n  # INPUT OBJECTS -----------------------------------\n  # these need to come *before* any formal arguments, as they are needed for params.R\n  sppEquivCol = \"Boreal\",\n  vegLeadingProportion = 0,\n  successionTimestep = 10L,\n  eventCaching = c(\".inputObjects\", \"init\"),\n  useParallel = FALSE,\n  overwrite = TRUE, # Just run this once. Then remove it.\n  Restart = TRUE,\n  standAlone = TRUE,\n  paths = list(\"packagePath\" = \"packages/\",\n               \"projectPath\" = \"~/SpaDES_book/LandRDemo_coreVeg\"),\n  packages = c(\n    # these are needed but don't load\n    \"DiagrammeR\",\n    \"lattice (&gt;= 0.22.5)\",\n    \"SpaDES.project (&gt;= 0.1.0.9003)\",\n    \"LandR (&gt;=1.1.5.9000)\",\n    \"quickPlot (&gt;= 1.0.2.9003)\",\n    \"reproducible (&gt;= 2.1.1.9002)\",\n    \"eliotmcintire/PSPclean@Eliot (&gt;= 0.1.4.9006)\",\n    \"PredictiveEcology/SpaDES.experiment@development (HEAD)\",\n    \"SpaDES.core (&gt;= 2.1.5)\",\n    \"terra\"\n  ),\n  options = list(\n    \"LandR.assertions\" = TRUE,\n    \"reproducible.destinationPath\" = paths$inputPath,\n    \"spades.inputPath\" = paths$inputPath,\n    \"spades.moduleCodeChecks\" = FALSE,\n    \"repos\" = repos\n  ),\n  modules = c(\n    \"PredictiveEcology/Biomass_speciesData@main\",\n    \"PredictiveEcology/Biomass_borealDataPrep@main\",\n    \"PredictiveEcology/Biomass_speciesParameters@main\",\n    \"PredictiveEcology/Biomass_core@main\"\n  ),\n  # SIMULATION SETUP ------------------------------------\n  times = list(start = 2001, end = 2031),\n  params = \"PredictiveEcology/PredictiveEcology.org@training-book/tutos/LandRDemo_coreVeg/params.R\",\n  # (more) INPUT OBJECTS -----------------------------------\n  # these come after, so that we don't need to pre-install/load LandR\n  # species lists/traits\n  sppEquiv = {\n    data(\"sppEquivalencies_CA\", package = \"LandR\")\n    sppEquivalencies_CA[grep(\"Pin\", LandR), `:=`(EN_generic_short = \"Pine\",\n                                                 EN_generic_full = \"Pine\",\n                                                 Leading = \"Pine leading\")]\n    sppEquivalencies_CA[grep(\"Betu_pap\", LandR), `:=`(EN_generic_short = \"Birch\",\n                                                      EN_generic_full = \"Birch\",\n                                                      Leading = \"Birch leading\")]\n    # all Popu will be merged\n    sppEquivalencies_CA[grep(\"Popu_\", LandR), `:=`(EN_generic_short = \"Poplar\",\n                                                   EN_generic_full = \"Poplar\",\n                                                   Leading = \"Poplar leading\")]\n    sppEquivalencies_CA[grep(\"Popu_\", LandR), Boreal := \"Popu_Spp\"]\n\n    # define spp column to use for model\n    sppEquivalencies_CA &lt;- sppEquivalencies_CA[!\"\", on = sppEquivCol]\n    sppEquivalencies_CA &lt;- na.omit(sppEquivalencies_CA, sppEquivCol)\n    sppEquivalencies_CA\n  },\n  speciesParams = {\n    list(\n      \"shadetolerance\" = list(\n        Betu_Pap = 1\n        , Lari_Lar = 1\n        , Pice_Gla = 2\n        , Pice_Mar = 3\n        , Pinu_Ban = 1.5\n        , Popu_Spp = 1\n      )\n    )\n  },\n  studyArea = {\n    originalcrs &lt;- \"+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    Biomass_corecrs &lt;- \"+proj=lcc +lat_1=49 +lat_2=77 +lat_0=0 +lon_0=-95 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n\n    smallExtent &lt;- c(xmin = -104.757, xmax = -104.48835, ymin = 55.68663, ymax = 55.94491)\n    studyAreaS &lt;- terra::vect(terra::ext(smallExtent))\n    studyAreaS &lt;-  terra::vect(terra::geom(studyAreaS), \"polygons\", crs = originalcrs, atts = data.frame(id = 1:length(studyAreaS)))\n    studyAreaS &lt;- terra::project(studyAreaS, Biomass_corecrs)\n    studyAreaS\n  },\n  studyAreaLarge = {\n    originalcrs &lt;- \"+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    Biomass_corecrs &lt;- \"+proj=lcc +lat_1=49 +lat_2=77 +lat_0=0 +lon_0=-95 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    largeExtent &lt;- c(xmin = -104.757, xmax = -104.2197, ymin = 55.68663, ymax = 56.20319)\n\n    studyAreaL &lt;- terra::vect(terra::ext(largeExtent))\n    studyAreaL &lt;-  terra::vect(terra::geom(studyAreaL), \"polygons\", crs = originalcrs, atts = data.frame(id = 1:length(studyAreaL)))\n    studyAreaL &lt;- terra::project(studyAreaL, Biomass_corecrs)\n    studyAreaL\n  },\n  # OUTPUTS TO SAVE -----------------------\n  outputs = {\n    rbind(\n      data.frame(\n        objectName = \"cohortData\",\n        saveTime = seq(times$start, times$end)\n      ),\n      data.frame(\n        objectName = \"pixelGroupMap\",\n        saveTime = seq(times$start, times$end)\n      )\n    )\n  }\n)\n\n\nIf you have a look at Section 16.1 in the Chapter 16 chapter, you will see some differences in the way we setup the two workflows:\n\npaths. Here we left the defaults for all paths (see ?setupPaths() for the list of path options) except for the project location (projectPath) and the location of the package library (packagePath, which will be placed inside projectPath).\noptions. We also set a couple of “global options” that determine the where data will be downloaded to (“reproducible.destinationPath”). This will be the same as the default directory to look for inputs (“spades.inputPath”). Notice how we used paths$ to get these directory paths from the paths object that setupProject creates (based on the paths argument above) prior to setting the options.\nother arguments (...). Almost all other arguments in the call above were passed to .... These are objects that need to be supplied by the user for these modules (e.g. studyArea and studyAreaLarge) or whose defaults we want to override (e.g., the species table, sppEquiv, and trait values, speciesParams). To avoid creating them on the .GlobalEnv first, we take advantage of setupProject‘s ability to run the code in { } and make these polygons. Note that these arguments are passed prior to any ’formal arguments’ (see ?formalArgs())",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#run-simulation",
    "href": "LandRDemo_coreVeg.html#run-simulation",
    "title": "14  Forest Landscape Modelling with LandR and setupProject",
    "section": "14.3 Run simulation",
    "text": "14.3 Run simulation\n\nYou can initialise the and run the workflow in two separate steps…\n\n\nCode\n# initialise then run simulation \n# simInitOut &lt;- SpaDES.core::simInit2(out)\nsimInitOut &lt;- do.call(SpaDES.core::simInit, out)\nsimOut &lt;- SpaDES.core::spades(simInitOut)\n\n\n… or together, using simInitAndSpades2()\n\n\nCode\nsimOut &lt;- SpaDES.core::simInitAndSpades2(out)\n\n\n\n14.3.1 Inspect the workflow, its inputs, outputs and parameters\nNow that we have a simulation we can inspect it. Let’s assume you initialised and ran your simulation with two separate simInit2() and spades() calls.\nInspect module connections and between-module object flows:\n\n\nCode\nSpaDES.core::moduleDiagram(simInitOut)\nSpaDES.core::objectDiagram(simInitOut)  \n\n\n\n\n\n\n\n\n\n\n\nLandR vegetation module ‘connections’.\n\n\n\n\n\n\n\nObject flows between modules (truncated).\n\n\n\n\n\nNote the scheduling of the init events in simInitOut and how simOut has future events scheduled too – thanks to this, we can extend the simulation beyond the original SpaDES.core::end(sim) of 2031 (Extend the simulation).\n\n\nCode\nSpaDES.core::events(simInitOut)\nSpaDES.core::events(simOut)\n\n\nWe can also have a look at the completed events:\n\n\nCode\nSpaDES.core::completed(simInitOut)\nSpaDES.core::completed(simOut)\n\n\nFinally, the following accessor functions will show a list of model inputs, outputs and parameters:\n\n\nCode\nSpaDES.core::inputs(simOut)\nSpaDES.core::outputs(simOut)\nSpaDES.core::parameters(simOut)\n\n\nWe could even plot some of the input and output rasters to check that they are as we expected – no need to look for these objects files, they are all in the simList.\n\n\nCode\n# spatial inputs from list above\nterra::plot(simOut$studyAreaLarge, col = \"navyblue\", main = \"studyArea & studyAreaLarge\")\nterra::plot(simOut$studyArea, col = \"lightblue\", add = TRUE)\n\n# spatial outputs from list above\nterra::plot(simOut$vegTypeMap, \n            col = hcl.colors(palette = \"Dynamic\", n = length(unique(simOut$vegTypeMap[]))), \n            main = \"\")\nterra::plot(simOut$speciesLayers)\n\n\n\n\n\n\n\n\n\n\n\nStudy areas used for parameterisation (dark blue) and simulation (light blue).\n\n\n\n\n\n\n\nLast year’s vegetation type map (leading species).\n\n\n\n\n\n\n\nPercent cover of species retained for simulation.\n\n\n\n\n\n\nInspecting inputs and outputs directly from the simList\n\n\n\nMore importantly in our view, is the ability to inspect statistical models used to fit model parameters. This is possible because the developers have declared the fitted statistical model objects as module outputs. Often, this type of information is buried in supplementary materials of papers and incomplete (e.g. coefficients and goodness-of-fit statistics are presented, but the entire model object, with its fitted values, residuals, etc., are not).\nBy exporting entire model objects, and making them available via repeatable code or data repositories, model transparency and potential scrutiny are massively increased.\n\n\nCode\n# model used to estimate species establishment probabilities\nsummary(simOut$modelBiomass$mod)\nplot(simOut$modelBiomass$mod)\n\n# model used to calibrate Picea glauca's growth parameters\nsummary(simOut$speciesGrowthCurves$Pice_Gla$NonLinearModel$Pice_Gla)\n\n\n\n\n14.3.2 Turn plotting on after setting up the workflow\nWe can change parameters and re-run the simulation to, e.g., activate live plotting in Biomass_core, without having to\n\nchange the parameter provided to setupProject\nrepeat the setupProject call\n\nNote that because simOut is actually a copy of simInitOut (see the output of SpaDES.core::completed(simInitOut)), this still means that simInitOut has to be re-generated for this purpose, otherwise spades would try to resume the simulation from the “last year”.\nThanks to internal caching, it will only take seconds to “redo” simInitOut. You will also notice that init events are retrieved from cache, this time around2.\n\n\nCode\nsimInitOut &lt;- SpaDES.core::simInit2(out)\nSpaDES.core::P(simInitOut, param = \".plots\", module = \"Biomass_core\") &lt;- \"screen\"\nSpaDES.core::P(simInitOut, param = \".plotMaps\", module = \"Biomass_core\") &lt;- TRUE\nsimOut &lt;- SpaDES.core::spades(simInitOut)\n\n\n\n\n14.3.3 Extend the simulation\nWe can also keep it going for a few more years. Use SpaDES.core::end() to extend the simulation another 20 years and then call SpaDES.core::spades() on the changed simList (not the one output by `SpaDES.core::simInit2()) to resume the simulation from 2031.\n\n\nCode\nSpaDES.core::end(simOut) &lt;- 2061\nsimOut &lt;- SpaDES.core::spades(simOut)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#sec-LandRScenarios",
    "href": "LandRDemo_coreVeg.html#sec-LandRScenarios",
    "title": "14  Forest Landscape Modelling with LandR and setupProject",
    "section": "14.4 Different scenarios and model selection",
    "text": "14.4 Different scenarios and model selection\nIn Barros et al. (2023), the model was run with two different parameterisation approaches one that was “data hungry” and calibrated tree species growth parameters (using Biomass_speciesParameters as we have done above) and a simpler one that used default parameter values (without Biomass_speciesParameters).\nSpaDES and LandR allow us to swap parameterisation/calibration approaches easily and re-evaluate each and compare the models (see Barros et al. (2023)).\nDo to this, we simply exclude Biomass_speciesParameters from out and run a second simulation. We also need to save the outputs in a different folder, or the previous ones will be overriden.\n\n\nCode\nout2 &lt;- out\nout2$modules &lt;- out2$modules[out2$modules != \"Biomass_speciesParameters\"]\nout2$paths$outputPath &lt;- normPath(file.path(\"~/SpaDES_book/LandRDemo_coreVeg\", \"outputsSim2\"))\n\nsimOut2 &lt;- SpaDES.core::simInitAndSpades2(out2)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#sec-LandRdebug",
    "href": "LandRDemo_coreVeg.html#sec-LandRdebug",
    "title": "14  Forest Landscape Modelling with LandR and setupProject",
    "section": "14.5 Debugging",
    "text": "14.5 Debugging\nThere are several ways to debug SpaDES modules (see Chapter 12), a relatively easy one for when you are suprised by an error occurring during specific event is to pass the event’s name to spades(..., debug = ) argument.\nBelow, we debug the plotSummaryBySpecies event of Biomass_core. R interrupts the execution of the code in the chunk that executes this event’s operations (inside doEvent.Biomass_core())\n\n\nCode\nsimOut &lt;- SpaDES.core::spades(simInitOut, debug = \"plotSummaryBySpecies\")\n\n\nR interrupts code execution during this event’s operations (inside doEvent.Biomass_core()):\ndebugging in: get(moduleCall, envir = fnEnv)(sim, cur[[\"eventTime\"]], cur[[\"eventType\"]])\ndebug at C:/Users/cbarros/Documents/SpaDES_book/LandRDemo_coreVeg/modules/Biomass_core/Biomass_core.R#314: {\n(...)\nFrom there you can press ENTER, F10 or the “Next” button to execute the code line-by-line. At some point you will get to this line:\n\n\nCode\nsim &lt;- plotSummaryBySpecies(sim)\n\n\nwhich calls the function that effectively makes the summary plots. If you spotted a problem during the plotSummaryBySpecies event (or maybe you want to see what it does and/or change the code) and it hasn’t been triggered yet, then it’s likely it happened in this function.\nBefore running the line you can debugonce(plotSummaryBySpecies) to enable debugging the function and spot the issue.\nAnother option would be to insert a browser() at the top of the function’s definition inside the module code or the R scripts in the module’s R/ folder (&lt;modulePath&gt;/&lt;module_name&gt;/R/). In this case look for plotSummaryBySpecies &lt;- compiler::cmpfun(function(sim) {...} inside the module code (Biomass_core.R) and try putting a browser() inside the {}",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#try-on-your-own",
    "href": "LandRDemo_coreVeg.html#try-on-your-own",
    "title": "14  Forest Landscape Modelling with LandR and setupProject",
    "section": "14.6 Try on your own",
    "text": "14.6 Try on your own\nTry re-running the workflow with a different set of study areas. For example:\n\n\nCode\n# studyArea could be\nstudyArea = {\nset.seed(123)\nSpaDES.tools::randomStudyArea(size = 200000000)\n}\n\n# studyAreaLarge\nstudyAreaLarge = {\nterra::buffer(studyArea, width = 10000)\n}\n\n\n\nNoticed any differences (speed, cache IDs, …)?\nwere the species simulated the same? How about their trait values (e.g. estimated maxB, species establishment probabilities. )",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#see-also",
    "href": "LandRDemo_coreVeg.html#see-also",
    "title": "14  Forest Landscape Modelling with LandR and setupProject",
    "section": "14.7 See also",
    "text": "14.7 See also\nChapter 10 on caching.\nLandR Manual\n?future::plan\nsimList accessors",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#barebones-r-script",
    "href": "LandRDemo_coreVeg.html#barebones-r-script",
    "title": "14  Forest Landscape Modelling with LandR and setupProject",
    "section": "14.8 Barebones R script",
    "text": "14.8 Barebones R script\n\n\nCode\ninstall.packages(c(\"googledrive\", \"httpuv\"), repos = repos)\n\ngoogledriveAuthPath &lt;- \"~/SpaDES_book/googledrive_auth_cache\"\ndir.create(googledriveAuthPath, showWarnings = FALSE)\ngoogledrive::drive_auth(cache = \"~/SpaDES_book/googledrive_auth_cache\")\n\n\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\ninstall.packages(c(\"SpaDES.project\", \"Require\"), repos = repos)\n\n\nlibrary(SpaDES.project)\n\nout &lt;- setupProject(\n  # INPUT OBJECTS -----------------------------------\n  # these need to come *before* any formal arguments, as they are needed for params.R\n  sppEquivCol = \"Boreal\",\n  vegLeadingProportion = 0,\n  successionTimestep = 10L,\n  eventCaching = c(\".inputObjects\", \"init\"),\n  useParallel = FALSE,\n  overwrite = TRUE, # Just run this once. Then remove it.\n  Restart = TRUE,\n  standAlone = TRUE,\n  paths = list(\"packagePath\" = \"packages/\",\n               \"projectPath\" = \"~/SpaDES_book/LandRDemo_coreVeg\"),\n  packages = c(\n    # these are needed but don't load\n    \"DiagrammeR\",\n    \"lattice (&gt;= 0.22.5)\",\n    \"SpaDES.project (&gt;= 0.1.0.9003)\",\n    \"LandR (&gt;=1.1.5.9000)\",\n    \"quickPlot (&gt;= 1.0.2.9003)\",\n    \"reproducible (&gt;= 2.1.1.9002)\",\n    \"eliotmcintire/PSPclean@Eliot (&gt;= 0.1.4.9006)\",\n    \"PredictiveEcology/SpaDES.experiment@development (HEAD)\",\n    \"SpaDES.core (&gt;= 2.1.5)\",\n    \"terra\"\n  ),\n  options = list(\n    \"LandR.assertions\" = TRUE,\n    \"reproducible.destinationPath\" = paths$inputPath,\n    \"spades.inputPath\" = paths$inputPath,\n    \"spades.moduleCodeChecks\" = FALSE,\n    \"repos\" = repos\n  ),\n  modules = c(\n    \"PredictiveEcology/Biomass_speciesData@main\",\n    \"PredictiveEcology/Biomass_borealDataPrep@main\",\n    \"PredictiveEcology/Biomass_speciesParameters@main\",\n    \"PredictiveEcology/Biomass_core@main\"\n  ),\n  # SIMULATION SETUP ------------------------------------\n  times = list(start = 2001, end = 2031),\n  params = \"PredictiveEcology/PredictiveEcology.org@training-book/tutos/LandRDemo_coreVeg/params.R\",\n  # (more) INPUT OBJECTS -----------------------------------\n  # these come after, so that we don't need to pre-install/load LandR\n  # species lists/traits\n  sppEquiv = {\n    data(\"sppEquivalencies_CA\", package = \"LandR\")\n    sppEquivalencies_CA[grep(\"Pin\", LandR), `:=`(EN_generic_short = \"Pine\",\n                                                 EN_generic_full = \"Pine\",\n                                                 Leading = \"Pine leading\")]\n    sppEquivalencies_CA[grep(\"Betu_pap\", LandR), `:=`(EN_generic_short = \"Birch\",\n                                                      EN_generic_full = \"Birch\",\n                                                      Leading = \"Birch leading\")]\n    # all Popu will be merged\n    sppEquivalencies_CA[grep(\"Popu_\", LandR), `:=`(EN_generic_short = \"Poplar\",\n                                                   EN_generic_full = \"Poplar\",\n                                                   Leading = \"Poplar leading\")]\n    sppEquivalencies_CA[grep(\"Popu_\", LandR), Boreal := \"Popu_Spp\"]\n\n    # define spp column to use for model\n    sppEquivalencies_CA &lt;- sppEquivalencies_CA[!\"\", on = sppEquivCol]\n    sppEquivalencies_CA &lt;- na.omit(sppEquivalencies_CA, sppEquivCol)\n    sppEquivalencies_CA\n  },\n  speciesParams = {\n    list(\n      \"shadetolerance\" = list(\n        Betu_Pap = 1\n        , Lari_Lar = 1\n        , Pice_Gla = 2\n        , Pice_Mar = 3\n        , Pinu_Ban = 1.5\n        , Popu_Spp = 1\n      )\n    )\n  },\n  studyArea = {\n    originalcrs &lt;- \"+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    Biomass_corecrs &lt;- \"+proj=lcc +lat_1=49 +lat_2=77 +lat_0=0 +lon_0=-95 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n\n    smallExtent &lt;- c(xmin = -104.757, xmax = -104.48835, ymin = 55.68663, ymax = 55.94491)\n    studyAreaS &lt;- terra::vect(terra::ext(smallExtent))\n    studyAreaS &lt;-  terra::vect(terra::geom(studyAreaS), \"polygons\", crs = originalcrs, atts = data.frame(id = 1:length(studyAreaS)))\n    studyAreaS &lt;- terra::project(studyAreaS, Biomass_corecrs)\n    studyAreaS\n  },\n  studyAreaLarge = {\n    originalcrs &lt;- \"+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    Biomass_corecrs &lt;- \"+proj=lcc +lat_1=49 +lat_2=77 +lat_0=0 +lon_0=-95 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    largeExtent &lt;- c(xmin = -104.757, xmax = -104.2197, ymin = 55.68663, ymax = 56.20319)\n\n    studyAreaL &lt;- terra::vect(terra::ext(largeExtent))\n    studyAreaL &lt;-  terra::vect(terra::geom(studyAreaL), \"polygons\", crs = originalcrs, atts = data.frame(id = 1:length(studyAreaL)))\n    studyAreaL &lt;- terra::project(studyAreaL, Biomass_corecrs)\n    studyAreaL\n  },\n  # OUTPUTS TO SAVE -----------------------\n  outputs = {\n    rbind(\n      data.frame(\n        objectName = \"cohortData\",\n        saveTime = seq(times$start, times$end)\n      ),\n      data.frame(\n        objectName = \"pixelGroupMap\",\n        saveTime = seq(times$start, times$end)\n      )\n    )\n  }\n)\n\n# initialise then run simulation \n# simInitOut &lt;- SpaDES.core::simInit2(out)\nsimInitOut &lt;- do.call(SpaDES.core::simInit, out)\nsimOut &lt;- SpaDES.core::spades(simInitOut)\n\nsimOut &lt;- SpaDES.core::simInitAndSpades2(out)\n\n\nSpaDES.core::moduleDiagram(simInitOut)\nSpaDES.core::objectDiagram(simInitOut)  \n\n\nSpaDES.core::events(simInitOut)\nSpaDES.core::events(simOut)\n\n\nSpaDES.core::completed(simInitOut)\nSpaDES.core::completed(simOut)\n\n\nSpaDES.core::inputs(simOut)\nSpaDES.core::outputs(simOut)\nSpaDES.core::parameters(simOut)\n\n# spatial inputs from list above\nterra::plot(simOut$studyAreaLarge, col = \"navyblue\", main = \"studyArea & studyAreaLarge\")\nterra::plot(simOut$studyArea, col = \"lightblue\", add = TRUE)\n\n# spatial outputs from list above\nterra::plot(simOut$vegTypeMap, \n            col = hcl.colors(palette = \"Dynamic\", n = length(unique(simOut$vegTypeMap[]))), \n            main = \"\")\nterra::plot(simOut$speciesLayers)\n\n# model used to estimate species establishment probabilities\nsummary(simOut$modelBiomass$mod)\nplot(simOut$modelBiomass$mod)\n\n# model used to calibrate Picea glauca's growth parameters\nsummary(simOut$speciesGrowthCurves$Pice_Gla$NonLinearModel$Pice_Gla)\n\n\nsimInitOut &lt;- SpaDES.core::simInit2(out)\nSpaDES.core::P(simInitOut, param = \".plots\", module = \"Biomass_core\") &lt;- \"screen\"\nSpaDES.core::P(simInitOut, param = \".plotMaps\", module = \"Biomass_core\") &lt;- TRUE\nsimOut &lt;- SpaDES.core::spades(simInitOut)\n\nSpaDES.core::end(simOut) &lt;- 2061\nsimOut &lt;- SpaDES.core::spades(simOut)\n\n\n\n\n\n\n\nout2 &lt;- out\nout2$modules &lt;- out2$modules[out2$modules != \"Biomass_speciesParameters\"]\nout2$paths$outputPath &lt;- normPath(file.path(\"~/SpaDES_book/LandRDemo_coreVeg\", \"outputsSim2\"))\n\nsimOut2 &lt;- SpaDES.core::simInitAndSpades2(out2)\n\n\nsimOut &lt;- SpaDES.core::spades(simInitOut, debug = \"plotSummaryBySpecies\")\n\n\nsim &lt;- plotSummaryBySpecies(sim)\n\n# studyArea could be\nstudyArea = {\nset.seed(123)\nSpaDES.tools::randomStudyArea(size = 200000000)\n}\n\n# studyAreaLarge\nstudyAreaLarge = {\nterra::buffer(studyArea, width = 10000)\n}\n\n\n\n\n\n\nBarros, Ceres, Yong Luo, Alex M. Chubaty, Ian M. S. Eddy, Tatiane Micheletti, Céline Boisvenue, David W. Andison, Steven G. Cumming, and Eliot J. B. McIntire. 2023. “Empowering Ecological Modellers with a PERFICT Workflow: Seamlessly Linking Data, Parameterisation, Prediction, Validation and Visualisation.” Methods in Ecology and Evolution 14 (1): 173–88. https://doi.org/10.1111/2041-210X.14034.\n\n\nScheller, Robert M., and Brian R. Miranda. 2015. LANDIS-II Biomass Succession V3.2 Extension  User Guide.",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#footnotes",
    "href": "LandRDemo_coreVeg.html#footnotes",
    "title": "14  Forest Landscape Modelling with LandR and setupProject",
    "section": "",
    "text": "See ?googledrive::drive_auth for more information.↩︎\nSee Chapter 10 about caching.↩︎",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "ForestsAndFire.html",
    "href": "ForestsAndFire.html",
    "title": "15  Forest Succession and Wildfire using setupProject",
    "section": "",
    "text": "15.1 Examining things\nWe can do all sorts of things. We will start with a few simple “accessors”, i.e., “access something from the simList”. completed shows the events that were run. elapsedTime shows how much time each event took.\nCode\ncompleted(outSim)\nelapsedTime(outSim, units = \"minute\")\nThe module metadata can be accessed from the sim or can be read from the module source files or it is usually built into the Rmd file that comes with the module.\nCode\nmm &lt;- moduleMetadata(outSim)\n\n# a list of all the module metadata\nmm$Biomass_borealDataPrep$",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Forest Succession and Wildfire using `setupProject`</span>"
    ]
  },
  {
    "objectID": "ForestsAndFire.html#changing-things",
    "href": "ForestsAndFire.html#changing-things",
    "title": "15  Forest Succession and Wildfire using setupProject",
    "section": "15.2 Changing things",
    "text": "15.2 Changing things\nSetting .plots = \"png\" will turn on all known plotting (that uses the Plots function) and save them all as png files in the figures subfolder.\n\n\nCode\nout$params$.globals$.plots &lt;- \"png\"\noutSim &lt;- simInitAndSpades2(out)\n\n\nThen we can look in the outputs/figures folder to see all the figures that the modules created.",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Forest Succession and Wildfire using `setupProject`</span>"
    ]
  },
  {
    "objectID": "ForestsAndFire.html#barebones-r-script",
    "href": "ForestsAndFire.html#barebones-r-script",
    "title": "15  Forest Succession and Wildfire using setupProject",
    "section": "15.3 Barebones R script",
    "text": "15.3 Barebones R script\n\n\nCode\nrepos &lt;- unique(c(\"predictiveecology.r-universe.dev\", getOption(\"repos\")))\noptions(repos = repos)\n\n# Require::Require(c(\"SpaDES.project (HEAD)\"))\nRequire::Require(c(\"PredictiveEcology/SpaDES.project@development (HEAD)\")) \n# pkgload::load_all(\"~/GitHub/SpaDES.project\")\n\nout &lt;- SpaDES.project::setupProject(\n  updateRprofile = TRUE,\n  name = \"scfm_example_fresh\",\n  useGit = FALSE,\n  paths = list(projectPath = \"~/SpaDES_book\"),\n  modules = c(\"PredictiveEcology/Biomass_borealDataPrep@development\",\n              \"PredictiveEcology/Biomass_core@development\",\n              \"PredictiveEcology/Biomass_regeneration@development\",\n              file.path(\"PredictiveEcology/scfm@development/modules\",\n                        c(\"scfmLandcoverInit\", \"scfmRegime\", \"scfmDriver\",\n                          \"scfmIgnition\", \"scfmEscape\", \"scfmSpread\",\n                          \"scfmDiagnostics\"))\n  ),\n  params = list(\n    .globals = list(.studyAreaName = \"scfm_example\",\n                    dataYear = 2011, #will get kNN 2011 data, and NTEMS 2011 landcover\n                    sppEquivCol = \"LandR\",\n                    .plots = \"png\",\n                    .useCache = c(\".inputObjects\", \"init\")\n                 ),\n    scfmDriver = list(targetN = 1000, #default is 4000 - higher targetN adds time + precision\n                      # targetN would ideally be minimum 2000 - mean fire size estimates will be bad with 1000\n                      .useParallelFireRegimePolys = TRUE) #assumes parallelization is an otpion\n    \n  ),\n  options = list(#spades.allowInitDuringSimInit = TRUE,\n                 spades.allowSequentialCaching = TRUE,\n                 spades.moduleCodeChecks = FALSE,\n                 #                reproducible.shapefileRead = \"terra::vect\",\n                 spades.recoveryMode = 1\n  ),\n  packages = c('RCurl', 'XML', 'snow'), # need for some downloading; if omitted, a message tells user\n  times = list(start = 2011, end = 2061),\n  sppEquiv = LandR::sppEquivalencies_CA[KNN %in% c(\"Popu_Tre\", \"Betu_Pap\",\n                                                   \"Pice_Gla\", \"Pice_Mar\",\n                                                   \"Pinu_Con\", \"Pinu_Ban\")],\n  studyArea = {\n    targetCRS &lt;- paste(\"+proj=lcc +lat_1=49 +lat_2=77 +lat_0=0 +lon_0=-95 +x_0=0 +y_0=0\",\n                       \"+datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0\")\n    sa &lt;- terra::vect(cbind(-1209980, 7586865), crs = targetCRS)\n    sa &lt;- LandR::randomStudyArea(center = sa, size = 10000 * 250 * 30000, seed = 1002)\n    sa &lt;- sf::st_as_sf(sa)\n  },\n  studyAreaLarge = {\n    sf::st_buffer(studyArea, 20000)\n  },\n  rasterToMatchLarge = {\n    rtml&lt;- terra::rast(terra::ext(studyAreaLarge), res = c(250, 250))\n    terra::crs(rtml) &lt;- terra::crs(studyAreaLarge)\n    rtml[] &lt;- 1\n    rtml &lt;- terra::mask(rtml, studyAreaLarge)\n  },\n  rasterToMatch = {\n    rtm &lt;- terra::crop(rasterToMatchLarge, studyArea)\n    rtm &lt;- terra::mask(rtm, studyArea)\n  }\n)\n\n\n#this must be done outside of setupProject (temporarily)\n#alternatively\noutSim &lt;- do.call(SpaDES.core::simInitAndSpades, out) |&gt;\n  Cache()\n\ncompleted(outSim)\nelapsedTime(outSim, units = \"minute\")\n\nmm &lt;- moduleMetadata(outSim)\n\n# a list of all the module metadata\nmm$Biomass_borealDataPrep$\n\nout$params$.globals$.plots &lt;- \"png\"\noutSim &lt;- simInitAndSpades2(out)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Forest Succession and Wildfire using `setupProject`</span>"
    ]
  },
  {
    "objectID": "castorExample.html",
    "href": "castorExample.html",
    "title": "16  Castor Workflow with setupProject",
    "section": "",
    "text": "16.1 Workflow setup\nCurrently, SpaDES.project functions expect SpaDES modules to either exist locally, or at root level of separate repositories. This is not the case with Castor modules, which are in a nested folder (i.e. a folder in a folder tree) of a single GitHub repository.\nSpaDES.project will eventually be able to deal with this1, but for now we work around this issue by using a beta version from the nestedGHmodules branch.\nCode\n# install/load necessary packages\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\ninstall.packages(c(\"SpaDES.project\", \"Require\"), repos = repos, dependencies = TRUE)\n\nlibrary(SpaDES.project)\nsetupProject does all the heavy-lifting of setting up the workflow, creating all the necessary folders, namely installing all package dependencies listed in the several modules and in setupProject(..., packages), sourcing additional files and creating parameter, inputs and outputs lists – see ?setupProject.\nNote that all folder/file paths are relative to projectPath. Note also how setupProject is getting extra functions and the parameters list from online .R scripts that it downloads to the project folder and sources2.\nCode\n# set up the workflow paths, dependencies and modules\n# as well as simulation parameters, (some) inputs and outputs\nout &lt;- setupProject(\n  paths = list(\"inputPath\" = \"modules/forestryCastor/inputs\",\n               \"outputPath\" = \"R/scenarios/comparison_stsm/outputs\",\n               \"modulePath\" = \"modules/\",\n               \"cachePath\" = \"modules/forestryCastor\",\n               \"projectPath\" = \"~/SpaDES_book/castorExample\"),\n  modules = file.path(\"bcgov/castor@main/R/SpaDES-modules\", \n                              c(\"dataCastor\",\n                                \"growingStockCastor\",\n                                \"blockingCastor\",\n                                \"forestryCastor\",\n                                \"roadCastor\")),\n  options = list(repos = repos),\n  functions = \"bcgov/castor@main/R/functions/R_Postgres.R\",\n  # install and load\n  require = \"dplyr\",\n  # install but don't load these:\n  packages = c(\n    \"DBI\", \n    \"DiagrammeR\",\n    \"keyring\",\n    \"rgdal\", \n    \"RPostgreSQL\", \n    \"sp\",\n    \"terra\"\n  ),\n  params = \"PredictiveEcology/PredictiveEcology.org@main/tutos/castorExample/params.R\",  \n  times = list(start = 0, end = 20),\n  outputs = {\n    data.frame(objectName = c(\"harvestReport\",\n                              \"growingStockReport\"))\n  },\n  scenario = {\n    data.table(name = \"stsm_base_case\",\n               description = paste(\"Priority queue = oldest first. Adjacency constraint\",\n                                   \"= None. Includes roads (mst) and blocks (pre).\",\n                                   \"Harvest flow = 147,300 m3/year in decade 1, 133,500\",\n                                   \"m3/year in decade 2, 132,300 m3/year in decades 3 to\",\n                                   \"14 and 135,400 m3/year in decades 15 to 25.\",\n                                   \"Minimum harvest age = 80 and minimum harvest volume = 150\"))\n  },\n  harvestFlow = {\n    rbindlist(list(data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 1,\n                                                 to = 1, \n                                                 by = 1),\n                                            1), \n                              flow = 1473000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 2,\n                                                 to = 2, \n                                                 by = 1),\n                                            1), \n                              flow = 1335000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 3,\n                                                 to = 14, \n                                                 by = 1),\n                                            1), \n                              flow = 1323000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 15,\n                                                 to = 25, \n                                                 by = 1),\n                                            1), \n                              flow = 1354000, \n                              partition_type = 'live')  \n    ))\n  },\n  # overwrite = TRUE,  ## activate if you want to keep modules up-to-date the with online repository\n  Restart = TRUE\n)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Castor Workflow with `setupProject`</span>"
    ]
  },
  {
    "objectID": "castorExample.html#sec-castorSetup",
    "href": "castorExample.html#sec-castorSetup",
    "title": "16  Castor Workflow with setupProject",
    "section": "",
    "text": "Using setupProject(..., Restart = TRUE)\n\n\n\nWhen creating a project for the first time, setupProject() will not only create the project folder structure, but also create an RStudio project file (.Rproj) and copy the current script (if it has been saved) into the project root directory.\nSetting Restart = TRUE will open a new RStudio window from “inside” the project being defined (i.e., the RStudio Project will be opened and all paths will be relative to the project root directory) and open the active script.\nThis means that all code before the setupProject() call and the setupProject() call will need to be re-run again on the new RStudio/R sessions.\nNone of this happens if the RStudio project file is already active (open).",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Castor Workflow with `setupProject`</span>"
    ]
  },
  {
    "objectID": "castorExample.html#initialise-the-model-and-inspect-simlist",
    "href": "castorExample.html#initialise-the-model-and-inspect-simlist",
    "title": "16  Castor Workflow with setupProject",
    "section": "16.2 Initialise the model and inspect simList",
    "text": "16.2 Initialise the model and inspect simList\nsetupProject() returns a names list containing values that can be passed as argument to simInit()3.\nWe use do.call() to pass the whole list of arguments to simInit.\n\n\nCode\n# initialize simulation\ncastorInit &lt;- do.call(SpaDES.core::simInit, out)\n\n\nAnother (more verbose) option would to call simInit directly:\n\n\nCode\ncastorInit &lt;- SpaDES.core::simInit(\n  times = out$times,\n  params = out$params, \n  modules = out$modules, \n  objects = list(scenario = out$scenario, \n                 harvestFlow = out$harvestFlow)\n)\n\n\nUse the following functions to access workflow/model properties. events(), for instance will output the scheduled events, which at this point are only the init events of each module as you can see in the output below.\n\n\nCode\n# inspect the `simList`\nSpaDES.core::params(castorInit) \nSpaDES.core::inputs(castorInit)\nSpaDES.core::outputs(castorInit)\nSpaDES.core::times(castorInit) \n\n# scheduled events\nSpaDES.core::events(castorInit) \n\n\n\n\n   eventTime         moduleName eventType eventPriority\n       &lt;num&gt;             &lt;char&gt;    &lt;char&gt;         &lt;num&gt;\n1:         0         checkpoint      init             0\n2:         0               save      init             0\n3:         0           progress      init             0\n4:         0               load      init             0\n5:         0         dataCastor      init             1\n6:         0 growingStockCastor      init             1\n7:         0     forestryCastor      init             1\n8:         0     blockingCastor      init             1",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Castor Workflow with `setupProject`</span>"
    ]
  },
  {
    "objectID": "castorExample.html#visualize-the-workflow",
    "href": "castorExample.html#visualize-the-workflow",
    "title": "16  Castor Workflow with setupProject",
    "section": "16.3 Visualize the workflow",
    "text": "16.3 Visualize the workflow\nmoduleDiagram() and objectDiagram() are great to visualise how each module interacts with the other. Recall that these interactions arise from object “exchanges” between modules, which are deduced by simInit() from module metadata (Figure 16.2) – i.e., if a module’s inputs are another’s outputs, then the first module will follow the second.\n\n\nCode\nSpaDES.core::moduleDiagram(castorInit)\nSpaDES.core::objectDiagram(castorInit)\n\n\n\n\n\n\n\n\n\n\nFigure 16.1: Diagram of module connections.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16.2: Diagram of module inter-dependencies with object names.",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Castor Workflow with `setupProject`</span>"
    ]
  },
  {
    "objectID": "castorExample.html#run-simulation",
    "href": "castorExample.html#run-simulation",
    "title": "16  Castor Workflow with setupProject",
    "section": "16.4 Run simulation",
    "text": "16.4 Run simulation\nspades() runs the simulation, beginning with the execution of the init events. Notice how the result of outputs() differs from previously.\n\n\nCode\ncastorSim &lt;- SpaDES.core::spades(castorInit)\n\n# we now have outputs\nSpaDES.core::outputs(castorSim)\n\n\n\n\n          objectName\n1      harvestReport\n2 growingStockReport\n                                                                                                              file\n1      C:/Users/cbarros/Documents/tutos/castorExample/R/scenarios/comparison_stsm/outputs/harvestReport_year20.rds\n2 C:/Users/cbarros/Documents/tutos/castorExample/R/scenarios/comparison_stsm/outputs/growingStockReport_year20.rds\n      fun package saveTime saved arguments\n1 saveRDS    base       20  TRUE        NA\n2 saveRDS    base       20  TRUE        NA\n\n\ncompleted(castorSim) shows the chaining of events that was produced and run by spades(). The sequence of steps in the workflow therefore arises from each module’s events and their scheduling, rather than being explicitly imposed by the user.\n\n\nCode\nSpaDES.core::completed(castorSim)\n\n\n    eventTime         moduleName          eventType eventPriority\n        &lt;num&gt;             &lt;char&gt;             &lt;char&gt;         &lt;num&gt;\n 1:         0         checkpoint               init             0\n 2:         0               save               init             0\n 3:         0           progress               init             0\n 4:         0               load               init             0\n 5:         0         dataCastor               init             1\n 6:         0 growingStockCastor               init             1\n 7:         0     forestryCastor               init             1\n 8:         0     blockingCastor               init             1\n....\n\n\nWe suggest omitting the blockingCastor module in setupProject() and rerunning the workflow again to see how spades is capable of re-generating a new workflow with little effort from the user.\n\n\nCode\nmodules &lt;- c(\"dataCastor\", \n             \"growingStockCastor\", \n             \"forestryCastor\")\n\nout &lt;- setupProject(\n  paths = list(\"inputPath\" = \"modules/forestryCastor/inputs\",\n               \"outputPath\" = \"/R/scenarios/comparison_stsm/outputs\",\n               \"modulePath\" = \"modules/\",\n               \"cachePath\" = \"modules/forestryCastor\",\n               \"projectPath\" = \"~/SpaDES_book/castorExample/\"),\n  modules = modules,\n  functions = \"bcgov/castor@main/R/functions/R_Postgres.R\",\n  # install and load\n  require = \"dplyr\",\n  # install but don't load these:\n  packages = c(\n    \"DBI\", \n    \"keyring\",\n    \"rgdal\", \n    \"RPostgreSQL\", \n    \"sp\",\n    \"terra\"\n  ),\n  params = \"params.R\",\n  times = list(start = 0, end = 20),\n  outputs = {\n    data.frame(objectName = c(\"harvestReport\",\n                              \"growingStockReport\"))\n  },\n  scenario = {\n    data.table(name = \"stsm_base_case\",\n               description = paste(\"Priority queue = oldest first. Adjacency constraint\",\n                                   \"= None. Includes roads (mst) and blocks (pre).\",\n                                   \"Harvest flow = 147,300 m3/year in decade 1, 133,500\",\n                                   \"m3/year in decade 2, 132,300 m3/year in decades 3 to\",\n                                   \"14 and 135,400 m3/year in decades 15 to 25.\",\n                                   \"Minimum harvest age = 80 and minimum harvest volume = 150\"))\n  },\n  harvestFlow = {\n    rbindlist(list(data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 1,\n                                                 to = 1, \n                                                 by = 1),\n                                            1), \n                              flow = 1473000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 2,\n                                                 to = 2, \n                                                 by = 1),\n                                            1), \n                              flow = 1335000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 3,\n                                                 to = 14, \n                                                 by = 1),\n                                            1), \n                              flow = 1323000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 15,\n                                                 to = 25, \n                                                 by = 1),\n                                            1), \n                              flow = 1354000, \n                              partition_type = 'live')  \n    ))\n  },\n  Restart = TRUE\n)\n\n# initialize and run simulation in one go\ncastorSim2 &lt;- do.call(SpaDES.core::simInitAndSpades, out)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Castor Workflow with `setupProject`</span>"
    ]
  },
  {
    "objectID": "castorExample.html#barebones-r-script",
    "href": "castorExample.html#barebones-r-script",
    "title": "16  Castor Workflow with setupProject",
    "section": "16.5 Barebones R script",
    "text": "16.5 Barebones R script\n\n\nCode\n# install/load necessary packages\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\ninstall.packages(c(\"SpaDES.project\", \"Require\"), repos = repos, dependencies = TRUE)\n\nlibrary(SpaDES.project)\n\n# set up the workflow paths, dependencies and modules\n# as well as simulation parameters, (some) inputs and outputs\nout &lt;- setupProject(\n  paths = list(\"inputPath\" = \"modules/forestryCastor/inputs\",\n               \"outputPath\" = \"R/scenarios/comparison_stsm/outputs\",\n               \"modulePath\" = \"modules/\",\n               \"cachePath\" = \"modules/forestryCastor\",\n               \"projectPath\" = \"~/SpaDES_book/castorExample\"),\n  modules = file.path(\"bcgov/castor@main/R/SpaDES-modules\", \n                              c(\"dataCastor\",\n                                \"growingStockCastor\",\n                                \"blockingCastor\",\n                                \"forestryCastor\",\n                                \"roadCastor\")),\n  options = list(repos = repos),\n  functions = \"bcgov/castor@main/R/functions/R_Postgres.R\",\n  # install and load\n  require = \"dplyr\",\n  # install but don't load these:\n  packages = c(\n    \"DBI\", \n    \"DiagrammeR\",\n    \"keyring\",\n    \"rgdal\", \n    \"RPostgreSQL\", \n    \"sp\",\n    \"terra\"\n  ),\n  params = \"PredictiveEcology/PredictiveEcology.org@main/tutos/castorExample/params.R\",  \n  times = list(start = 0, end = 20),\n  outputs = {\n    data.frame(objectName = c(\"harvestReport\",\n                              \"growingStockReport\"))\n  },\n  scenario = {\n    data.table(name = \"stsm_base_case\",\n               description = paste(\"Priority queue = oldest first. Adjacency constraint\",\n                                   \"= None. Includes roads (mst) and blocks (pre).\",\n                                   \"Harvest flow = 147,300 m3/year in decade 1, 133,500\",\n                                   \"m3/year in decade 2, 132,300 m3/year in decades 3 to\",\n                                   \"14 and 135,400 m3/year in decades 15 to 25.\",\n                                   \"Minimum harvest age = 80 and minimum harvest volume = 150\"))\n  },\n  harvestFlow = {\n    rbindlist(list(data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 1,\n                                                 to = 1, \n                                                 by = 1),\n                                            1), \n                              flow = 1473000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 2,\n                                                 to = 2, \n                                                 by = 1),\n                                            1), \n                              flow = 1335000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 3,\n                                                 to = 14, \n                                                 by = 1),\n                                            1), \n                              flow = 1323000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 15,\n                                                 to = 25, \n                                                 by = 1),\n                                            1), \n                              flow = 1354000, \n                              partition_type = 'live')  \n    ))\n  },\n  # overwrite = TRUE,  ## activate if you want to keep modules up-to-date the with online repository\n  Restart = TRUE\n)\n\n# initialize simulation\ncastorInit &lt;- do.call(SpaDES.core::simInit, out)\n\ncastorInit &lt;- SpaDES.core::simInit(\n  times = out$times,\n  params = out$params,\n  modules = out$modules,\n  objects = list(scenario = out$scenario,\n                 harvestFlow = out$harvestFlow)\n)\n\n# inspect the `simList`\nSpaDES.core::params(castorInit)\nSpaDES.core::inputs(castorInit)\nSpaDES.core::outputs(castorInit)\nSpaDES.core::times(castorInit)\n\n# scheduled events\nSpaDES.core::events(castorInit)\n\n\n\nSpaDES.core::moduleDiagram(castorInit)\nSpaDES.core::objectDiagram(castorInit)\n\n\n\n\n\ncastorSim &lt;- SpaDES.core::spades(castorInit)\n\n# we now have outputs\nSpaDES.core::outputs(castorSim)\n\n\n\n\n\nSpaDES.core::completed(castorSim)\n\nmodules &lt;- c(\"dataCastor\",\n             \"growingStockCastor\",\n             \"forestryCastor\")\n\nout &lt;- setupProject(\n  paths = list(\"inputPath\" = \"modules/forestryCastor/inputs\",\n               \"outputPath\" = \"/R/scenarios/comparison_stsm/outputs\",\n               \"modulePath\" = \"modules/\",\n               \"cachePath\" = \"modules/forestryCastor\",\n               \"projectPath\" = \"~/SpaDES_book/castorExample/\"),\n  modules = modules,\n  functions = \"bcgov/castor@main/R/functions/R_Postgres.R\",\n  # install and load\n  require = \"dplyr\",\n  # install but don't load these:\n  packages = c(\n    \"DBI\",\n    \"keyring\",\n    \"rgdal\",\n    \"RPostgreSQL\",\n    \"sp\",\n    \"terra\"\n  ),\n  params = \"params.R\",\n  times = list(start = 0, end = 20),\n  outputs = {\n    data.frame(objectName = c(\"harvestReport\",\n                              \"growingStockReport\"))\n  },\n  scenario = {\n    data.table(name = \"stsm_base_case\",\n               description = paste(\"Priority queue = oldest first. Adjacency constraint\",\n                                   \"= None. Includes roads (mst) and blocks (pre).\",\n                                   \"Harvest flow = 147,300 m3/year in decade 1, 133,500\",\n                                   \"m3/year in decade 2, 132,300 m3/year in decades 3 to\",\n                                   \"14 and 135,400 m3/year in decades 15 to 25.\",\n                                   \"Minimum harvest age = 80 and minimum harvest volume = 150\"))\n  },\n  harvestFlow = {\n    rbindlist(list(data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ',\n                              period = rep( seq (from = 1,\n                                                 to = 1,\n                                                 by = 1),\n                                            1),\n                              flow = 1473000,\n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ',\n                              period = rep( seq (from = 2,\n                                                 to = 2,\n                                                 by = 1),\n                                            1),\n                              flow = 1335000,\n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ',\n                              period = rep( seq (from = 3,\n                                                 to = 14,\n                                                 by = 1),\n                                            1),\n                              flow = 1323000,\n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ',\n                              period = rep( seq (from = 15,\n                                                 to = 25,\n                                                 by = 1),\n                                            1),\n                              flow = 1354000,\n                              partition_type = 'live')\n    ))\n  },\n  Restart = TRUE\n)\n\n# initialize and run simulation in one go\ncastorSim2 &lt;- do.call(SpaDES.core::simInitAndSpades, out)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Castor Workflow with `setupProject`</span>"
    ]
  },
  {
    "objectID": "castorExample.html#footnotes",
    "href": "castorExample.html#footnotes",
    "title": "16  Castor Workflow with setupProject",
    "section": "",
    "text": "SpaDES.project is currently being adapted to deal with modules nested in folders of GitHub repositories (instead of living in their own GitHub repositories). Hence, the code in this example is subject to changes in the near future.↩︎\nNote that these files are placed in folders that respect the folder structure of where they come from (if they are not in the repository root folder). For instance, in the example the params.R is placed in &lt;projectPath&gt;/tutos/castorExample/params.R .↩︎\nSee also Chapter 7.↩︎",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Castor Workflow with `setupProject`</span>"
    ]
  },
  {
    "objectID": "bestPractices.html",
    "href": "bestPractices.html",
    "title": "Best practices",
    "section": "",
    "text": "General best practices for \\(R^3T\\) workflows",
    "crumbs": [
      "Best practices"
    ]
  },
  {
    "objectID": "bestPractices.html#general-best-practices-for-r3t-workflows",
    "href": "bestPractices.html#general-best-practices-for-r3t-workflows",
    "title": "Best practices",
    "section": "",
    "text": "Script, script, script – this means script everything you do, including package installation.\n“DOComment” your code – use comments that describe the intention of the code, not necessarily a code translation into human language.\n\n\n\n\n\n\nNot a very useful comment (we can check ?lm to know what it does):\n\n\nCode\n# lm fits a linear model\nlm(biomass ~ height)\n\n\nA more useful comment:\n\n\nCode\n# model linear relationship between biomass and height\nlm(biomass ~ height)\n\n\n\n\n\nMinimize the number of software/languages used – the more jumps between languages/software the less robust and reproducible the workflow is. Remember: other users will need to install the same software and be able to the same jumps/operations that you did without you looking over their shoulder.\nModularise and “functionise” – avoid loooooong scripts, which are harder to read, learn and debug. Instead bundle your code into modules and functions.\n\nSpaDES helps the modularisation part a great deal but it is still up to the developer to create functions and to decide what workflow components can/should be broken into separate modules or events.\nWhen using embedded module and event caching, think about what workflow steps can be cached to speed up development and re-runs and consider turning these into separate modules or events.\nConsider “packaging” your functions so they can be used across projects and SpaDES modules.\n\n\n\nFunctions and modules as key tools for $R^3T$, but also for building integrated and continuous workflows; McIntire et al. (2022)\n\n\n\nCentralize workflow in a single script – this is quite intuitive when using SpaDES, as usually there is a “controller” script that sets up and runs the workflow.\nUse project-oriented and self-contained workflows – pick a structure that is self-explanatory and make sure that the project can be “moved” between users/machines without changing the code.\nDon’t use absolute paths – use relative paths (relative to project directory) – RStudio Projects and SpaDES.project do this automatically.\n\nYou can even install your R packages into project-level libraries, to allow for different package versions between projects in the same machine\n\nVersion control – great for collaboration, great for tracking changes, great to recover old versions of a project/code\n\nWhen using version control software, it might be best not to use cloud-based storage and syncing (e.g. OneDrive, Google Drive, Dropbox) on the same files/folders, as it can conflict with and slow down the version control software.\n\nTest (!) – test your code and your workflow if you want them to endure and persist through time and users\n\nUse a combination of assertions, unit tests and integration tests1",
    "crumbs": [
      "Best practices"
    ]
  },
  {
    "objectID": "bestPractices.html#best-practices-for-spades-workflows",
    "href": "bestPractices.html#best-practices-for-spades-workflows",
    "title": "Best practices",
    "section": "Best practices for SpaDES workflows",
    "text": "Best practices for SpaDES workflows\n\nLimit the number of objects in .GlobalEnv – instead, put them in functions or inside a module. When objects are in modules, you can add default object values (e.g. via .inputObjects()), or save them into files that are loaded by setupProject or simInit. Alternatively, you can pass objects or code to make them directly to setupProject() as ... arguments, or to the simInit objects arguments. See 6  Providing Module Inputs and, for an example with setupProject, 14  Forest Landscape Modelling with LandR and setupProject.\n\nWhy? Because modules might then find/use objects in/from the .GlobalEnv when they shouldn’t (they should use them from the simList). SpaDES.project::setupProject and simInit deal with these issues by loading and objects directly into a separate environment (the simList).\n\nDon’t install packages “manually” and “separately” – script package installation in a reproducible way, i.e. that includes reference to package versions. Even better, let setupProject deal with package installation.\n\nWhy not? When you have many modules, each with a list of packages it needs it will be hard to figure out what packages need to be installed or updated. setupProject was designed to deal with this issue using the Require package.\n\nDon’t pre-load packages – let simInit do it when the simulation is being initialized and only after it has asserted that packages are available and in the correct versions.\n\nWhy not? There are many reasons why things can get messed up with modelling in R… e.g., package dependency issues (especially version numbers that collide during development stages), internet availability. Pre-loading a package prevents it from being updated, which can make setupProject (and simInit) fail if they attempt to update a package to respect module requirements.\n\nAvoid installing packages into a cloud-synced/managed folder – files in and folders managed by cloud-storage software like OneDrive, Google Drive and Dropbox, are constantly being screened by these software which can lead to conflicts during package installation (e.g., the software holds on to certain files and R is unable to delete and re-install them). If package installation is scripted, there is no need to sync it with a server – you can recover it at any time.\nAvoid pointing the cache to a cloud-synced/managed folder – for the same reasons as in the previous point.",
    "crumbs": [
      "Best practices"
    ]
  },
  {
    "objectID": "bestPractices.html#see-also",
    "href": "bestPractices.html#see-also",
    "title": "Best practices",
    "section": "See also",
    "text": "See also\nEFI’s reproducible forecasting workflows\nThe Practice of Reproducible Research\nAdvanced R - Style guide; by Hadley Wickham\nTypes of testing; by Codecov\nPaper by Sarma et al. (2016) on code testing\n\n\n\n\nSarma, Gopal P., Travis W. Jacobs, Mark D. Watts, S. Vahid Ghayoomie, Stephen D. Larson, and Richard C. Gerkin. 2016. “Unit Testing, Model Validation, and Biological Simulation.” F1000Research 5 (August): 1946. https://doi.org/10.12688/f1000research.9315.1.",
    "crumbs": [
      "Best practices"
    ]
  },
  {
    "objectID": "bestPractices.html#footnotes",
    "href": "bestPractices.html#footnotes",
    "title": "Best practices",
    "section": "",
    "text": "Assertions and unit tests are smaller and generally test specific operations within a workflow (e.g. if (1 + x != 2) stop(\"there is an error\")) or things like object integrity (e.g. if (!is(x, \"data.frame\") stop(\"there is an error\")). Integration tests are larger in the sense that they test many components of a workflow and whether they work well together (they can also test an entire workflow)↩︎",
    "crumbs": [
      "Best practices"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Barros, Ceres, Yong Luo, Alex M. Chubaty, Ian M. S. Eddy, Tatiane\nMicheletti, Céline Boisvenue, David W. Andison, Steven G. Cumming, and\nEliot J. B. McIntire. 2023. “Empowering Ecological Modellers with\na PERFICT Workflow: Seamlessly Linking Data, Parameterisation,\nPrediction, Validation and Visualisation.” Methods in Ecology\nand Evolution 14 (1): 173–88. https://doi.org/10.1111/2041-210X.14034.\n\n\nJanssen, Marco A., Calvin Pritchard, and Allen Lee. 2020. “On Code\nSharing and Model Documentation of Published Individual and Agent-Based\nModels.” Environmental Modelling & Software 134\n(December): 104873. https://doi.org/10.1016/j.envsoft.2020.104873.\n\n\nMcIntire, Eliot J. B., Alex Chubaty, Steve Cumming, David Andison, Ceres\nBarros, Céline Boisvenue, Samuel Hache, Yong Luo, Tatiane Micheletti,\nand Frances Stewart. 2022. “PERFICT: A Re-Imagined Foundation for\nPredictive Ecology.” Ecology Letters. https://doi.org/10.22541/au.163252535.52485317/v1.\n\n\nReynolds, James F., and Basil Acock. 1997. “Modularity and\nGenericness in Plant and Ecosystem Models.” Ecological\nModelling 94 (1): 7–16. https://doi.org/10.1016/S0304-3800(96)01924-2.\n\n\nSarma, Gopal P., Travis W. Jacobs, Mark D. Watts, S. Vahid Ghayoomie,\nStephen D. Larson, and Richard C. Gerkin. 2016. “Unit Testing,\nModel Validation, and Biological Simulation.”\nF1000Research 5 (August): 1946. https://doi.org/10.12688/f1000research.9315.1.\n\n\nScheller, Robert M., and Brian R. Miranda. 2015. LANDIS-II Biomass\nSuccession V3.2 Extension  User Guide.\n\n\nSharma, Nitesh Kumar, Ram Ayyala, Dhrithi Deshpande, Yesha M Patel,\nViorel Munteanu, Dumitru Ciorba, Andrada Fiscutean, et al. 2023.\n“Analytical Code Sharing Practices in Biomedical Research.”\nbioRxiv, August, 2023.07.31.551384. https://doi.org/10.1101/2023.07.31.551384.",
    "crumbs": [
      "References"
    ]
  }
]