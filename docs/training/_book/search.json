[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Robust and nimble scientific workflows, using SpaDES",
    "section": "",
    "text": "Preface\nThis book is a work in progress. Please visit this again as chapters are being added and modified.\nThe approaches presented here use the SpaDES family of packages and associated packages, like reproducible and Require, that we have developed to face a variety of issues that we experienced during our own journeys as modellers and, more generally, scientists.\nMany of these issues we faced because most of us were ecologists by training (not computer scientists, not engineers, etc.), who lacked a strong programming foundation. So, we expect many who have other backgrounds and maybe very strong programming skills to find this set of solutions foreign and perhaps unnecessary, limited, or over-complicated for many applications outside the realm of ecological sciences. We certainly don’t expect NASA scientists to overhaul their own workflows and follow ours – but feel free too and send us your feedback!\nThis book is therefore focused on the many ways that models and data, including the data generated through models, can be used for decision making, reproducibility of publications, and reused across different applications and modelling contexts, etc. By working towards a set of standards for our data and modeling workflows, our science can become more nimble. We can thus pivot and update as issues come up.\nWe hope that many ecologists and those in related sciences (e.g. forestry, wildlife management, etc.), academics or practitioners, can appreciate the value of aligning their work with the R3T1, PERFICT2 and nimbleness principles and find these solutions useful. Mostly we hope that those that work with ecosystems can embrace these tools to work towards expanding the abilities of the community to become robust to any scrutiny we face.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Robust and nimble scientific workflows, using SpaDES",
    "section": "",
    "text": "Repeatability, Reproducibility, Reusability and Transparency↩︎\nPredict regularly from models that are Evaluated, Reusable, Freely accessible, and Interoperable, and that are part of Continuous workflows that are Tested regularly↩︎",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Why SpaDES?\nSpaDES is a set of R packages that facilitate implementing nimble workflows that follow in the principles of repeatability, reproducibility, reusability and transparency (R3T), via the creation and use of highly modular code that has metadata attached.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#why-spades",
    "href": "intro.html#why-spades",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1.1 Modularity\nModular code for ecological analyses has been long proposed (Reynolds and Acock 1997). Modularity means that scripts can be broken up into themes that bundled into meaningful chunks that can be easily moved, swapped, replaced or scrapped easily. A nice example of this is Barros et al. (2023) where a module was included or removed to identify the value of “adding more complexity”. One simple conclusion followed Occam’s Razor: simpler data and models predicted simpler characteristics of the forest more accurately than the complex data and models. In other words, adding complexity to a model made the model perform worse for some characteristics.\n\n\n1.1.2 Metadata\nMetadata in a SpaDES context includes identifying what objects  are expected by a chunk of code and what objects are created by a chunk of code: the inputs and outputs. This forces a user to understand their code and its linkages, and it allows R to know how to connect this chunk of code with others. Importantly, it allows SpaDES to chain modules such that the workflow structure can be defined from the bottom-up, rather than top-down.\n\n\n1.1.3 Nimbleness\nTogether SpaDES’s modularity, standardized structure and metatada, improve workflow nimbleness, where we can weave together new Results that use new data, updated data, a new module, a new study area, a new visualization, address new stakeholder’s needs and more.\n\n1.1.3.1 Aren’t packages and functions sufficient?\nScientists have embraced the idea of modular code by creating and using functions, often bundled into packages, e.g., R packages. This is analogous to the Methods section of a journal paper: i.e., the methods (functions) describe how you will do something. The use of packages in this way has massively accelerated Ecology and other data sciences.\nHowever, even if you know all the functions that a paper used, this in itself is not sufficient to reproduce the Results. SpaDES modules can be thought of the recipe needed to make the Results. In other words, a SpaDES module enables a developer to bundle the functions in a specific order so that one can recreate the steps to make the Results. A user can then use the module directly, rather instead of trying to recreate the necessary sequence of functions.\n\n\n\nFunctions and modules as key tools to achieve workflow nimbleness. From McIntire et al. (2022).\n\n\n\n\n\n1.1.4 I use targets for my workflows. How does SpaDES differ?\nThere are two major differences between targets and the SpaDES approach:\n\ntargets is “top-down”, SpaDES is “bottom-up” – with targets, the workflow is entirely defined by the script developer (as in Make). This is, they define the connections and the sequence between each “target” (the code sections that call functions and execute operations), when they will be iterated and for “how many times”. Re-arranging “targets” sequences and iterations may therefore be hard, if the “target” code is not well known/understood.\nSpaDES is meant to enable mixing-and-matching different modules that share the same inputs/outputs easily – i.e. without having to have deep knowledge of the module code. SpaDES will read each module’s metadata and from it deduce the sequence in which modules need to be chained. SpaDES will also iterate module code when necessary, following the developer’s “scheduling” instructions. The workflow sequence, therefore, arises from the set of modules that is being used1.\nSpaDES has “embedded” metadata – or at least it makes the developer think about it2. Each module is defined by listing not only the inputs and outputs, but also their descriptions and types of object class, the module’s description, its operating time scale, package and module dependencies, and much more. Some of the metadata is essential to chain modules (lists of inputs and outputs), some is not but can greatly facilitate workflow setup (e.g. declaring module dependencies), while other metadata is simply good to have (e.g. a description of the module).\n\nFinally, both targets and SpaDES have embedded caching mechanisms, which in SpaDES can be controlled at several levels (by the user, inside the module code, etc.) – see Chapter 11 on SpaDES caching mechanisms.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#spades-applied-ecology",
    "href": "intro.html#spades-applied-ecology",
    "title": "1  Introduction",
    "section": "1.2 SpaDES & applied ecology",
    "text": "1.2 SpaDES & applied ecology\nSpaDES development was, and continues to be, strongly motivated by our attempts to answer important issues in applied ecology.\n\n\n\n\n\n\nThe three big problems in applied ecology\n\n\n\nApplied ecology – the application of ecological science to questions related to the effects of human activities on ecosystems – is challenged and motivated by three main problems:\n\nmany species are declining or uncontrollably increasing\nmany ecological processes (like fire, food web dynamics, productivity) are changing\nconservation and management problems require trans-disciplinary solutions\n\n\n\nAlongside these problems, ecologists must grapple with new expectations for how they do their work to inform these problems.\n\n1.2.1 New expectations\nApplied ecologists of the 21st century are expected more and more to uphold standards of nimbleness, broad participation and scrutiny.\nAnalyses must be able to respond quickly to new data, new insights, new drivers, and new management needs; projects must include knowledge and participation from outside the scientific community and be relevant to non-scientific audiences; and they must accept and embrace scientific and non-scientific scrutiny.\nThese expectations are not independent of each other. Greater nimbleness allows for easier participation by others and scrutiny benefits from the participation of a broad range of specialists and non-specialists.\nMeeting these expectations requires the R3T:\n\nrepeatability – analyses must be able to produce the same results, when using the exact same context (e.g. same user, same machine setup);\nreproducibility – analyses must be able to produce the same results by others and into the future;\nreusability – the methodology must be easy to transfer and expand in a different context;\ntransparency – analyses must be able to be inspected, understood, and scrutinized by many eyes;\n\nbut also\n\nforecasting – analyses must demonstrate that they are proving reliable insights into the future, not just the past or theoretical expectation;\nvalidation – analyses must clearly demonstrate why they should be trusted and used;\nopen-data/open-models – raw data, parameters, model algorithms have to be (freely) accessible as much as possible;\ntesting – models and predictions should be continuously tested.\n\nTogether these 10 requirements (and a little more) are encompassed by the PERFICT principles for applied ecological modelling (McIntire et al. 2022).\n\n\n\n\n\n\nPERFICT\n\n\n\n\nPredict regularly from models that are\nEvaluated,\nReusable,\nFreely accessible, and\nInteroperable, and that are part of\nContinuous workflows that are\nTested regularly\n\n\n\nIt can be very challenging to fulfill these expectations, especially for non-programmers.\nSpaDES aims to help (applied) ecologists “get there” by relieving ecologists from needing to know/learn advanced computer programming (e.g. developing caching mechanisms) and offering tools that will enable them to develop PERFICT workflows.\n\n\n\n\n\nIt does so by harnessing the flexibility of R, the contributions of its vast community and knowing what tools applied ecologists (and modellers) often need.\n\n\n\n\n\n\nTip 1.1: reproducible::prepInputs a tool that will make your life easier\n\n\n\nApplied ecologists often need to get a raw spatial layer from somewhere (locally, a data repository), make it conform to a given study area and even change it to a given spatial projection or resolution.\nThey also often need to do this for many layers.\nreproducible::prepInputs facilitates this process in a single function call by having the ability to:\n\ndownload from a data repository URL;\nspatially process the data according to a polygon or raster template\n\nIt also caches these operations, so taht they don’t need to be repeated unnecessarily.\nThis can save hours of learning to master caching and GIS algorithms (or avoid using flawed approaches) for many ecologists!\n\n\nThe SpaDES set of R packages is full of tools like prepInputs (Tip 1.1).\nThis book is intended to show applied ecologists (and whoever else!) the approaches that we use to bring our work closer to the PERFICT principles, better meet the expectations, and better address the problems.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#our-challenge",
    "href": "intro.html#our-challenge",
    "title": "1  Introduction",
    "section": "1.3 Our challenge",
    "text": "1.3 Our challenge\nWith the limited training provided in this book, applied ecologists can work towards creating PERFICT workflows. Embracing the transparency and nimbleness it provides, we can pivot more rapidly to the current management needs. When we are asked at the end of a 3-year project, “can we redo everything because we have a new stakeholder who feels that our assumptions are wrong?”, our answer should be “yes”.\n\n\n\n\nBarros, Ceres, Yong Luo, Alex M. Chubaty, Ian M. S. Eddy, Tatiane Micheletti, Céline Boisvenue, David W. Andison, Steven G. Cumming, and E. J. B. McIntire. 2023. “Empowering Ecological Modellers with a PERFICT Workflow: Seamlessly Linking Data, Parameterisation, Prediction, Validation and Visualisation.” Methods in Ecology and Evolution 14 (1): 173–88. https://doi.org/https://doi.org/10.1111/2041-210X.14034.\n\n\nMcIntire, Eliot J. B., Alex M. Chubaty, Steven G. Cumming, Dave Andison, Ceres Barros, Céline Boisvenue, Samuel Haché, Yong Luo, Tatiane Micheletti, and Frances E. C. Stewart. 2022. “PERFICT: A Re-Imagined Foundation for Predictive Ecology.” Ecology Letters 25 (6): 1345–51. https://doi.org/10.1111/ele.13994.\n\n\nReynolds, James F., and Basil Acock. 1997. “Modularity and Genericness in Plant and Ecosystem Models.” Ecological Modelling 94 (1): 7–16. https://doi.org/10.1016/S0304-3800(96)01924-2.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "1  Introduction",
    "section": "",
    "text": "Note that SpaDES still allows a user to impose module sequencing if they wish to.↩︎\nSpaDES won’t force most metadata to be filled, so it’s at the discretion of the module developer how much detail they want to provide.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "settingUp.html",
    "href": "settingUp.html",
    "title": "Setting up your computer and system",
    "section": "",
    "text": "This brief section shows how to set up R, RStudio, SpaDES, and pre-install R packages necessary to run all chapter code, if you need to do so.",
    "crumbs": [
      "Setting up your computer and system"
    ]
  },
  {
    "objectID": "installRandSpatialPkgs.html",
    "href": "installRandSpatialPkgs.html",
    "title": "2  Installing R and Spatial Packages",
    "section": "",
    "text": "2.1 Install R",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Installing R and Spatial Packages</span>"
    ]
  },
  {
    "objectID": "installRandSpatialPkgs.html#install-r",
    "href": "installRandSpatialPkgs.html#install-r",
    "title": "2  Installing R and Spatial Packages",
    "section": "",
    "text": "2.1.1 Windows\n\nDownload and run the R installer (as administrator!).\nDownload and install the Rtools version that matches the installed R version. Be sure to check the “add Rtools to PATH” option during installation if necessary (Rtools v4.0).\n\n\n\n2.1.2 macOS\n\nDownload and run the R installer from https://cran.r-project.org/bin/macosx.\nInstall Xcode commandline tools from the terminal:\n\nxcode-select --install\n\nInstall homebrew from the terminal (instructions at https://brew.sh/)\nInstall GDAL and other spatial packages (instructions at https://www.alexchubaty.com/post/2020-01-08-using-latest-gdal-macos-redux/)\nInstall OpenMP support for data.table:\n\nbrew update && brew install llvm\n\nInstall GLPK (needed for full igraph functionality; used with SpaDES.core::moduleGraph):\n\nbrew install glpk\nThen, in R, install igraph from source so it is compiled with GLPK:\ninstall.packages(\"igraph\", type = \"source\")\n\n\n2.1.3 Linux\nInstall via apt or yum depending on your distribution. Instructions for Ubuntu 18.04 LTS are shown below.\n\nInstall R and its development libraries:\n\nsudo apt install r-base r-base-dev\n\nInstall java and configure R to use it:\n\nsudo apt build-dep -y r-cran-rjava\nsudo R CMD javareconf\n\nInstall dependencies for spatial and other packages:\n\nsudo apt build-dep -y r-cran-tkrplot\n\nsudo apt-get install -y \\\nccache \\\ngdal-bin \\\ngit \\\nlibcairo2-dev \\\nlibcurl4-gnutls-dev \\\nlibgdal-dev \\\nlibgeos-dev \\\nlibgit2-dev \\\nlibgmp-dev \\\nlibjq-dev \\\nlibmagick++-dev \\\nlibproj-dev \\\nlibprotobuf-dev \\\nlibprotoc-dev \\\nlibssh2-1-dev \\\nlibssl-dev \\\nlibudunits2-dev \\\nlibv8-dev \\\nlibxml2-dev \\\nlibxt-dev \\\npandoc \\\npandoc-citeproc \\\nprotobuf-compiler \\\npython-gdal \\\npython3-gdal \\\ncurl \\\nr-cran-littler",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Installing R and Spatial Packages</span>"
    ]
  },
  {
    "objectID": "installRandSpatialPkgs.html#troubleshooting",
    "href": "installRandSpatialPkgs.html#troubleshooting",
    "title": "2  Installing R and Spatial Packages",
    "section": "2.2 Troubleshooting",
    "text": "2.2 Troubleshooting\nFor Mac users, it may be helpful to use brew doctor:\nbrew doctor\nIf you are still not able with the above instructions, you may be able to follow these more in-depth instructions.",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Installing R and Spatial Packages</span>"
    ]
  },
  {
    "objectID": "installRandSpatialPkgs.html#see-also",
    "href": "installRandSpatialPkgs.html#see-also",
    "title": "2  Installing R and Spatial Packages",
    "section": "2.3 See also",
    "text": "2.3 See also\nHands on programming with R",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Installing R and Spatial Packages</span>"
    ]
  },
  {
    "objectID": "PackagesForBook.html",
    "href": "PackagesForBook.html",
    "title": "3  Pre-installing R packages for book",
    "section": "",
    "text": "3.1 Installation code\nIf you can run the following code, then you will be able to run code in any of the chapters in this book. This code begins by installing SpaDES.project and its dependencies, then uses setupProject to download and install a list of R packages hosted on GitHub and a single SpaDES module (Biomass-core) which has over 130 package dependencies.\nCode\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\ninstall.packages(c(\"Require\", \"SpaDES.project\"), repos = repos)\n\nlibrary(SpaDES.project)\n\nout &lt;- setupProject(\n  packages = \"PredictiveEcology/PredictiveEcology.org@training-book/training/R/pkgList.R\",\n  options = list(repos = repos),\n  name = \"Introduction\",\n  modules = \"PredictiveEcology/Biomass_core@main\"\n)\nNote that setupProject will change your working directory to ./Introduction. If that is not where you want to keep working, restart R and make sure you set your working directory to where you want it to be (if restarting is not sufficient).",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Pre-installing R packages for book</span>"
    ]
  },
  {
    "objectID": "PackagesForBook.html#code-explained",
    "href": "PackagesForBook.html#code-explained",
    "title": "3  Pre-installing R packages for book",
    "section": "3.2 Code explained",
    "text": "3.2 Code explained\nIf you care to know what the code is “doing”, read on.\nThe setupProject call above internally uses Require to download and install any missing packages. Although the packages themselves are installed in a folder inside ./Introduction/ (the project folder) (see .libPaths() after running the code), Require caches the downloaded package installation files in a user-accessible folder (so independent from any project).\nThis means that, should you, e.g., switch projects and attempt to reinstall the same or a subset of these packages, setupProject (via Require) would access the package cache and reinstall them in whatever new project folder library. This is much faster than downloading the packages again.\nThe same is true should you lose internet connection, since the downloads do not need to happen again.",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Pre-installing R packages for book</span>"
    ]
  },
  {
    "objectID": "PackagesForBook.html#see-also",
    "href": "PackagesForBook.html#see-also",
    "title": "3  Pre-installing R packages for book",
    "section": "3.3 See also",
    "text": "3.3 See also\nChapter 4 on R package installation troubleshooting",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Pre-installing R packages for book</span>"
    ]
  },
  {
    "objectID": "PackagesForBook.html#footnotes",
    "href": "PackagesForBook.html#footnotes",
    "title": "3  Pre-installing R packages for book",
    "section": "",
    "text": "See this introduction to R3T workflows.↩︎",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Pre-installing R packages for book</span>"
    ]
  },
  {
    "objectID": "TroubleshootingPackageInstallation.html",
    "href": "TroubleshootingPackageInstallation.html",
    "title": "4  Troubleshooting R package installation",
    "section": "",
    "text": "4.1 General diagnosing tools\nThe following help diagnose many of the issues mentioned below.",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Troubleshooting R package installation</span>"
    ]
  },
  {
    "objectID": "TroubleshootingPackageInstallation.html#general-diagnosing-tools",
    "href": "TroubleshootingPackageInstallation.html#general-diagnosing-tools",
    "title": "4  Troubleshooting R package installation",
    "section": "",
    "text": "loadedNamespaces() shows which packages are actually loaded\nsessionInfo() shows several other things as well, including package versions. Very useful when called after restarting R to see if there are any packages being pre-loaded\npackageVersion(\"&lt;packagename&gt;\") shows which version of the package your session currently has access to (already loaded or on disk in the library but not yet loaded). It might not necessarily correspond to the installed version.",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Troubleshooting R package installation</span>"
    ]
  },
  {
    "objectID": "TroubleshootingPackageInstallation.html#cant-install-a-package",
    "href": "TroubleshootingPackageInstallation.html#cant-install-a-package",
    "title": "4  Troubleshooting R package installation",
    "section": "4.2 Can’t install a package",
    "text": "4.2 Can’t install a package\n\n4.2.1 Package has already been loaded\nSome packages have files that cannot be deleted if they are being used in the current or another R session. This is primarily true for packages with compiled code. This will create several cascading problems, even after restarting the current R session.\n\n4.2.1.1 Potential solutions\n\nRestart R – The number one solution for many problems is to restart R. If using RStudio, the keyboard shortcut is commonly CTRL-SHIFT-F10.\nClose other R or RStudio sessions – If you have more than one session open, each one may have packages loaded. That means you can’t install (update), delete or uninstall a package that has already been loaded elsewhere.\nClose RStudio and install in a separate R session – By default, RStudio pre-loads packages before user input. This is convenient under some conditions, but is very difficult to deal with when it doesn’t work correctly – e.g. when these packages need to be updated. You may have to close RStudio, open a separate R session (without RStudio) and install the packages there.\nUpdate packages in user library – Package versions may collide between the user library and the project library. Try to update the packages in the user library. To determine where this is, you can try:\n\nuserLib &lt;- Sys.getenv(\"R_LIBS_USER\")\nthen update the packages there:\nupdate.packages(userLib, ask = FALSE)\n\nTurn off R diagnostics – Alternatively (or in complement) to the solution above, you can turn off R code diagnostics (temporarily or permanently), in your RStudio’s Global Options. This can greatly reduce the number of pre-loaded packages at the expense of losing some RStudio functionality. Via RStudio GUI:\n\n\nGo to Tools &gt; Global Options &gt; Code\nOpen the Diagnostics tab, and uncheck “Show diagnostics for R”\n\nRestart R after doing the above. Try the package installations again. If they fail again, see other solutions and try them.\n\n\n\nTurning of R diagnostics with RStudio – a potential solution to prevent RStudio from pre-loading several R packages.\n\n\nAlternatively, you can:\n\n\nCode\ninstall.packages(\"RStudio.prefs\")\nRStudio.prefs::use_RStudio_prefs(\n  show_diagnostics_r = FALSE\n)\n\n\n\n\n\n4.2.2 00LOCK folder issues\nOnce a package installation failure happened and interrupted the process, there may be a 00LOCK folder that R cannot remove, nor overwrite. R can’t install anything until that 00LOCK folder is removed.\n\n4.2.2.1 Potential solutions\n\nDelete 00LOCK folder(s) – The error message of the package installation failure will indicate if this is the issue and tell you where the 00LOCK folder is located. Make sure all other R sessions are closed and that the current session is restarted (and possibly closed), before deleting the 00LOCK folder. Then try installing the package again. If you can’t delete it, ensure RStudio and R are completely closed and possibly other software such as Git version control software (e.g. GitKraken, Bitbucket).\n\n\n\n\n4.2.3 Missing dependencies\nAlthough this happens less and less because functions like install.packages now default to installing package dependencies, it can still happen that one of the target package’s dependencies is missing or failed to install. The error message will indicate which one, but bear in mind that when installing many packages/dependencies, the reason why the dependency wasn’t installed may be buried in previous messages and warnings. So read the installation output carefully.\n\n4.2.3.1 Potential solutions\nThe solution will depend on the reason why the dependency package failed to install. See solutions in Package has already been loaded and 00LOCK folder issues.\n\n\n\n4.2.4 Package version cannot be met or found\nWhen Require is used to install packages1, it uses various caching mechanisms. If a package can’t be found, or there is an unexplainable installation failure clearing the package cache may fix it.\n\n4.2.4.1 Potential solutions\nTry purging the cache with one or more of these:\n\n\nCode\n## Can't find the package remotely\nRequire::purgeCache()\n\n## Can't install a particular package, e.g., ggplot2\nRequire::clearRequirePackageCache(packages = \"ggplot2\")\n\n## The above didn't work, clear ALL packages from local cache\nRequire::purgeCache(packages = TRUE)",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Troubleshooting R package installation</span>"
    ]
  },
  {
    "objectID": "TroubleshootingPackageInstallation.html#installed-a-package-but-it-isnt-showing-up",
    "href": "TroubleshootingPackageInstallation.html#installed-a-package-but-it-isnt-showing-up",
    "title": "4  Troubleshooting R package installation",
    "section": "4.3 Installed a package, but it isn’t showing up",
    "text": "4.3 Installed a package, but it isn’t showing up\n\n4.3.1 You installed it to a different library\nAs people migrate to using “project” libraries, i.e., a unique R package library for each project, sometimes, the user library (the one that you get by default with a normal R installation) can cause problems.\n\n4.3.1.1 Potential solutions\n\nBecome aware of user vs. project library – .libPaths() is your friend. It tells you what folder the current R session is using as a package library. The default place for a personal library in R depends on operating system. For windows, it is something like:\n\n\n\nCode\n&gt; Sys.getenv(\"R_LIBS_USER\") [1] \"C:\\\\Users\\\\emcintir\\\\AppData\\\\Local/R/win-library/4.4\"}\n\n\nFor Linux, it is something like:\n\n\nCode\n&gt; Sys.getenv(\"R_LIBS_USER\") [1] \"/home/emcintir/R/x86_64-pc-linux-gnu-library/4.3\"}\n\n\nIf you have a project-specific library, including if you use SpaDES.project or renv, .libPaths() will point to somewhere else. For SpaDES.project it will be something like:\n\n\nCode\n# Windows \n&gt; .libPaths() [1] \"C:/Users/emcintir/AppData/Roaming/R/data/R/SpaDES.project/packages/x86_64-w64-mingw32/4.4\"  \n\n# Linux \n&gt; .libPaths() [1] \"/home/emcintir/.local/share/R/SpaDES.project/packages/x86_64-pc-linux-gnu/4.3\"}\n\n\nWhen you install a package, ensure it was installed in the correct location.\n\n\n\n4.3.2 Package loaded in RAM collides with package on disk\nIf you previously loaded a package via e.g., library(ggplot2), then you happen to update it to a newer version, the newer version will be on disk in your library, but packageVersion(\"ggplot2\") will show the older one. Restart R and it will be solved.",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Troubleshooting R package installation</span>"
    ]
  },
  {
    "objectID": "TroubleshootingPackageInstallation.html#see-also",
    "href": "TroubleshootingPackageInstallation.html#see-also",
    "title": "4  Troubleshooting R package installation",
    "section": "4.4 See also",
    "text": "4.4 See also\nAn alternative way to address package management is using the renv package. Some people have great success with this. Some of us find it not very amenable to modular workflows.",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Troubleshooting R package installation</span>"
    ]
  },
  {
    "objectID": "TroubleshootingPackageInstallation.html#footnotes",
    "href": "TroubleshootingPackageInstallation.html#footnotes",
    "title": "4  Troubleshooting R package installation",
    "section": "",
    "text": "For instance, SpaDES.project functions and SpaDES.core::simInit() internally use Require to install package dependencies specified by the user or modules.↩︎",
    "crumbs": [
      "Setting up your computer and system",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Troubleshooting R package installation</span>"
    ]
  },
  {
    "objectID": "SpaDESbasics.html",
    "href": "SpaDESbasics.html",
    "title": "SpaDES 101",
    "section": "",
    "text": "The following chapters cover the basics of working with SpaDES.\nWe introduce fundamental pieces of SpaDES workflows, namely modules, events and functions. We show how to create simple modules and link them in simple workflows, the “simulation” object – the simList – module metadata and an introduction to caching mechanisms in SpaDES.\nBy the end of this chapter you should understand how SpaDES modules are comprised of events that are automatically scheduled and run by the SpaDES.core::simInit and SpaDES.core::spades functions (or SpaDES.core::simInitAndSpades which groups the previous two).\n\n\n\nThree modules, caribou, vegetation and harvest, each with two events that are scheduled in a yearly or monthly sequence",
    "crumbs": [
      "SpaDES 101"
    ]
  },
  {
    "objectID": "NewModuleIntro.html",
    "href": "NewModuleIntro.html",
    "title": "5  Introduction to SpaDES Modules",
    "section": "",
    "text": "5.1 Some R code to convert\nCode\n# create some data\nx &lt;- rnorm(10)\ny &lt;- x + rnorm(10)\n# fit a linear model\nmodel &lt;- lm(y ~ x)\n\n# plot the fit\nplot(model)\nLooking at this code above, we can imagine that the first 3 lines are conceptually different – fit a dummy model – from the last line – visualize it. Let’s put these into 2 “modules”, and then run them in sequence.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "NewModuleIntro.html#create-a-module",
    "href": "NewModuleIntro.html#create-a-module",
    "title": "5  Introduction to SpaDES Modules",
    "section": "5.2 Create a module",
    "text": "5.2 Create a module\nWe use the SpaDES.core function newModule() to make a new module.\nStep 1 – move the code to an “init” event. This “init” event is a convention that SpaDES uses. A module must always have an “init” event. This is the only code that is “definitely run” in a module.\n\n\nCode\nRequire::Require(c(\"reproducible\", \"SpaDES.core (&gt;= 2.1.5)\"), \n                 repos = c(\"https://predictiveecology.r-universe.dev\", getOption(\"repos\")))\n\n# make a module\nnm1 &lt;- \"My_linear_model\"\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nSpaDES.core::newModule(name = nm1, path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           x &lt;- rnorm(10)\n                           y &lt;- x + rnorm(10)\n                           # fit a linear model\n                           model &lt;- lm(y ~ x)\n                         }\n                       ))\n\n\nKeeping objects\nFor now, we just say, if you want to keep an object, assign it to “sim”. We will explain this in much more detail later. Here, we want to keep the model that we fit. But we don’t care about the x and y. So we assign the model to sim.\n\n\nCode\n# make a module\nSpaDES.core::newModule(name = nm1, path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           x &lt;- rnorm(10)\n                           y &lt;- x + rnorm(10)\n                           # fit a linear model\n                           sim$model &lt;- lm(y ~ x)     #  &lt;--------- change to sim$\n                         }\n                       ))\n\n\nHow would we run this “init” event? We use simInit, which parses the code (like loading a library or sourcing a function) then spades, which executes it.\n\n\nCode\nout &lt;- simInit(modules = nm1, paths = list(modulePath = modulePath))\nout &lt;- spades(out)\n\n\nWe can look at the output:\n\n\nCode\nout$model\n\n\nWe can also look at “what ran”… or in other words, what was our workflow. Of course, this will just be one “user-created” event (there are 4 “SpaDES-created” events … we may use them later, ignore for now)\n\n\nCode\ncompleted(out)\n\n\nWe have our first “simple workflow”! 1 chunk of code :)\n\n5.2.1 Add a second module\nOur next step is to divide the pieces into conceptual chunks. Let’s now create a new module for the plot … a “visualization module”.\n\n\nCode\nnm2 &lt;- \"visualize\"\nSpaDES.core::newModule(nm2, path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           plot(sim$model)\n                         }\n                       )\n)\n\n\nAnd now we run both together. We name them both in the module argument. We are using simInitAndSpades which is a shortcut to running the two functions separately.\n\n\nCode\nout2 &lt;- simInitAndSpades(module = c(nm1, nm2), paths = list(modulePath = modulePath))\n\n\nWe can look at the output again:\n\n\nCode\nout2$model\n\ncompleted(out2)\n\n\nThis time, there is an extra event that happened. We now have a workflow of 2 events.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "NewModuleIntro.html#sec-newModule-challengeYourself",
    "href": "NewModuleIntro.html#sec-newModule-challengeYourself",
    "title": "5  Introduction to SpaDES Modules",
    "section": "5.3 Challenge yourself",
    "text": "5.3 Challenge yourself\n\nMake a new module. Make it really simple. Run it with simInitAndSpades as in the above examples.\n\n-   Use `sim$` for an object that will be outputted.\n\nMake a second new module that uses the sim$ object.\n\n-   Add another new object in `sim$`\n\nMake a third new module that uses the sim$ object from the 2nd module.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "NewModuleIntro.html#see-also",
    "href": "NewModuleIntro.html#see-also",
    "title": "5  Introduction to SpaDES Modules",
    "section": "5.4 See also",
    "text": "5.4 See also\nsimList accessors\n?simInitAndSpades\n?newModule",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "NewModuleIntro.html#barebones-r-script",
    "href": "NewModuleIntro.html#barebones-r-script",
    "title": "5  Introduction to SpaDES Modules",
    "section": "5.5 Barebones R script",
    "text": "5.5 Barebones R script\n\n\nCode\n# create some data\nx &lt;- rnorm(10)\ny &lt;- x + rnorm(10)\n# fit a linear model\nmodel &lt;- lm(y ~ x)\n\n# plot the fit\nplot(model)\n\nRequire::Require(c(\"reproducible\", \"SpaDES.core (&gt;= 2.1.5)\"), \n                 repos = c(\"https://predictiveecology.r-universe.dev\", getOption(\"repos\")))\n\n# make a module\nnm1 &lt;- \"My_linear_model\"\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nSpaDES.core::newModule(name = nm1, path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           x &lt;- rnorm(10)\n                           y &lt;- x + rnorm(10)\n                           # fit a linear model\n                           model &lt;- lm(y ~ x)\n                         }\n                       ))\n\n# make a module\nSpaDES.core::newModule(name = nm1, path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           x &lt;- rnorm(10)\n                           y &lt;- x + rnorm(10)\n                           # fit a linear model\n                           sim$model &lt;- lm(y ~ x)     #  &lt;--------- change to sim$\n                         }\n                       ))\n\nout &lt;- simInit(modules = nm1, paths = list(modulePath = modulePath))\nout &lt;- spades(out)\n\nout$model\n\ncompleted(out)\n\nnm2 &lt;- \"visualize\"\nSpaDES.core::newModule(nm2, path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           plot(sim$model)\n                         }\n                       )\n)\n\nout2 &lt;- simInitAndSpades(module = c(nm1, nm2), paths = list(modulePath = modulePath))\n\nout2$model\n\ncompleted(out2)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html",
    "href": "MetaDataAndModuleFiles.html",
    "title": "6  Module Files and Metadata",
    "section": "",
    "text": "6.1 Continue example – a linear model\nWe will start by thinking about metadata: What is metadata?\nSlightly modifying the example, we remove the line with x &lt;- rnorm(10). This will make the code chunk not work because it needs the x to run the next line. We can examine the following code chunk. First, we ask: what are the inputs and the outputs?\nCode\n# create some data\ny &lt;- x + rnorm(10)\n# fit a linear model\nmodel &lt;- lm(y ~ x)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#required-packages-input-expectations-and-output-creations",
    "href": "MetaDataAndModuleFiles.html#required-packages-input-expectations-and-output-creations",
    "title": "6  Module Files and Metadata",
    "section": "6.2 Required Packages, Input Expectations and Output Creations",
    "text": "6.2 Required Packages, Input Expectations and Output Creations\n\n6.2.1 Inputs and Outputs\nWe use the terms expectsInput and createsOutput to describe the inputs and outputs in the metadata. This makes it clear that the metadata do not specify which they will go get; rather, it makes it clear that it doesn’t matter where the inputs are coming from. They could come from one of three sources: a user, another module, or defaults that the developer sets up. Likewise, the module specifies which outputs it creates, without specifying “for what other module”.\nThe inputs to this chunk are just one: the object x. This code will not work (i.e., it will cause an error) if x is not defined. We can say that this code chunk “expects” x as an input.\nThe outputs are y and model. We can say that this code chunk “creates” y and model as outputs. However, we had said in Chapter 5 that we would only be interested in keeping model. So, we will continue with only one output, model.\n\n\n6.2.2 Required Packages\nNext, what are the package dependencies?. We call this reqdPkgs in the SpaDES metadata. We see that there are three functions: rnorm, lm and plot. We don’t know what packages they are in, so we can find out by typing them at the R prompt. At the bottom of the function, it says that the function rnorm is in the stats package. Fortunately for us, this is a default (“base”) package in R and it is always pre-loaded. So, nothing to do here.\n\n\nCode\n&gt; rnorm function (n, mean = 0, sd = 1)  ... \n&lt;environment: namespace:stats&gt;}\n\n\nSo, our expectations, dependencies and creations are:\n\nInputs: x\nOutputs: model\nPackage dependencies: Base packages only\n\nWe will next put them into the correct places in the new SpaDES module.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#module-files",
    "href": "MetaDataAndModuleFiles.html#module-files",
    "title": "6  Module Files and Metadata",
    "section": "6.3 Module files",
    "text": "6.3 Module files\nMake the module again (see Chapter 5). This time we will add sim$ for the x as we are now interested in the fact that it might be coming from outside this module.\n\n\nCode\nRequire::Require(c(\"reproducible\", \"SpaDES.core\"), repos = c(\"https://predictiveecology.r-universe.dev\", getOption(\"repos\")))\n\n# make a module\nnm1 &lt;- \"My_linear_model\"\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nSpaDES.core::newModule(name = nm1, path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           y &lt;- sim$x + rnorm(10)      # &lt;--------- add sim$ here\n                           # fit a linear model\n                           sim$model &lt;- lm(y ~ sim$x)  # &lt;--------- add sim$ here\n                         }\n                       ))\n\n\nWhere is this module code? In the previous chapter, we didn’t look or care where the module code was.\nnewModule actually creates a new folder, with the name as provided by the argument, in the folder specified with path. This folder has several files in it. See ?newModule for details. For now, run the above and open the My_linear_model.R script that it creates.\nWhen we make a module, we get a message stating where the module code is. From here, open the file, e.g., by copy-pasting the file path (pick the .R file NOT the .Rmd file for now)\n\n\n\n\n\n\nOpening a module file\nFrom here onward, we will need to manually open the module code file. Every SpaDES module is defined by having at least 1 file that is named with &lt;modulePath&gt;/&lt;moduleName&gt;/&lt;moduleName&gt;.R. Even though we can do a lot with newModule(), we will need to get used to opening, examining and changing the code in the module code file.\n\n\n\nWe will look at a few elements in this chapter.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#inputobjects",
    "href": "MetaDataAndModuleFiles.html#inputobjects",
    "title": "6  Module Files and Metadata",
    "section": "6.4 inputObjects",
    "text": "6.4 inputObjects\nScroll down to inputObjects and expectsInputs(). This is where we will put our inputs that we noticed in our code chunk. We will declare x as an “input” by putting it there, like this:\n\n\nCode\ninputObjects = bindrows(\n  expectsInput(objectName = \"x\", objectClass = \"numeric\", \n               desc = \"The inputs for the linear model\", sourceURL = NA)\n)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#outputobjects",
    "href": "MetaDataAndModuleFiles.html#outputobjects",
    "title": "6  Module Files and Metadata",
    "section": "6.5 outputObjects",
    "text": "6.5 outputObjects\nNext, scroll down to outputObjects and createsOutput(). We will declare model as an “output” by putting it there. Don’t forget the comma at the end of each createsOutput() as each is an argument to bindrows (unless it is the last one).\n\n\nCode\noutputObjects = bindrows(\n  createsOutput(objectName = \"model\", objectClass = \"lm\", \n                desc = \"A linear model object from the equation (x ~ y)\")\n)\n\n\nAfter saving the module R script, we can run the module ad inspect the output\n\n\nCode\nout &lt;- simInit(modules = nm1, paths = list(modulePath = modulePath))\nout &lt;- spades(out)\n\n# or \nout &lt;- simInitAndSpades(modules = nm1, paths = list(modulePath = modulePath))\n\nout$model",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#sharing-inputs-and-outputs",
    "href": "MetaDataAndModuleFiles.html#sharing-inputs-and-outputs",
    "title": "6  Module Files and Metadata",
    "section": "6.6 Sharing inputs and outputs",
    "text": "6.6 Sharing inputs and outputs\nYou may have noticed that the init event is now placed into a function called doEvent.My_linear_model.init and it has an argument sim. If you are familiar with making functions in R, this is just a named argument \"sim\". This means that we can use sim inside the function. We don’t know what sim is yet, and we don’t know how to use it fully yet. But we do know that we have added sim$ to the init event. We also see that there is a return(sim) added at the bottom of the event function.\n\n\n\n\n\n\nAn event occurs in a special function that starts with doEvent.. But, since it is “in a function”, each event has all the features of a function:\n\narguments – specifically sim can be used\nsomething returned – in this case, the simList. return(sim) must always be present - it is by default, but don’t delete it!\nit can be run– but don’t worry about running it; SpaDES runs it when it is time.\n\n\n\n\n\n\n\n\n\n\nThe simList\nThe simList is the data structure that is the foundation of SpaDES. It can be used like a list; accessing objects can be done with $ or [[\"model\"]], for example.\nIn any function that has an argument sim, we pass the simList, so we can access the simList with sim$ from inside such a function.\nSee Chapter 8 for more details about the simList.\n\n\n\nTo share objects between modules, we must assign them to the sim and make sure that return(sim) is at the end of the function.\nNow we have a module that creates one object, model and puts them inside sim. This all happens in the event called init.\nNext: add the visualization module with metadata",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#visualization-module",
    "href": "MetaDataAndModuleFiles.html#visualization-module",
    "title": "6  Module Files and Metadata",
    "section": "6.7 Visualization module",
    "text": "6.7 Visualization module\nWe remake the second module from last chapter. But this time we will look at and update the metadata.\n\n\nCode\nnm2 &lt;- \"visualize\"\nnewModule(nm2, path = modulePath, open = FALSE,\n          events = list(\n            init = {\n              plot(sim$model)\n            }\n          )\n)\n\n\n\n6.7.1 Outputs of one module are Inputs of another\nHere we start to see the “shared” objects. The module we just made above createsOutput of model. But this new visualization module will expectInput of model. So, we can copy the same description if it is the same.\n\n\nCode\ninputObjects = bindrows(\n  expectsInput(objectName = \"model\", objectClass = \"lm\", \n               desc = \"A linear model object from the equation (x ~ y)\", sourceURL = NA)\n)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#default-values",
    "href": "MetaDataAndModuleFiles.html#default-values",
    "title": "6  Module Files and Metadata",
    "section": "6.8 Default Values",
    "text": "6.8 Default Values\nRecall, we don’t have a value for x. This means that if you run the following, you will get an error, unlike in the previous chapter where we had x defined in the init event.\n\n\nCode\nsimInitAndSpades(modules = c(nm1, nm2), \n                 paths = list(modulePath = modulePath))\n\n\nJust like functions in R, we can supply default values for our inputs. We put these in a function at the bottom called .inputObjects. See Chapter 7 for a model detailed explanation of module inputs and how to deal with them.\nCopy this to the module, replacing the contents of the template .inputObjects function.\n\n\nCode\n.inputObjects &lt;- function(sim) {\n  if (!suppliedElsewhere(\"x\", sim))\n    sim$x &lt;- rnorm(10, mean = 20, sd = 2)\n  return(invisible(sim))\n}\n\n\n!suppliedElsewhere(\"x\", sim) will check if x is in sim and if not, will run the subsequent code lines (see ?suppliedElsewhere).",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#run-the-new-module",
    "href": "MetaDataAndModuleFiles.html#run-the-new-module",
    "title": "6  Module Files and Metadata",
    "section": "6.9 Run the new module",
    "text": "6.9 Run the new module\nNow, we have inputs and outputs defined, our code has been places in 2 spots (events), and we have default value for x.\n\n\nCode\nsimInitAndSpades(modules = c(nm1, nm2), \n                 paths = list(modulePath = modulePath))\n\n\nWe now have a SpaDES module that has metadata, generates random starting data (if the user doesn’t supply an alternative), fits a linear model, outputs that model, and plots the fit.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#questions",
    "href": "MetaDataAndModuleFiles.html#questions",
    "title": "6  Module Files and Metadata",
    "section": "6.10 Questions",
    "text": "6.10 Questions\n\nWhat are some things we “gained” from putting our simple 3 lines of code into a module?\n\nWe can turn off plotting easily. Set .plotInitialTime = NA in the simInitAndSpades call.\n\nWhat are some things we “lost”?\n\nMore complicated. (overkill for these 3 lines?)\n\nWhat if we used an R package that wasn’t in the base packages list?\n\nSee ?defineModule for all the metadata items. Specifically, see reqdPkgs.\n\nWhat is the sim? See ?'.simList-class'",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#sec-moduleFilesAndMetadata-challengeYourself",
    "href": "MetaDataAndModuleFiles.html#sec-moduleFilesAndMetadata-challengeYourself",
    "title": "6  Module Files and Metadata",
    "section": "6.11 Challenge yourself",
    "text": "6.11 Challenge yourself\n\nFill in the metadata from the Challenges you did in previous chapter.\nLook at the other elements of the metadata and cross reference them with ?defineModule\nLook at the Rmd file of one of the modules that has been built (recall the message after you call newModule), where you have filled in the metadata. Try to build it and look at the automatic tables that get built from the metadata.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#see-also",
    "href": "MetaDataAndModuleFiles.html#see-also",
    "title": "6  Module Files and Metadata",
    "section": "6.12 See also",
    "text": "6.12 See also\nChapter 9 on Modules, Events and Functions\nChapter 7 on module inputs\nChapter 8 on the simList\n?defineModule describes all the metadata entries.\n?expectsInput\n?createsOutput\n?simInitAndSpades\n?newModule\n?SpaDES.project::setupProject\n?SpaDES.core::simInit\n?SpaDES.core::simInitAndSpaDES",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "MetaDataAndModuleFiles.html#barebones-r-script",
    "href": "MetaDataAndModuleFiles.html#barebones-r-script",
    "title": "6  Module Files and Metadata",
    "section": "6.13 Barebones R script",
    "text": "6.13 Barebones R script\n\n\nCode\n# create some data\ny &lt;- x + rnorm(10)\n# fit a linear model\nmodel &lt;- lm(y ~ x)\n\n\n\nRequire::Require(c(\"reproducible\", \"SpaDES.core\"), repos = c(\"https://predictiveecology.r-universe.dev\", getOption(\"repos\")))\n\n# make a module\nnm1 &lt;- \"My_linear_model\"\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nSpaDES.core::newModule(name = nm1, path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           y &lt;- sim$x + rnorm(10)      # &lt;--------- add sim$ here\n                           # fit a linear model\n                           sim$model &lt;- lm(y ~ sim$x)  # &lt;--------- add sim$ here\n                         }\n                       ))\n\n\n\n\n\nout &lt;- simInit(modules = nm1, paths = list(modulePath = modulePath))\nout &lt;- spades(out)\n\n# or \nout &lt;- simInitAndSpades(modules = nm1, paths = list(modulePath = modulePath))\n\nout$model\n\nnm2 &lt;- \"visualize\"\nnewModule(nm2, path = modulePath, open = FALSE,\n          events = list(\n            init = {\n              plot(sim$model)\n            }\n          )\n)\n\n\n\nsimInitAndSpades(modules = c(nm1, nm2), \n                 paths = list(modulePath = modulePath))\n\n\n\nsimInitAndSpades(modules = c(nm1, nm2), \n                 paths = list(modulePath = modulePath))",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Module Files and Metadata</span>"
    ]
  },
  {
    "objectID": "ModuleInputs.html",
    "href": "ModuleInputs.html",
    "title": "7  Module Inputs",
    "section": "",
    "text": "7.1 How to supply Inputs\nThere are several ways to get objects into the simList:\nUltimately, it is the last of these that is the power of SpaDES. i.e., modularity.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Module Inputs</span>"
    ]
  },
  {
    "objectID": "ModuleInputs.html#how-to-supply-inputs",
    "href": "ModuleInputs.html#how-to-supply-inputs",
    "title": "7  Module Inputs",
    "section": "",
    "text": "User passes during simInit:\nusing the objects argument (if it is an object);\nusing the inputs argument (if it is from disk);\nusing the params argument;\nDeveloper creates defaults and specifies them in defineParameter() and .inputObjects;\nA different module creates them prior to the running of this module.\n\n\n\n7.1.1 During simInit\nA user can directly pass objects into the simInit and these will be put into the simList\n\n\nCode\na &lt;- 1\nsim &lt;- SpaDES.core::simInit(objects = list(a = a))\nsim$a\n\n\nor do pass them via an .rds file\n\n\nCode\nb &lt;- 1\ntf &lt;- tempfile(fileext = \".rds\")\nsaveRDS(b, file = tf)\nsim &lt;- SpaDES.core::simInit(inputs = data.frame(object = \"b\", file = tf))\nsim$b\n\n\nBecause parameters are usually module-specific, and need to be passed to with reference to a module. “Global” parameters are the exception to this rule:\n\n\nCode\nc &lt;- 1\nsim &lt;- SpaDES.core::simInit(params = list(.globals = list(c = c)))\nSpaDES.core::params(sim)$.globals$c\n\n\nTo pass parameters to a module, we go back to out simple module and make a minor change:\n\n\nCode\nnm1 &lt;- \"My_linear_model\"\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nSpaDES.core::newModule(name = nm1, path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           x &lt;- rnorm(P(sim)$length)\n                           y &lt;- x + rnorm(P(sim)$length)\n                           # fit a linear model\n                           model &lt;- lm(y ~ x)\n                         }\n                       ))\n\n\nNow we open My_linear_model.R and add the following\n\n\nCode\ndefineParameter(\"length\", \"integer\", 10L, 5L, 100L,\n                \"Number of values to generate\")\n\n\n… to the module metadata section for parameters. Remember to save the file after you’re done.\n\n\nCode\ndefineModule(\n  &lt;...&gt;\n    parameters = bindrows(\n      # here\n      &lt;...&gt;\n    )\n  &lt;...&gt;\n)\n\n\nNow run the the module:\n\n\nCode\nout2 &lt;- SpaDES.core::simInitAndSpades(modules = nm1,\n                         paths = list(modulePath = modulePath))\nparams(out2)   # can you find the length parameter?\n\n\nNotice how params = list(\"My_linear_model\" = list(length = 20)) has \"My_linear_model\", not nm1. this is because list() does not accept objects as “names”.\n\n\n7.1.2 .inputObjects\nFor every Input that is specified in the metadata, the module developer has the option of specifying a default. In R, functions can be given defaults when they are defined like this:\n\n\nCode\nrnormMean5 &lt;- function(n = 1) { # the n = 1 is the default value\n  rnorm(n = n, mean = 5)\n}\nrnormMean5() # can be run without any arguments\n\n\nThis works for only the simplest cases. In the case of a module, objects can be arbitrarily complicated and so this approach will not be suitable.\nInstead, there is a function that is called every time a module is initialized (i.e. by simInit()) where a developer can put anything they want to specify as defaults. It is generally most useful to use if (!SpaDES.core::suppliedElsewhere(\"obj\", sim)) i.e., if the object isn’t in sim, then give it a value.\n\n\nCode\n.inputObjects &lt;- function(sim) {\n  \n  if (!suppliedElsewhere(\"y\", sim)) {\n    sim$y &lt;- rnorm(100)\n  }\n  \n  return(sim)\n}\n\n\n\n7.1.2.1 Advanced .inputObjects example\nIn the Biomass_core module (this is an implementation of the LANDIS-II Biomass Succession Extension v3.2), there are many Inputs as defined in the metadata. The module needs each one of these to work.\nThe developers have created a .inputObjects function that will fill in these Inputs with defaults if the user hasn’t supplied them (using !SpaDES.core::suppliedElsewhere()).\nWe will look at a few examples in this module: Biomass_core::.inputObjects.\n\nsome GIS tests that evaluate whether 2 objects are in the same CRS (i.e., they need to be the same projection, etc., for this module to work)\nif an object is missing, it may make sense to fill in the details with parameters from the Internet.\nan object called studyArea. The developer tests whether it exists and creates an error if it does not exist.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Module Inputs</span>"
    ]
  },
  {
    "objectID": "ModuleInputs.html#questions",
    "href": "ModuleInputs.html#questions",
    "title": "7  Module Inputs",
    "section": "7.2 Questions",
    "text": "7.2 Questions\n\nIn .inputObjects, why don’t we just write if (!is.null(sim$y))? See ?SpaDES.core::suppliedElsewhere\n\nIt turns out that other modules may create this object “after” this module is run, and this test will fail.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Module Inputs</span>"
    ]
  },
  {
    "objectID": "ModuleInputs.html#try-on-your-own",
    "href": "ModuleInputs.html#try-on-your-own",
    "title": "7  Module Inputs",
    "section": "7.3 Try on your own",
    "text": "7.3 Try on your own\n\nUsing the My_linear_model shown above, try running simulations where you pass different values to the length parameter\n\nTip: have a look at the params argument of SpaDES.core::simInitAndSpades()",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Module Inputs</span>"
    ]
  },
  {
    "objectID": "ModuleInputs.html#see-also",
    "href": "ModuleInputs.html#see-also",
    "title": "7  Module Inputs",
    "section": "7.4 See also",
    "text": "7.4 See also\n?SpaDES.core::expectsInputs\n?SpaDES.core::suppliedElsewhere\n?SpaDES.core::defineParameter\n?SpaDES.core::simInit\n?SpaDES.core::simInitAndSpades",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Module Inputs</span>"
    ]
  },
  {
    "objectID": "ModuleInputs.html#barebones-r-script",
    "href": "ModuleInputs.html#barebones-r-script",
    "title": "7  Module Inputs",
    "section": "7.5 Barebones R script",
    "text": "7.5 Barebones R script\n\n\nCode\na &lt;- 1\nsim &lt;- SpaDES.core::simInit(objects = list(a = a))\nsim$a\n\nb &lt;- 1\ntf &lt;- tempfile(fileext = \".rds\")\nsaveRDS(b, file = tf)\nsim &lt;- SpaDES.core::simInit(inputs = data.frame(object = \"b\", file = tf))\nsim$b\n\nc &lt;- 1\nsim &lt;- SpaDES.core::simInit(params = list(.globals = list(c = c)))\nSpaDES.core::params(sim)$.globals$c\n\nnm1 &lt;- \"My_linear_model\"\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nSpaDES.core::newModule(name = nm1, path = modulePath, open = FALSE,\n                       events = list(\n                         init = {\n                           x &lt;- rnorm(P(sim)$length)\n                           y &lt;- x + rnorm(P(sim)$length)\n                           # fit a linear model\n                           model &lt;- lm(y ~ x)\n                         }\n                       ))\n\n\n\n\n\nout2 &lt;- SpaDES.core::simInitAndSpades(modules = nm1,\n                         paths = list(modulePath = modulePath))\nparams(out2)   # can you find the length parameter?\n\nrnormMean5 &lt;- function(n = 1) { # the n = 1 is the default value\n  rnorm(n = n, mean = 5)\n}\nrnormMean5() # can be run without any arguments",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Module Inputs</span>"
    ]
  },
  {
    "objectID": "simList.html",
    "href": "simList.html",
    "title": "8  The simList - What is it?",
    "section": "",
    "text": "8.1 Where does simList come from?\nThere is only one way in SpaDES.core to create a simList:",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#where-does-simlist-come-from",
    "href": "simList.html#where-does-simlist-come-from",
    "title": "8  The simList - What is it?",
    "section": "",
    "text": "using simInit() creates a simList object.1",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#how-can-we-specify-a-simlist",
    "href": "simList.html#how-can-we-specify-a-simlist",
    "title": "8  The simList - What is it?",
    "section": "8.2 How can we specify a simList?",
    "text": "8.2 How can we specify a simList?\nA simList object is simply a structured data type containing various elements.\nThe main components of a simList are:\n\nA list of modules used;\nThe event queue;\nA description of the data (object) dependencies.\n\nWe can examine the simList object structure in the usual R fashion by printing (showing) it, or by using str():\n\n\nCode\nemptySim &lt;- SpaDES::simInit()\nemptySim  # same as show(emptySim)\nstr(emptySim)\n\n\nNOTE: simLists are S4 objects, so we can use getSlots() and slotNames() to examine the object.\nSee also ?'simList-class'",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#accessing-the-parts-of-a-simlist",
    "href": "simList.html#accessing-the-parts-of-a-simlist",
    "title": "8  The simList - What is it?",
    "section": "8.3 Accessing the parts of a simList",
    "text": "8.3 Accessing the parts of a simList\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe simList can be imagined as a file cabinet where all the simulation details and objects (i.e. the parameters, inputs and outputs declared by each module) are stored neatly and in an easily accessible way.\n\n\n\n\n\n\n\n\n\n\n8.3.1 Initialize and inspect an empty simList object\n\n\nCode\nemptySim &lt;- simInit()\n\n\n\nWhat are the names of each of the slots in the simList?\nWhat do each of these slots contain?\n\nHint: see ?'simList-class'\n\n\nCode\nstr(emptySim)\nslotNames(emptySim)\ngetSlots('simList')\n?`simList-class`\n\n\n\n\n8.3.2 Inspect a non-empty simList object\nUse the simList accessor functions to determine the following:\n\nthe modules included in the simulation and their package dependencies;\nthe global parameter values used;\nthe module-specific parameter values used;\nthe simulation start and end times;\nthe timeunits used by the modules in the simulation;\nthe scheduled and completed event queues;\nthe objects (functions, data, etc.) used in the simulation;\nthe file paths used for simulation inputs and outputs.\n\nWe will try this with the simple linear module first, for which we’ve already defined default values for the input object x (see Chapter 6).\n\n\nCode\n# Get the sample modules that come with SpaDES.core\n\nmodulePath &lt;- getSampleModules(tempdir())\n# options(spades.loadReqdPkgs = FALSE) # we don't need to check for packages in this example\nnm1 &lt;- \"My_linear_model\"\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nmySim &lt;- simInit(params = list(\"My_linear_model\" = list(length = 20)),\n                 modules = nm1,\n                 paths = list(modulePath = modulePath))\nevents(mySim)\n\n# b is in the .xData slot\nmySim$x\nmySim@.xData$x\n\n# all functions below come from SpaDES.core::\n# list modules used in the simulation\nmodules(mySim)\n\n# list module dependencies and packages used\ndepends(mySim)\npackages(mySim)\n\n# list global and module-specific param values\nparams(mySim)\nP(mySim)       # bonus: how do params() and P() differ?\n\n# list start and end times\ntimes(mySim)\nstart(mySim)\nend(mySim)\n\n# get the simulation and module timeunits\ntimeunit(mySim)\ntimeunits(mySim)\n\n# get the scheduled and completed event queues\nevents(mySim)\ncompleted(mySim)\n\n# list the objects (functions, data, etc.) stored in the simList\nobjects(mySim)\n\n# list the file paths used in the simulation\npaths(mySim)\ninputPath(mySim)\noutputPath(mySim)\n\n\nNow run the simulation\n\n\nCode\nmySimOut &lt;- reproducible::Copy(mySim) # make a deep copy of the simList\nmySimOut &lt;- spades(mySimOut)\n\n\n\n\n\n\n\n\nsimNew &lt;- sim doesn’t copy\n\n\n\nIf you don’t know what an environment is in R, it is OK. The most important feature of an environment is that it employs pass-by-reference, which means it is not copied when it is “assigned” somewhere. This makes SpaDES fast enough to use for huge workflows.\n\n\nCode\nsim &lt;- simInit()\nsim$a &lt;- 1\nsimNew &lt;- sim\nsimNew$a &lt;- 2\n\n# what value will this have?\nsim$a\n\n\n\n\n\n\n8.3.3 Compare the simList before and after spades()\n\n\nCode\ntimes(mySim)\ntimes(mySimOut)\n\nobjects(mySim)\nobjects(mySimOut)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#try-on-your-own",
    "href": "simList.html#try-on-your-own",
    "title": "8  The simList - What is it?",
    "section": "8.4 Try on your own",
    "text": "8.4 Try on your own\n\nRepeat the above with more complex modules. Use the accessor functions to look at what inside the simList and try passing different parameter values or inputs.\n\n\nCode\nmodulePath &lt;- getSampleModules(tempdir())\n# options(spades.loadReqdPkgs = FALSE) # we don't need to check for packages in this example\nmySim &lt;- simInit(modules = dir(modulePath[1:3]),\npaths = list(modulePath = modulePath),\nobjects = list(b = 1))\nsimOut &lt;- spades(mySim)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#see-also",
    "href": "simList.html#see-also",
    "title": "8  The simList - What is it?",
    "section": "8.5 See also",
    "text": "8.5 See also\nEnvironments - Advanced R\n?'simList-class'\n?SpaDES.core::envir\n?SpaDES.core::simInit\n?SpaDES.core::spades",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#barebones-r-script",
    "href": "simList.html#barebones-r-script",
    "title": "8  The simList - What is it?",
    "section": "8.6 Barebones R script",
    "text": "8.6 Barebones R script\n\n\nCode\n# this is in the .GlobalEnv\na &lt;- 1\nenvironment()  ## the current environment is .GlobalEnv\nglobalenv()  ## the same\n\nls(envir = environment())\n\nRequire::Require(c(\"reproducible\", \"SpaDES.core  (&gt;= 2.1.5)\"),\n                 repos = c(\"https://predictiveecology.r-universe.dev\", getOption(\"repos\")))\n\nsim &lt;- simInit()\nsim$a &lt;- 1\nsim$b &lt;- sim$a + 2\nsim$b\nSpaDES.core::envir(sim)\n\nsim &lt;- simInit()\nis(sim, \"environment\")\n# [1] TRUE\n\nemptySim &lt;- SpaDES::simInit()\nemptySim  # same as show(emptySim)\nstr(emptySim)\n\n\n\n\n\nemptySim &lt;- simInit()\n\nstr(emptySim)\nslotNames(emptySim)\ngetSlots('simList')\n?`simList-class`\n\n# Get the sample modules that come with SpaDES.core\n\nmodulePath &lt;- getSampleModules(tempdir())\n# options(spades.loadReqdPkgs = FALSE) # we don't need to check for packages in this example\nnm1 &lt;- \"My_linear_model\"\nmodulePath &lt;- \"~/SpaDES_book/NewModuleIntro/NewModule\"\nmySim &lt;- simInit(params = list(\"My_linear_model\" = list(length = 20)),\n                 modules = nm1,\n                 paths = list(modulePath = modulePath))\nevents(mySim)\n\n# b is in the .xData slot\nmySim$x\nmySim@.xData$x\n\n# all functions below come from SpaDES.core::\n# list modules used in the simulation\nmodules(mySim)\n\n# list module dependencies and packages used\ndepends(mySim)\npackages(mySim)\n\n# list global and module-specific param values\nparams(mySim)\nP(mySim)       # bonus: how do params() and P() differ?\n\n# list start and end times\ntimes(mySim)\nstart(mySim)\nend(mySim)\n\n# get the simulation and module timeunits\ntimeunit(mySim)\ntimeunits(mySim)\n\n# get the scheduled and completed event queues\nevents(mySim)\ncompleted(mySim)\n\n# list the objects (functions, data, etc.) stored in the simList\nobjects(mySim)\n\n# list the file paths used in the simulation\npaths(mySim)\ninputPath(mySim)\noutputPath(mySim)\n\nmySimOut &lt;- reproducible::Copy(mySim) # make a deep copy of the simList\nmySimOut &lt;- spades(mySimOut)\n\nsim &lt;- simInit()\nsim$a &lt;- 1\nsimNew &lt;- sim\nsimNew$a &lt;- 2\n\n# what value will this have?\nsim$a\n\ntimes(mySim)\ntimes(mySimOut)\n\nobjects(mySim)\nobjects(mySimOut)\n\nmodulePath &lt;- getSampleModules(tempdir())\n# options(spades.loadReqdPkgs = FALSE) # we don't need to check for packages in this example\nmySim &lt;- simInit(modules = dir(modulePath[1:3]),\npaths = list(modulePath = modulePath),\nobjects = list(b = 1))\nsimOut &lt;- spades(mySim)",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "simList.html#footnotes",
    "href": "simList.html#footnotes",
    "title": "8  The simList - What is it?",
    "section": "",
    "text": "Note that simInitAndSpades calls simInit internally↩︎",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>The `simList` - What is it?</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html",
    "href": "ModulesAndEvents.html",
    "title": "9  Modules, Events and Functions",
    "section": "",
    "text": "9.1 Modules\nModules include the following elements:\nThere are many optional pieces too. The default template produces many of these optional pieces, which means it is “noisy”. This also means we can ignore most of it for now.\nOptional pieces include:\nThese are all contained within a file structure like this, with other optional files:\nTo make a new module, see: Chapter 5.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#modules",
    "href": "ModulesAndEvents.html#modules",
    "title": "9  Modules, Events and Functions",
    "section": "",
    "text": "a function call to defineModule that defines the metadata (mandatory)\na function definition for doEvent.moduleName (mandatory)\n\n\n\n\nother functions in the R folder or the main moduleName.R file\na documentation file (moduleName.rmd)\n\n\n/moduleRepository\n  |_ moduleName/\n      |_ R/                     # contains additional/optional .R (helper) files\n      |_ data/                  # directory for all included data\n          |_ CHECKSUMS.txt      # contains checksums for data files\n      |_ tests/                 # contains (optional) unit tests for module code\n      |_ citation.bib           # bibtex citation for the module\n      |_ LICENSE.txt            # describes module's legal usage\n      |_ moduleName.R           # module code file (incl. metadata)\n      |_ moduleName.Rmd         # documentation, usage info, etc.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#events",
    "href": "ModulesAndEvents.html#events",
    "title": "9  Modules, Events and Functions",
    "section": "9.2 Events",
    "text": "9.2 Events\nEvents are named chunks of code that can be scheduled to be run once or many times. These are scheduled with scheduleEvent(). There are several commonly occurring module types that can be grouped based on the events that they contain (see Section 9.4).\nTo see how to schedule events, see: Chapter 10.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#functions",
    "href": "ModulesAndEvents.html#functions",
    "title": "9  Modules, Events and Functions",
    "section": "9.3 Functions",
    "text": "9.3 Functions\nEssentially, everything in R is or uses functions. Modules define functions (doEvent.*moduleName*), events call specific functions (we some times call these “event functions”), and functions can be defined within modules, R packages, or user code.\n\n9.3.1 Rerun-tolerant functions\nIn re-usable workflows, functions become particularly effective if they are rerun-tolerant, see Tip 9.1 (we use tolerant in part to reflect the fact that the computer tolerates it but also the human because they don’t have to wait).\n\n\n\n\n\n\nTip 9.1\n\n\n\nFunctions are rerun-tolerant if they\n\nare rerun-efficient, meaning the first time they run they “do” something, but the second and subsequent times, they give the same output as the first time, but they skip the “doing” part\n\n\noptionally the efficiency can be by memory caching (“memoising”) and/or more persistent disk caching.\n\n\nand are rerun-robust, meaning they can be run error-free and with sensible or identical outputs (if inputs are the same) using any person’s computer.\n\n\n\nTo achieve these qualities, functions must use some sort of caching (i.e., evaluate the call and skip the content of the function if the call is deemed identical to a previous version of the call), and they must address any computer or operating system issues (such as paths, package dependencies etc.).\nBase R has some functions that are like this and some that are not. For example library is rerun-tolerant because it does something the first time, which may be slow, and subsequent times in the same session it is fast (memory efficient, but not disk efficient)\nTwo key functions help achieve these points, ?reproducible::Cache and ?reproducible::prepInputs\n\n\n9.3.2 Cache()\nCache() is a function that can be wrapped around other functions that turns that function into a rerun-tolerant function. reproducible::Cache has several important modifications that work for some objects that don’t cache well using “normal” caching, such as terra objects that are actually pointers to locations on disk rather than normal R objects.\nThe following code will result in d being the same vector as b, and it will be returned quickly.\n\n\nCode\nlibrary(reproducible)\n\na &lt;- rnorm(1e7)\nb &lt;- rnorm(1e7) |&gt; Cache()\nd &lt;- rnorm(1e7) |&gt; Cache()\n\n\nSee ?reproducible::Cache\n\n\n9.3.3 prepInputs()\nprepInputs() is a workhorse function that helps users point to cloud or local datasets: ?reproducible::prepInputs.\nIn this example, we point to a url only and prepInputs downloads it, does checksumming, unzips it and loads it into R using the default terra::vect because it is a shp file after the unzipping.\n\n\nCode\necozoneOfCanada &lt;- reproducible::prepInputs(\n  url = \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\")\n\n\nFor more information ?reproducible::prepInputs",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#sec-moduletypes",
    "href": "ModulesAndEvents.html#sec-moduletypes",
    "title": "9  Modules, Events and Functions",
    "section": "9.4 Module types",
    "text": "9.4 Module types\nEven though all modules are built with the same structures (events & functions), for convenience, we can categorize different types of modules in different ways.\nFor example, modules can be categorized by:\n\n9.4.1 Static\nStatic modules can be defined as modules that “run once”. This means that they may have only one event. Or a sequence of events that occur one after the other with no rescheduling.\nThese could include:\n\nData preparation modules - one (maybe just the “init” event) or few events and their primary goal is to get and deal with data;\nGIS modules that do a number of GIS operations to get data into the necessary formats;\nData Visualization modules that specialize in creating a set of visuals from a known set of inputs.\n\n\n\n9.4.2 Dynamic\nDynamic modules are modules that have events that recur. There are at least 2 types of such models: those that have cyclic dependencies, i.e., its outputs are also its inputs (possibly with other modules in between) and those that do not.\n\nLandscape simulation modules (e.g., wildfire, vegetation change)\nWildlife population modules with Markov dependency (e.g., population matrix models)\nWildlife population modules without Markov-dependency (e.g., population models that only depend on habitat covariates)\nData visualization modules that get used e.g., annually after other modules.\n\nIn Barros et al. (2023) we classified modules with respect to what the modules try to accomplish:\n\n“data/calibration modules” prepare model inputs and parameters\n“prediction/simulation modules” generate predictions using either static or dynamic mechanisms\n“validation modules” evaluate predictions against independent data.\n\nThere are no strict rules to classify a SpaDES module, just as there are no strict rules to classify an R script.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#see-also",
    "href": "ModulesAndEvents.html#see-also",
    "title": "9  Modules, Events and Functions",
    "section": "9.5 See also",
    "text": "9.5 See also\nChapter 10 on event scheduling\n?scheduleEvent\n?P\n?time\n?start\n?end",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#more-learning-on-this-subject",
    "href": "ModulesAndEvents.html#more-learning-on-this-subject",
    "title": "9  Modules, Events and Functions",
    "section": "9.6 More learning on this subject",
    "text": "9.6 More learning on this subject\nMy First Module\nCreating a seed dispersal module",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "ModulesAndEvents.html#barebones-r-script",
    "href": "ModulesAndEvents.html#barebones-r-script",
    "title": "9  Modules, Events and Functions",
    "section": "9.7 Barebones R script",
    "text": "9.7 Barebones R script\n\n\nCode\nlibrary(reproducible)\n\na &lt;- rnorm(1e7)\nb &lt;- rnorm(1e7) |&gt; Cache()\nd &lt;- rnorm(1e7) |&gt; Cache()\n\necozoneOfCanada &lt;- reproducible::prepInputs(\n  url = \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\")\n\n\n\n\n\n\nBarros, Ceres, Yong Luo, Alex M. Chubaty, Ian M. S. Eddy, Tatiane Micheletti, Céline Boisvenue, David W. Andison, Steven G. Cumming, and Eliot J. B. McIntire. 2023. “Empowering Ecological Modellers with a PERFICT Workflow: Seamlessly Linking Data, Parameterisation, Prediction, Validation and Visualisation.” Methods in Ecology and Evolution 14 (1): 173–88. https://doi.org/10.1111/2041-210X.14034.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Modules, Events and Functions</span>"
    ]
  },
  {
    "objectID": "Scheduling.html",
    "href": "Scheduling.html",
    "title": "10  Scheduling Events",
    "section": "",
    "text": "10.1 Convert to a module\nIn the above code, there are 4 sections. These will each be copied into the SpaDES module below, in their respective sections. We have added 1 new section, called “Prediction”.\nCode\nSpaDES.core::newModule(name = \"scheduling\", path = \"~/SpaDES_book/scheduling\")\nOpen the module file, which will be printed in the console. Scroll down to the Init function and copy the Init, the .inputObjects, and the Plot parts in the code above into the new module, as we did in Chapter 5.\nWe must make the same decisions about “local objects” (objects that are OK not to be kept for later) and about “global objects” (those that we want to keep). These global objects get put into sim. Your new module should have these 3 new sections/functions:\nCode\nInit &lt;- function(sim) {\n  y &lt;- sim$x + rnorm(10)\n  # fit a linear model\n  sim$out &lt;- lm(y ~ sim$x)\n  sim$pred &lt;- list()\n}\n\nplotFun &lt;- function(sim) {\n  sim$predictions &lt;- data.frame(year = rep(sim$years, each = 10), prediction = unlist(sim$pred))\n  # plot the predictions\n  sim$gg &lt;- ggplot(sim$predictions, aes(x = year, y = prediction, colour = year)) + geom_point() + geom_smooth()\n  print(sim$gg)\n}\n\n.inputObjects &lt;- function(sim) {\n  sim$x &lt;- rnorm(10)\n}",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#new-event-function-prediction",
    "href": "Scheduling.html#new-event-function-prediction",
    "title": "10  Scheduling Events",
    "section": "10.2 New Event Function – Prediction",
    "text": "10.2 New Event Function – Prediction\nThe new part is the for loop. This part takes new covariates (new values for y), emulating “predicted” covariates, and derives a newly predicted x, which we then keep as the predicted x values each year.\nWe’ll use scheduleEvent() below to do this iteration. For now, copy the Prediction part into a new function:\n\n\nCode\nPrediction &lt;- function(sim) {\n  startYear &lt;- 2023\n  sim$years &lt;- startYear:(startYear + 10) + 1\n  for (year in sim$years - startYear) {\n    sim$pred[[year]] &lt;- predict(sim$out, newdata = data.frame(y = rnorm(10) + year))\n  }\n  return(invisible(sim))\n}",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#scheduling",
    "href": "Scheduling.html#scheduling",
    "title": "10  Scheduling Events",
    "section": "10.3 Scheduling",
    "text": "10.3 Scheduling\nNow we need to tell SpaDES when to execute and when to iterate each of the steps or “events”. The Init we do once, at the start. The plotFn we do once, but this time it is at the “end”. The .inputObjects always only happens once and “before the start” (Init) – it is scheduled automatically so nothing to do here. The last part (i.e., the prediction event) must happen 10 times, and it must start after Init and before the plotFn.\n\n10.3.1 doEvent\nThere is a special function in a SpaDES module called doEvent(). SpaDES calls this function once, passing the argument event = \"init\". That means that R will enter into this function only once and run only the init part, unless we specifically tell it to do more, using the scheduleEvent function.\nWe place this function anywhere we want inside doEvent, in general. In this example, we will place it in a few places.\n\n10.3.1.1 In the init event\nWe look at the init event (code inside event = \"init\") and we see 2 scheduleEvent calls that come with the template. We will use those to learn. In each “event”, we often see one part that “does something” and another part that “schedules something”.\nIn the default template, we “do” the Init function and we schedule plot and save. We can delete the save event, as we won’t do that here. But we will replace it with “schedule prediction”.\nSee ?start, ?scheduleEventhttps://rdrr.io/cran/SpaDES.core/man/scheduleEvent.html, ?P\n\n\nCode\nsim &lt;- Init(sim)\n\n# schedule future event(s)\nsim &lt;- scheduleEvent(sim, P(sim)$.plotInitialTime, \"scheduling\", \"plot\")\n# sim &lt;- scheduleEvent(sim, P(sim)$.saveInitialTime, \"scheduling\", \"save\")\n\n# here we create a new event type == \"predictions\" and we schedule it for `start(sim)`\nsim &lt;- scheduleEvent(sim, start(sim), \"scheduling\", \"predictions\") \n\n\nCopy the above code chunk to the init section so that it looks like this:\n\n\nCode\nswitch(\n  eventType,\n  init = {\n    sim &lt;- Init(sim)\n    \n    # schedule future event(s)\n    sim &lt;- scheduleEvent(sim, P(sim)$.plotInitialTime, \"scheduling\", \"plot\")\n    \n    # here we create a new event type == \"predictions\" and we schedule it for `start(sim)`\n    sim &lt;- scheduleEvent(sim, start(sim), \"scheduling\", \"predictions\") \n  },\n  ...\n)\n\n\n\n\n\n10.3.2 The new event\nWe will add code to make a new event, called \"predictions\" (the name must match what we wrote in the scheduleEvent above). In this event, we “do” the prediction, then we schedule the next prediction at “time plus 1”\nSee ?SpaDES.core::times().\n\n\n\n\n\n\nTime in SpaDES\n\n\n\nIt is useful to understand time in SpaDES. Time has units (e.g., “year”) which is defined by the modules metadata timeunit. So, if time(sim) is 1 or 2024, that would be in year units, if the module is in year. To know what “time” it is in a module, the easiest function is time(sim). That will give you the “time”.\nTime, in SpaDES, is a way of ordering events. If one event happens at time 2024, and another event happens at 2025, then the 2024 event will happen first.\nThe other two useful functions are start(sim) and end(sim), which will give you the starting time of the spades call and ending time respectfully. These would have been specified in simInit.\n\n\n\n\nCode\nswitch(\n  eventType,\n  init = {...},\n  predictions = {\n    # do the Prediction\n    sim &lt;- Prediction(sim)\n    \n    # schedule the next Prediction\n    sim &lt;- scheduleEvent(sim, time(sim) + 1, \"scheduling\", \"predictions\") \n  },\n  ...\n)\n\n\n\n\n\n\n\n\nTop-down vs Bottom-up workflow sequencing\n\n\n\nIn a “top-down” workflow, we could imagine something like:\n\n\nCode\nscheduleEvent(sim, time(sim) + 1, \"predictions\")\nscheduleEvent(sim, time(sim) + 2, \"predictions\")\nscheduleEvent(sim, time(sim) + 3, \"predictions\")\n\n\nThis would schedule 3 predictions, during the next three “time steps”. This may be very clear, but it would be difficult to do this for dozens of years (could be done with a for-loop).\nA “bottom up” approach is to schedule the predictions event once, then each time that predictions event occurs, reschedule it.\n\n\nCode\ninit = {\n  scheduleEvent(sim, time(sim), \"predictions\")\n}\n\npredictions = {\n  scheduleEvent(sim, time(sim) + 1, \"predictions\")\n}\n\n\nEach time the predictions event happens, it will reschedule itself forever! Very simple. The workflow sequence emerges from the self-scheduling.\n\n\n\n\n10.3.3 Double check existing events\nIf we ran the above changes, we would see an error because plotFn is, by default, scheduled to run at the time that is specified by .plotInitialTime, which by default is start(sim). We have no data yet at that time. So, we will choose to schedule plotFn to run at end(sim):\n\n\nCode\nscheduleEvent(sim, end(sim), \"scheduling\", \"plot\")\n\n\n\n\n10.3.4 Update module metadata\nLike in Chapter 6, we have to update the module metadata… what the inputs, outputs, parameters are. SpaDES will not error if the metadata are not correct, but it will try to point out the problems.\nHere’s an example:\n\n\nCode\ncreatesOutput(objectName = \"predictions\", objectClass = \"data.frame\", \n              desc = \"Table of predictions and years\")",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#run",
    "href": "Scheduling.html#run",
    "title": "10  Scheduling Events",
    "section": "10.4 Run",
    "text": "10.4 Run\nThe resulting module can now be run.\n\n\nCode\nSpaDES.core::simInitAndSpades(modules = \"scheduling\", paths = list(modulePath = \"~/SpaDES_book/scheduling\"))\n\n\nA complete version of this new module can be found at scheduling.R. You can copy this over top of the new module that you created here, i.e., keep the same folder structure.",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#questions",
    "href": "Scheduling.html#questions",
    "title": "10  Scheduling Events",
    "section": "10.5 Questions",
    "text": "10.5 Questions\n\nhow are some ways that scheduleEvent is different from a “loop”?\n\nWe can change the “step” length between events.\nWe can interweave events, e.g., a fire event then a tree growth event\n\n\n\n\nWhen is a loop better than scheduling?\n\nLoops are much faster than scheduling.\nBut really, avoid loops in R if you can help it\n\n\n\n\nChances are that the first versions of this module didn’t work. How do you fix it?\n\nLearn how to debug in R and SpaDES",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#try-on-your-own",
    "href": "Scheduling.html#try-on-your-own",
    "title": "10  Scheduling Events",
    "section": "10.6 Try on your own",
    "text": "10.6 Try on your own\n\nTry creating a new parameter that controls the frequency of predictions.\nHere’s a clue:\npredictions = {\n  scheduleEvent(sim, time(sim) + P(sim)$predFreq, \"predictions\")\n}",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#see-also",
    "href": "Scheduling.html#see-also",
    "title": "10  Scheduling Events",
    "section": "10.7 See also",
    "text": "10.7 See also\nChapter 9 on Modules, Events and Functions\n?scheduleEvent\n?P\n?time\n?start\n?end",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#more-learning-on-this-subject",
    "href": "Scheduling.html#more-learning-on-this-subject",
    "title": "10  Scheduling Events",
    "section": "10.8 More learning on this subject",
    "text": "10.8 More learning on this subject\nMy First Module\nCreating a seed dispersal module",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "Scheduling.html#barebones-r-script",
    "href": "Scheduling.html#barebones-r-script",
    "title": "10  Scheduling Events",
    "section": "10.9 Barebones R script",
    "text": "10.9 Barebones R script\n\n\nCode\n# .inputObjects  #####\nx &lt;- rnorm(10)\n\n# Init #####\ny &lt;- x + rnorm(10)\n# fit a linear model\nout &lt;- lm(y ~ x)\npred &lt;- list()\n\n# Prediction #####\nstartYear &lt;- 2023\nyears &lt;- startYear:(startYear + 10) + 1\nfor (year in years - startYear) {\n  pred[[year]] &lt;- predict(out, newdata = data.frame(y = rnorm(10) + year))\n}\n\n# Plot #####\npredictions &lt;- data.frame(year = rep(years, each = 10), prediction = unlist(pred))\n# plot the predictions\nggplot(predictions, aes(x = year, y = prediction, colour = year)) + \n  geom_point() + geom_smooth()\n\nSpaDES.core::newModule(name = \"scheduling\", path = \"~/SpaDES_book/scheduling\")\n\nInit &lt;- function(sim) {\n  y &lt;- sim$x + rnorm(10)\n  # fit a linear model\n  sim$out &lt;- lm(y ~ sim$x)\n  sim$pred &lt;- list()\n}\n\nplotFun &lt;- function(sim) {\n  sim$predictions &lt;- data.frame(year = rep(sim$years, each = 10), prediction = unlist(sim$pred))\n  # plot the predictions\n  sim$gg &lt;- ggplot(sim$predictions, aes(x = year, y = prediction, colour = year)) + geom_point() + geom_smooth()\n  print(sim$gg)\n}\n\n.inputObjects &lt;- function(sim) {\n  sim$x &lt;- rnorm(10)\n}\n\nPrediction &lt;- function(sim) {\n  startYear &lt;- 2023\n  sim$years &lt;- startYear:(startYear + 10) + 1\n  for (year in sim$years - startYear) {\n    sim$pred[[year]] &lt;- predict(sim$out, newdata = data.frame(y = rnorm(10) + year))\n  }\n  return(invisible(sim))\n}\n\nsim &lt;- Init(sim)\n\n# schedule future event(s)\nsim &lt;- scheduleEvent(sim, P(sim)$.plotInitialTime, \"scheduling\", \"plot\")\n# sim &lt;- scheduleEvent(sim, P(sim)$.saveInitialTime, \"scheduling\", \"save\")\n\n# here we create a new event type == \"predictions\" and we schedule it for `start(sim)`\nsim &lt;- scheduleEvent(sim, start(sim), \"scheduling\", \"predictions\") \n\nswitch(\n  eventType,\n  init = {\n    sim &lt;- Init(sim)\n    \n    # schedule future event(s)\n    sim &lt;- scheduleEvent(sim, P(sim)$.plotInitialTime, \"scheduling\", \"plot\")\n    \n    # here we create a new event type == \"predictions\" and we schedule it for `start(sim)`\n    sim &lt;- scheduleEvent(sim, start(sim), \"scheduling\", \"predictions\") \n  },\n  ...\n)\n\nswitch(\n  eventType,\n  init = {...},\n  predictions = {\n    # do the Prediction\n    sim &lt;- Prediction(sim)\n    \n    # schedule the next Prediction\n    sim &lt;- scheduleEvent(sim, time(sim) + 1, \"scheduling\", \"predictions\") \n  },\n  ...\n)\n\nscheduleEvent(sim, time(sim) + 1, \"predictions\")\nscheduleEvent(sim, time(sim) + 2, \"predictions\")\nscheduleEvent(sim, time(sim) + 3, \"predictions\")\n\ninit = {\n  scheduleEvent(sim, time(sim), \"predictions\")\n}\n\npredictions = {\n  scheduleEvent(sim, time(sim) + 1, \"predictions\")\n}\n\nscheduleEvent(sim, end(sim), \"scheduling\", \"plot\")\n\ncreatesOutput(objectName = \"predictions\", objectClass = \"data.frame\", \n              desc = \"Table of predictions and years\")\n\nSpaDES.core::simInitAndSpades(modules = \"scheduling\", paths = list(modulePath = \"~/SpaDES_book/scheduling\"))",
    "crumbs": [
      "SpaDES 101",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Scheduling Events</span>"
    ]
  },
  {
    "objectID": "ContinuousWorkflows.html",
    "href": "ContinuousWorkflows.html",
    "title": "Working with Continuous Workflows",
    "section": "",
    "text": "SpaDES and Continuous Workflows\nSpaDES allows us to implement feature 3 (hierarchical caching) of Tip 1 because we can Cache at many levels: functions, events, modules, meta-modules, or entire projects. As we are developing inside a project, we can be working on a step inside a module that relies on previous “upstream” modules, but those modules can run very fast, so we can be quickly where we need to be, without breaking the workflow.\nThinking about this situation, we can now re-visit the idea of “Module Types” (introduced in 9.4 Module types) in terms of how they might depend on each other and certain types of inputs, and the types of outputs they produce.",
    "crumbs": [
      "Working with Continuous Workflows"
    ]
  },
  {
    "objectID": "ContinuousWorkflows.html#module-types-revisited",
    "href": "ContinuousWorkflows.html#module-types-revisited",
    "title": "Working with Continuous Workflows",
    "section": "Module Types (Revisited)",
    "text": "Module Types (Revisited)\nSpaDES doesn’t have an explicit module types. Rather, by convention, we associate different modules with generic things they do. A fairly comprehensive list of modules types that we create are:\n\nData Munging – uses prepInputs and outputs clean, usable data for a project, mostly specifies createsOutputs\nParameterization – uses data from e.g., a Data Munging module and uses statistics on data. This would be recognizable as a complete ecological study for publication.\nCalibration – similar to Parameterization but uses repeated simulation to estimate parameters.\nStudy Area specifics – creates outputs that are very idiosyncratic to a study area\nStatic Forecasting – creates outputs at different times, that are not used by itself\nDynamic Forecasting – creates outputs at different times, that are also its own inputs\nValidation – takes many repeated inputs, often many replicates\nVisualization – takes inputs from one or many replicated module runs and build rich visuals\nPost-Processing – takes inputs from one or many replicated module runs and builds data analytics. These may be similar to Validation\n\nThus, the differences are about how the inputObjects and outputObjects are specified and designed.\n\n\n\n\nJanssen, Marco A., Calvin Pritchard, and Allen Lee. 2020. “On Code Sharing and Model Documentation of Published Individual and Agent-Based Models.” Environmental Modelling & Software 134 (December): 104873. https://doi.org/10.1016/j.envsoft.2020.104873.\n\n\nSharma, Nitesh Kumar, Ram Ayyala, Dhrithi Deshpande, Yesha M Patel, Viorel Munteanu, Dumitru Ciorba, Andrada Fiscutean, et al. 2023. “Analytical Code Sharing Practices in Biomedical Research.” bioRxiv, August, 2023.07.31.551384. https://doi.org/10.1101/2023.07.31.551384.",
    "crumbs": [
      "Working with Continuous Workflows"
    ]
  },
  {
    "objectID": "Caching.html",
    "href": "Caching.html",
    "title": "11  Introduction to Cache",
    "section": "",
    "text": "11.1 How to use Cache\nThe Cache function can be used with any function. A user can wrap it around another function call or use the base pipe operator |&gt;. The following two calls are the same, and thus the 2nd one will result in the identical output to the first:\nCode\nlibrary(reproducible)\nreproducible::Cache(rnorm(1))\n\n\n[1] -2.121077\nattr(,\".Cache\")\nattr(,\".Cache\")$newCache\n[1] TRUE\n\nattr(,\"tags\")\n[1] \"cacheId:422bae4ed2f770cc\"\nattr(,\"call\")\n[1] \"\"\n\n\nCode\nrnorm(1) |&gt;\n  reproducible::Cache()\n\n\n[1] -2.121077\nattr(,\".Cache\")\nattr(,\".Cache\")$newCache\n[1] FALSE\n\nattr(,\"tags\")\n[1] \"cacheId:422bae4ed2f770cc\"\nattr(,\"call\")\n[1] \"\"\nSee ?reproducible::Cache for many more examples.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#when-to-use-cache",
    "href": "Caching.html#when-to-use-cache",
    "title": "11  Introduction to Cache",
    "section": "11.2 When to use Cache",
    "text": "11.2 When to use Cache\nThe most obvious case to use Cache is when the calculation is expensive. For example, GIS operations are commonly time consuming. In the example below, we will use terra::project three times, with timings.\n\n11.2.1 From disk\n\n\nCode\n# Data setup\nlibrary(terra)\ntmpDir &lt;- file.path(tempdir(), \"reproducible_examples\", \"Cache\")\ndir.create(tmpDir, recursive = TRUE)\nx &lt;- y &lt;- 2001\nras &lt;- terra::rast(terra::ext(0, x, 0, y), vals = sample(1:(x*y)), res = 1)\nterra::crs(ras) &lt;- \"+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +datum=WGS84\"\nnewCRS &lt;- \"+init=epsg:4326\" # A longlat crs\n\n# Call slow operation: project\n# No Cache\nsystem.time(map1 &lt;- terra::project(ras, newCRS)) # Warnings due to new PROJ\n\n\n   user  system elapsed \n   1.44    0.03    1.50 \n\n\nCode\n# With Cache -- a little slower the first time because saving to disk\nsystem.time(map2 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\n\n   user  system elapsed \n   5.66    0.16    5.90 \n\n\nCode\n# faster the second time; improvement depends on size of object and time to run function\nsystem.time(map3 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\n\n   user  system elapsed \n   0.61    0.05    0.68 \n\n\n\n\n11.2.2 From disk and memory\nWe can set an option so that objects will also be saved to disk as normal, but they will also be saved as RAM objects – “memoising”.\n\n\nCode\noptOrig &lt;- options(\"reproducible.useMemoise\" = TRUE)\nsystem.time(map4 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\n\n   user  system elapsed \n   0.37    0.08    0.46 \n\n\nCode\nsystem.time(map5 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\n\n   user  system elapsed \n   0.03    0.03    0.06 \n\n\nCode\noptions(optOrig)",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#caching-examples",
    "href": "Caching.html#caching-examples",
    "title": "11  Introduction to Cache",
    "section": "11.3 Caching examples",
    "text": "11.3 Caching examples\n\n11.3.1 Basic cache use with tags\nWe can add tags to identify the Cache call.\n\n\nCode\nranNumsA &lt;- Cache(rnorm, 4, userTags = c(\"random number generator\"))\n\nshowCache(userTags = \"random number generator\")\n\n\n             cacheId                  tagKey                   tagValue\n              &lt;char&gt;                  &lt;char&gt;                     &lt;char&gt;\n 1: ad0ea27476c50b66 random number generator    random number generator\n 2: ad0ea27476c50b66                function                      rnorm\n 3: ad0ea27476c50b66                   class                    numeric\n 4: ad0ea27476c50b66             object.size                       1008\n 5: ad0ea27476c50b66                accessed 2024-06-12 01:21:50.886574\n 6: ad0ea27476c50b66                 inCloud                      FALSE\n 7: ad0ea27476c50b66                fromDisk                      FALSE\n 8: ad0ea27476c50b66              resultHash                           \n 9: ad0ea27476c50b66       elapsedTimeDigest           0.003304958 secs\n10: ad0ea27476c50b66     elapsedTimeFirstRun          6.604195e-05 secs\n11: ad0ea27476c50b66          otherFunctions                    execute\n12: ad0ea27476c50b66          otherFunctions               process_file\n13: ad0ea27476c50b66          otherFunctions              process_group\n14: ad0ea27476c50b66          otherFunctions                 call_block\n15: ad0ea27476c50b66          otherFunctions                 block_exec\n16: ad0ea27476c50b66          otherFunctions                      eng_r\n17: ad0ea27476c50b66          otherFunctions               in_input_dir\n18: ad0ea27476c50b66          otherFunctions                     in_dir\n19: ad0ea27476c50b66          otherFunctions                  timing_fn\n20: ad0ea27476c50b66          otherFunctions                     handle\n21: ad0ea27476c50b66               preDigest         n:7eef4eae85fd9229\n22: ad0ea27476c50b66               preDigest      mean:c40c00762a0dac94\n23: ad0ea27476c50b66               preDigest        sd:853b1797f54b229c\n24: ad0ea27476c50b66               preDigest      .FUN:4f604aa46882b368\n             cacheId                  tagKey                   tagValue\n                   createdDate\n                        &lt;char&gt;\n 1: 2024-06-12 01:21:50.887097\n 2: 2024-06-12 01:21:50.887097\n 3: 2024-06-12 01:21:50.887097\n 4: 2024-06-12 01:21:50.887097\n 5: 2024-06-12 01:21:50.887097\n 6: 2024-06-12 01:21:50.887097\n 7: 2024-06-12 01:21:50.887097\n 8: 2024-06-12 01:21:50.887097\n 9: 2024-06-12 01:21:50.887097\n10: 2024-06-12 01:21:50.887097\n11: 2024-06-12 01:21:50.887097\n12: 2024-06-12 01:21:50.887097\n13: 2024-06-12 01:21:50.887097\n14: 2024-06-12 01:21:50.887097\n15: 2024-06-12 01:21:50.887097\n16: 2024-06-12 01:21:50.887097\n17: 2024-06-12 01:21:50.887097\n18: 2024-06-12 01:21:50.887097\n19: 2024-06-12 01:21:50.887097\n20: 2024-06-12 01:21:50.887097\n21: 2024-06-12 01:21:50.887097\n22: 2024-06-12 01:21:50.887097\n23: 2024-06-12 01:21:50.887097\n24: 2024-06-12 01:21:50.887097\n                   createdDate",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#clean-up-cache",
    "href": "Caching.html#clean-up-cache",
    "title": "11  Introduction to Cache",
    "section": "11.4 Clean up cache",
    "text": "11.4 Clean up cache\nWe can use either clearCache, keepCache, or cc to remove things from the Cache database. clearCache removes everything that matches the query. keepCache keeps everything that matches the query. cc removes the most recent entry (i.e., it is a shorthand for a commonly used option).\n\n\nCode\n# Two different funcxtions\na &lt;- rnorm(1) |&gt; Cache()\nb &lt;- runif(1) |&gt; Cache()\n\n# Clear only the first one\nclearCache(userTags = \"rnorm\", ask = FALSE)\na2 &lt;- rnorm(1) |&gt; Cache()\nb2 &lt;- runif(1) |&gt; Cache()\n\n# b2 and b are still identical; a and a2 are not\na == a2 # FALSE\n\n\n[1] FALSE\n\n\nCode\nb == b2 # TRUE\n\n\n[1] TRUE\n\n\nCode\n# This time keep ONLY the rnorm\nkeepCache(userTags = \"rnorm\", ask = FALSE)\n\n\n             cacheId              tagKey                   tagValue\n              &lt;char&gt;              &lt;char&gt;                     &lt;char&gt;\n 1: 422bae4ed2f770cc            function                      rnorm\n 2: 422bae4ed2f770cc               class                    numeric\n 3: 422bae4ed2f770cc         object.size                        984\n 4: 422bae4ed2f770cc            accessed 2024-06-12 01:21:51.014576\n 5: 422bae4ed2f770cc             inCloud                      FALSE\n 6: 422bae4ed2f770cc            fromDisk                      FALSE\n 7: 422bae4ed2f770cc          resultHash                           \n 8: 422bae4ed2f770cc   elapsedTimeDigest           0.002718925 secs\n 9: 422bae4ed2f770cc elapsedTimeFirstRun           7.70092e-05 secs\n10: 422bae4ed2f770cc      otherFunctions                    execute\n11: 422bae4ed2f770cc      otherFunctions               process_file\n12: 422bae4ed2f770cc      otherFunctions              process_group\n13: 422bae4ed2f770cc      otherFunctions                 call_block\n14: 422bae4ed2f770cc      otherFunctions                 block_exec\n15: 422bae4ed2f770cc      otherFunctions                      eng_r\n16: 422bae4ed2f770cc      otherFunctions               in_input_dir\n17: 422bae4ed2f770cc      otherFunctions                     in_dir\n18: 422bae4ed2f770cc      otherFunctions                  timing_fn\n19: 422bae4ed2f770cc      otherFunctions                     handle\n20: 422bae4ed2f770cc           preDigest         n:853b1797f54b229c\n21: 422bae4ed2f770cc           preDigest      mean:c40c00762a0dac94\n22: 422bae4ed2f770cc           preDigest        sd:853b1797f54b229c\n23: 422bae4ed2f770cc           preDigest      .FUN:4f604aa46882b368\n             cacheId              tagKey                   tagValue\n                   createdDate\n                        &lt;char&gt;\n 1: 2024-06-12 01:21:51.015111\n 2: 2024-06-12 01:21:51.015111\n 3: 2024-06-12 01:21:51.015111\n 4: 2024-06-12 01:21:51.015111\n 5: 2024-06-12 01:21:51.015111\n 6: 2024-06-12 01:21:51.015111\n 7: 2024-06-12 01:21:51.015111\n 8: 2024-06-12 01:21:51.015111\n 9: 2024-06-12 01:21:51.015111\n10: 2024-06-12 01:21:51.015111\n11: 2024-06-12 01:21:51.015111\n12: 2024-06-12 01:21:51.015111\n13: 2024-06-12 01:21:51.015111\n14: 2024-06-12 01:21:51.015111\n15: 2024-06-12 01:21:51.015111\n16: 2024-06-12 01:21:51.015111\n17: 2024-06-12 01:21:51.015111\n18: 2024-06-12 01:21:51.015111\n19: 2024-06-12 01:21:51.015111\n20: 2024-06-12 01:21:51.015111\n21: 2024-06-12 01:21:51.015111\n22: 2024-06-12 01:21:51.015111\n23: 2024-06-12 01:21:51.015111\n                   createdDate\n\n\nCode\na3 &lt;- rnorm(1) |&gt; Cache()\nb3 &lt;- runif(1) |&gt; Cache()\n\n# b2 and b are still identical; a and a2 are not\na2 == a3 # TRUE\n\n\n[1] TRUE\n\n\nCode\nb2 == b3 # FALSE\n\n\n[1] FALSE",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#nested-caching",
    "href": "Caching.html#nested-caching",
    "title": "11  Introduction to Cache",
    "section": "11.5 Nested Caching",
    "text": "11.5 Nested Caching\nNested caching is when Caching of a function occurs inside an outer function, which is itself cached. This is a critical element to working within a reproducible work flow. Ideally, at all points in a development cycle, it should be possible to get to any line of code starting from the very initial steps, running through everything up to that point, in less than a few seconds. If the workflow can be kept very fast like this, it will be very likely to work at any point it is tested.\nIn the example here, we run an outer function that calls an inner function. If we decide to change the outer function along the way, and the inner function is unaffected, then we can still recover the cached version of the inner call.\nWarning this will not necessarily work the other way, i.e., if inner is changed, we won’t notice until we clearCache and rerun.\n\n\nCode\n# Make 2 functions\ninner &lt;- function(mean) {\n  d &lt;- 1\n  Cache(rnorm(3, mean = mean))\n}\nouter &lt;- function(n) {\n  Cache(inner(0.1))\n}\n\n# Call outer function\nCache(outer(n = 2))\n\n\n[1] -0.4617438 -0.3278299 -0.5672069\nattr(,\".Cache\")\nattr(,\".Cache\")$newCache\n[1] TRUE\n\nattr(,\"tags\")\n[1] \"cacheId:aa5fa876944e27be\"\nattr(,\"call\")\n[1] \"\"\n\n\nCode\n# Change outer function\nouter &lt;- function(n) {\n  a &lt;- 0.1\n  Cache(inner(a))\n}\n\n# Still recovers inner \nCache(outer(n = 2))\n\n\n[1] -0.4617438 -0.3278299 -0.5672069\nattr(,\".Cache\")\nattr(,\".Cache\")$newCache\n[1] TRUE\n\nattr(,\"tags\")\n[1] \"cacheId:293cb55e4c25d110\"\nattr(,\"call\")\n[1] \"\"\n\n\nCode\n# BUT if we change the inner, it won't work\ninner &lt;- function(mean) {\n  d &lt;- 2                        # Changed d\n  Cache(rnorm(3, mean = mean))\n}\nCache(outer(n = 2))\n\n\n[1] -0.4617438 -0.3278299 -0.5672069\nattr(,\".Cache\")\nattr(,\".Cache\")$newCache\n[1] FALSE\n\nattr(,\"tags\")\n[1] \"cacheId:293cb55e4c25d110\"\nattr(,\"call\")\n[1] \"\"",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#best-practices",
    "href": "Caching.html#best-practices",
    "title": "11  Introduction to Cache",
    "section": "11.6 Best practices",
    "text": "11.6 Best practices\nIn general, we have found that use of Cache to be beneficial when used as following:\n\nSlow functions get cached. “Slow” can be “slower than using Cache”\nRegularly clearCache(ask = FALSE), e.g., at the end of a day or week of work, then let it run.\n\nSome of our team regularly add:\n\nIf using SpaDES, use cache at the event level, if the event is non-stochastic\nDon’t cache a simInit call – instead implement internal caching in the modules and use event caching. See vignette(topic = \"iii-cache\", package = \"SpaDES.core\")",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#see-also",
    "href": "Caching.html#see-also",
    "title": "11  Introduction to Cache",
    "section": "11.7 See also",
    "text": "11.7 See also\nSpaDES.core vignette on caching",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "Caching.html#barebones-r-script",
    "href": "Caching.html#barebones-r-script",
    "title": "11  Introduction to Cache",
    "section": "11.8 Barebones R script",
    "text": "11.8 Barebones R script\n\n\nCode\nlibrary(reproducible)\nreproducible::Cache(rnorm(1))\n\nrnorm(1) |&gt;\n  reproducible::Cache()\n\n# Data setup\nlibrary(terra)\ntmpDir &lt;- file.path(tempdir(), \"reproducible_examples\", \"Cache\")\ndir.create(tmpDir, recursive = TRUE)\nx &lt;- y &lt;- 2001\nras &lt;- terra::rast(terra::ext(0, x, 0, y), vals = sample(1:(x*y)), res = 1)\nterra::crs(ras) &lt;- \"+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +datum=WGS84\"\nnewCRS &lt;- \"+init=epsg:4326\" # A longlat crs\n\n# Call slow operation: project\n# No Cache\nsystem.time(map1 &lt;- terra::project(ras, newCRS)) # Warnings due to new PROJ\n\n# With Cache -- a little slower the first time because saving to disk\nsystem.time(map2 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\n# faster the second time; improvement depends on size of object and time to run function\nsystem.time(map3 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\noptOrig &lt;- options(\"reproducible.useMemoise\" = TRUE)\nsystem.time(map4 &lt;- terra::project(ras, newCRS) |&gt; Cache())\n\nsystem.time(map5 &lt;- terra::project(ras, newCRS) |&gt; Cache())\noptions(optOrig)\n\nranNumsA &lt;- Cache(rnorm, 4, userTags = c(\"random number generator\"))\n\nshowCache(userTags = \"random number generator\")\n\n# Two different funcxtions\na &lt;- rnorm(1) |&gt; Cache()\nb &lt;- runif(1) |&gt; Cache()\n\n# Clear only the first one\nclearCache(userTags = \"rnorm\", ask = FALSE)\na2 &lt;- rnorm(1) |&gt; Cache()\nb2 &lt;- runif(1) |&gt; Cache()\n\n# b2 and b are still identical; a and a2 are not\na == a2 # FALSE\nb == b2 # TRUE\n\n# This time keep ONLY the rnorm\nkeepCache(userTags = \"rnorm\", ask = FALSE)\na3 &lt;- rnorm(1) |&gt; Cache()\nb3 &lt;- runif(1) |&gt; Cache()\n\n# b2 and b are still identical; a and a2 are not\na2 == a3 # TRUE\nb2 == b3 # FALSE\n\n# Make 2 functions\ninner &lt;- function(mean) {\n  d &lt;- 1\n  Cache(rnorm(3, mean = mean))\n}\nouter &lt;- function(n) {\n  Cache(inner(0.1))\n}\n\n# Call outer function\nCache(outer(n = 2))\n\n# Change outer function\nouter &lt;- function(n) {\n  a &lt;- 0.1\n  Cache(inner(a))\n}\n\n# Still recovers inner \nCache(outer(n = 2))\n\n# BUT if we change the inner, it won't work\ninner &lt;- function(mean) {\n  d &lt;- 2                        # Changed d\n  Cache(rnorm(3, mean = mean))\n}\nCache(outer(n = 2))",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction to Cache</span>"
    ]
  },
  {
    "objectID": "prepInputs.html",
    "href": "prepInputs.html",
    "title": "12  reproducible::prepInputs for Data",
    "section": "",
    "text": "12.1 prepInputs\nThis function can be used to prepare R objects from remote or local data sources. The object of this function is to provide a reproducible version of a series of commonly used steps for getting, loading, and processing data.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#simplest-case-a-url",
    "href": "prepInputs.html#simplest-case-a-url",
    "title": "12  reproducible::prepInputs for Data",
    "section": "12.2 Simplest case: a url",
    "text": "12.2 Simplest case: a url\nIf we can point directly to a file on a cloud location, prepInputs does its thing, getting the local file.\n\n\nCode\nRequire::Require(c(\"terra\", \"reproducible\"), \n                 repos = c(getOption(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))))\nurl &lt;- \"https://github.com/tati-micheletti/host/raw/master/data/rasterTest.tif\"\nras &lt;- prepInputs(url = url, destinationPath = \"~/SpaDES_book/data/prepInputs\")\n\nterra::plot(ras)",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#case-in-an-archive-like-zip",
    "href": "prepInputs.html#case-in-an-archive-like-zip",
    "title": "12  reproducible::prepInputs for Data",
    "section": "12.3 Case: in an archive (like zip)",
    "text": "12.3 Case: in an archive (like zip)\nOften, cloud-stored files are in an archive, like a zip or tar.gz. These can be handled automatically with prepInputs. By default, it will try to extract all files from the archive, and load one of them into R:\n\n\nCode\nurl &lt;- \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\"\nshpEcozone &lt;- prepInputs(url = url, destinationPath = \"~/SpaDES_book/data/prepInputs\")\nterra::plot(shpEcozone[1])",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#case-local-stash-using-reproducible.inputpaths",
    "href": "prepInputs.html#case-local-stash-using-reproducible.inputpaths",
    "title": "12  reproducible::prepInputs for Data",
    "section": "12.4 Case: local stash using reproducible.inputPaths",
    "text": "12.4 Case: local stash using reproducible.inputPaths\nIf we want to use the same file in many projects, we can obviously just download it again in each project, using the same lines of prepInputs. However, we can setup a local “stash” of data files. This is a set it and forget it option in reproducible.\n\n\nCode\noptions(reproducible.inputPaths = \"~/data\")\nurl &lt;- \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\"\nshpEcozone &lt;- prepInputs(url = url, destinationPath = \"~/SpaDES_book/data/prepInputs\")\nterra::plot(shpEcozone[1])\n\n\nIf we run this chunk in the same project, results will be like the previous chunk: a vector dataset from the Canadian federal government. BUT, if we run it in a different project, it will check the stashed diretory and won’t need to download it again. Moreover, it will not actually make a copy but a link to the file, so it won’t take extra space on your hard drive.\nIf you are running in a *nix-like system (Mac, Linux, etc.) or you have Git Bash installed, you can see the number of links to a file with ls. The column after the attributes (e.g., drwxr-xr-x), is the number of pointers to a file. Anything more than 1 means that there are several pointers.\nsystem(paste0(\"ls -l\", getOption(\"inputPaths\")))",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#stages-of-prepinputs",
    "href": "prepInputs.html#stages-of-prepinputs",
    "title": "12  reproducible::prepInputs for Data",
    "section": "12.5 Stages of prepInputs",
    "text": "12.5 Stages of prepInputs\nThis function has three stages, using three internal functions:\n\nreproducible::preProcess which is getting data (download, extracting from archives, checksumming)\nreproducible::process – load the data into R (note: user can’t access this directly)\nreproducible::postProcessTo (for Spatial* and Raster* objects, this is crop, reproject, mask/intersect).\n\npreProcess will be run, if a user supplies url or archive. process will be run if fun is not NA. It will try to guess fun based on file type if fun is left at the default of NULL. postProcess will be triggered if the user passes any of the arguments of postProcessTo (to, maskTo, cropTo) studyArea or rasterToMatch.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#with-gis",
    "href": "prepInputs.html#with-gis",
    "title": "12  reproducible::prepInputs for Data",
    "section": "12.6 With GIS",
    "text": "12.6 With GIS\nThe data we download may cover a larger area than our study needs. For example, there may be a provincial or national dataset, but we are only using a part of that. If we create a studyArea, we can use this as part of prepInputs, passing it to to or one of the other *to functions.\n\n12.6.1 Vector data\nThe following will get the national ecozone map, project, crop and mask it to the SK dataset.\n\n\nCode\nSK &lt;- SpaDES.project::setupStudyArea(list(level = 2, NAME_1 = \"Saskatchewan\"))\nshpEcozoneSK &lt;- prepInputs(\n  url = \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\",\n  to = SK, destinationPath = \"~/SpaDES_book/data/prepInputs\"\n)\nterra::plot(shpEcozoneSK[1])\n\n\n\n\n12.6.2 Raster data\nThe following will get a national DEM layer, crop and mask it to the SK dataset. We leave it in the projection it came in at the original source.\n\n\nCode\nurlTif1 &lt;- \"https://geodata.ucdavis.edu/geodata/elv/CAN_elv_msk.zip\"\n# Turns out the previous steps (original data or postProccessed) have an error\ntry(DEMSK &lt;- prepInputs(\n  url = urlTif1,\n  maskTo = shpEcozoneSK, \n  cropTo = shpEcozoneSK,\n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n))\n\nshpEcozoneSK &lt;- fixErrorsIn(shpEcozoneSK)\n# Rerun\nDEMSK &lt;- prepInputs(\n  url = urlTif1,\n  cropTo = shpEcozoneSK,\n  maskTo = shpEcozoneSK, \n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n)\n\nterra::plot(DEMSK)\nterra::plot(shpEcozoneSK[1], add = TRUE, col = \"transparent\")\n\n\nOf course, we may do many other things, including change the resolution of the downloaded object, change the projection, and resolution. prepInputs uses a template raster to know what to project, crop, and mask to\n\n\nCode\nSK &lt;- SpaDES.project::setupStudyArea(list(level = 2, NAME_1 = \"Saskatchewan\", epsg = 5070))\nSKras &lt;- terra::rast(terra::ext(SK), res = 250, val = 1)\nterra::crs(SKras) &lt;- terra::crs(SK)\n\nDEMSK250m &lt;- prepInputs(\n  url = urlTif1,\n  to = SKras,                   # &lt;-   template raster\n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n)\nterra::plot(DEMSK250m)\n\n\nSo, we can easily put these prepInputs calls in our workflows, in any project, with minimal new effort each time.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#caching",
    "href": "prepInputs.html#caching",
    "title": "12  reproducible::prepInputs for Data",
    "section": "12.7 Caching",
    "text": "12.7 Caching\nprepInputs is friendly with Cache. In addition to the local stashing of a file, the GIS itself may take a long time. We can just |&gt; Cache() at the end and we have a workflow that doesn’t need to be broken.\n\n\nCode\nDEMSK250m &lt;- prepInputs(\n  url = urlTif1,\n  to = SKras, \n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n) |&gt; \n  Cache()\n\n# run later... very fast\nDEMSK250m &lt;- prepInputs(\n  url = urlTif1,\n  to = SKras, \n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n) |&gt; \n  Cache()",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#extending-prepinputs-with-fun",
    "href": "prepInputs.html#extending-prepinputs-with-fun",
    "title": "12  reproducible::prepInputs for Data",
    "section": "12.8 Extending prepInputs with fun",
    "text": "12.8 Extending prepInputs with fun\nIt is impossible for prepInputs to be able to handle all data capturing cases. When customization is needed, a few options are possible.\n\nMake a custom fun argument. Optionally, dlFun can be used to specify how to download the data.\nMake a custom prepInputs_XXX function that calls prepInputs internally.\n\nThe following example uses a custom fun. These examples are fast, so the benefits of caching won’t be as apparent as for when more complex GIS operations are needed, e.g. reprojecting large raster datasets.\n\n\nCode\nLuxembourgFull &lt;- prepInputs(\n dlFun =\n   geodata::gadm(name = \"GADM\", country = \"LUX\", level = 0, path = \"~/SpaDES_book/prepInputs\") # preProcess keeps file from this!\n) |&gt; Cache()\n\nLuxembourgInnerBuffer &lt;- prepInputs(\n  dlFun =\n    geodata::gadm(name = \"GADM\", country = \"LUX\", level = 0, path = \"~/SpaDES_book/prepInputs\") # preProcess keeps file from this!\n  ,\n  fun = {                      # Custom function\n    out &lt;- readRDS(targetFile)\n    out &lt;- terra::vect(out)\n    terra::buffer(out, 5000)\n  }\n) |&gt; Cache()\n\nterra::plot(LuxembourgInnerBuffer)\nterra::plot(Luxembourg, add = TRUE)\n\n\nBy rerunning the previous code, the caching will be in effect. This means that the slow, two-or-more-stage processes of downloading, custom operations, and possibly GIS using `to functions can all be Cached in a single step, resulting in the smallest possible output being saved, i.e., intermediate large objects have only limited “saving”.\nNOTE: Rmarkdown and Quarto both have a form of caching of chunks. This can be effective in some circumstances, but it is somewhat limited (as are all forms of Caching – they will hit their limits somewhere). For instance, they do not deal with the pointers of C++ objects in terra.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#see-also",
    "href": "prepInputs.html#see-also",
    "title": "12  reproducible::prepInputs for Data",
    "section": "12.9 See also",
    "text": "12.9 See also\nThere are many other elements of this function that can be effectively used.\nreproducible::prepInputs\nreproducible::preProcess\nreproducible::postProcessTo",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "prepInputs.html#barebones-r-script",
    "href": "prepInputs.html#barebones-r-script",
    "title": "12  reproducible::prepInputs for Data",
    "section": "12.10 Barebones R script",
    "text": "12.10 Barebones R script\n\n\nCode\nRequire::Require(c(\"terra\", \"reproducible\"), \n                 repos = c(getOption(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))))\nurl &lt;- \"https://github.com/tati-micheletti/host/raw/master/data/rasterTest.tif\"\nras &lt;- prepInputs(url = url, destinationPath = \"~/SpaDES_book/data/prepInputs\")\n\nterra::plot(ras)\n\nurl &lt;- \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\"\nshpEcozone &lt;- prepInputs(url = url, destinationPath = \"~/SpaDES_book/data/prepInputs\")\nterra::plot(shpEcozone[1])\n\noptions(reproducible.inputPaths = \"~/data\")\nurl &lt;- \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\"\nshpEcozone &lt;- prepInputs(url = url, destinationPath = \"~/SpaDES_book/data/prepInputs\")\nterra::plot(shpEcozone[1])\n\nSK &lt;- SpaDES.project::setupStudyArea(list(level = 2, NAME_1 = \"Saskatchewan\"))\nshpEcozoneSK &lt;- prepInputs(\n  url = \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\",\n  to = SK, destinationPath = \"~/SpaDES_book/data/prepInputs\"\n)\nterra::plot(shpEcozoneSK[1])\n\nurlTif1 &lt;- \"https://geodata.ucdavis.edu/geodata/elv/CAN_elv_msk.zip\"\n# Turns out the previous steps (original data or postProccessed) have an error\ntry(DEMSK &lt;- prepInputs(\n  url = urlTif1,\n  maskTo = shpEcozoneSK, \n  cropTo = shpEcozoneSK,\n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n))\n\nshpEcozoneSK &lt;- fixErrorsIn(shpEcozoneSK)\n# Rerun\nDEMSK &lt;- prepInputs(\n  url = urlTif1,\n  cropTo = shpEcozoneSK,\n  maskTo = shpEcozoneSK, \n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n)\n\nterra::plot(DEMSK)\nterra::plot(shpEcozoneSK[1], add = TRUE, col = \"transparent\")\n\nSK &lt;- SpaDES.project::setupStudyArea(list(level = 2, NAME_1 = \"Saskatchewan\", epsg = 5070))\nSKras &lt;- terra::rast(terra::ext(SK), res = 250, val = 1)\nterra::crs(SKras) &lt;- terra::crs(SK)\n\nDEMSK250m &lt;- prepInputs(\n  url = urlTif1,\n  to = SKras,                   # &lt;-   template raster\n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n)\nterra::plot(DEMSK250m)\n\nDEMSK250m &lt;- prepInputs(\n  url = urlTif1,\n  to = SKras, \n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n) |&gt; \n  Cache()\n\n# run later... very fast\nDEMSK250m &lt;- prepInputs(\n  url = urlTif1,\n  to = SKras, \n  destinationPath = \"~/SpaDES_book/data/prepInputs\"\n) |&gt; \n  Cache()\n\nLuxembourgFull &lt;- prepInputs(\n dlFun =\n   geodata::gadm(name = \"GADM\", country = \"LUX\", level = 0, path = \"~/SpaDES_book/prepInputs\") # preProcess keeps file from this!\n) |&gt; Cache()\n\nLuxembourgInnerBuffer &lt;- prepInputs(\n  dlFun =\n    geodata::gadm(name = \"GADM\", country = \"LUX\", level = 0, path = \"~/SpaDES_book/prepInputs\") # preProcess keeps file from this!\n  ,\n  fun = {                      # Custom function\n    out &lt;- readRDS(targetFile)\n    out &lt;- terra::vect(out)\n    terra::buffer(out, 5000)\n  }\n) |&gt; Cache()\n\nterra::plot(LuxembourgInnerBuffer)\nterra::plot(Luxembourg, add = TRUE)",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>`reproducible::prepInputs` for Data</span>"
    ]
  },
  {
    "objectID": "debugging.html",
    "href": "debugging.html",
    "title": "13  Debugging SpaDES Modules",
    "section": "",
    "text": "13.1 Debugging with browser()\nbrowser() calls are very useful when you have access to the source code. When inserted inside a function, they will interrupt code execution at that point and allow the user to “enter” the function’s environment in debugging mode – i.e. they will have access to all the objects the function has access to internally.\nLet’s define a simple function and then use it improperly.\nCode\nmyFun &lt;- function(x, y) {\n  out &lt;- sum(x, y)\n  return(out)\n}\n\nmyFun(runif(20), \"A\")\nBecause we have the source code, we can:\nCode\nmyFun &lt;- function(x, y) {\n  browser()\n  out &lt;- sum(x, y)\n  return(out)\n}\n\nmyFun(runif(20), \"A\")\nCode\n# &gt; myFun(runif(20), \"A\")\n# Called from: myFun(runif(20), \"A\")\n# Browse[1]&gt; x\n#  [1] 0.48059327 0.12201652 0.39367787 0.91989186 0.04872701 0.85632846 0.05945062 0.87683559 0.58599446 0.10403352 0.49429023\n#  [12] 0.69785397 0.19622413 0.05559181 0.20329131 0.14909383 0.61400844 0.73638292 0.21185129 0.72534305\n# Browse[1]&gt; y\n#  [1] \"A\"\nFrom the above we would quickly realise we were trying to add a numeric vector with a character vector, which obviously doesn’t work.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "debugging.html#debugging-with-browser",
    "href": "debugging.html#debugging-with-browser",
    "title": "13  Debugging SpaDES Modules",
    "section": "",
    "text": "13.1.1 browser() with a SpaDES module\nGo back to the module My_linear_model created in Chapter 5 and insert a browser() in the init event, save the module and run again.\n\n\nCode\ndoEvent.My_linear_model.init &lt;- function(sim, eventTime, eventType, priority) {\n    browser()\n    x &lt;- rnorm(10)\n    y &lt;- x + rnorm(10)\n    sim$model &lt;- lm(y ~ x)  \n    return(sim)\n}\n\n\nIf you are using RStudio, it probably opened the module .R script (if not try right-clicking the RStudio window and selecting “Reload”), showing a highlighted browser() line. The R console shows:\n\n\nCode\nout &lt;- simInit(modules = nm1, paths = list(modulePath = modulePath))\nout &lt;- spades(out)\n\n\n\n\nCode\n# No packages to install/update\n# Jun09 00:03:51 simInit Resetting .Random.seed of session because sim$._randomSeed is not NULL. To get a different seed, run: sim$._randomSeed &lt;- NULL to clear it.\n# Jun09 00:03:51 simInit Using setDTthreads(1). To change: 'options(spades.DTthreads = X)'.\n# Jun09 00:03:51 chckpn:init total elpsd: 21 secs | 0 checkpoint init 0\n# Jun09 00:03:51 save  :init total elpsd: 21 secs | 0 save init 0\n# Jun09 00:03:51 prgrss:init total elpsd: 21 secs | 0 progress init 0\n# Jun09 00:03:51 load  :init total elpsd: 21 secs | 0 load init 0\n# Jun09 00:03:51 My_lnr:init total elpsd: 21 secs | 0 My_linear_model init 1\n# Called from: get(moduleCall, envir = fnEnv)(sim, cur[[\"eventTime\"]], cur[[\"eventType\"]])\n\n\nUse ls() to see what objects are in the function environment, then execute code line-by-line with ENTER, F10 or the “Next” button.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "debugging.html#debugging-with-debug-and-debugonce",
    "href": "debugging.html#debugging-with-debug-and-debugonce",
    "title": "13  Debugging SpaDES Modules",
    "section": "13.2 Debugging with debug() and debugonce()",
    "text": "13.2 Debugging with debug() and debugonce()\nIf we don’t have access to the function code (or don’t want to insert a browser()) we can use debug() and debugonce(). The effect will be similar to having a browser() in the first line of a function’s definition.\nHere’s an example:\n\n\nCode\ndebugonce(\"time\")\n\ntime(out) ## then press ENTER to execute each line of code one-by-one\n\n\nundebug(&lt;function_name&gt;) will de-activate debugging for that function.\n\n13.2.1 debugonce() and debug() with a SpaDES module\nThe process would be similar in a module, with the difference that the debug()/debugonce() call would either happen before running the module with spades(), OR from within the module in debugging mode.\n\n\n\n\n\n\nIf debugging module functions, they might not be easily available from the .GlobalEnv since they “live” inside the simList.\nThe easiest way to debug module functions is to\n\nInsert a browser() in that function\n\nOR\n\nInsert a browser() in the module, before the function is called\nCall debugonce(\"&lt;function_name&gt;\")/debug(\"&lt;function_name&gt;\")\nProceed to executing the function\n\n\n\n\nLet’s try it:\n\nExit browser() mode (e.g., enter Q in the R console)\nRemove the browser() from My_linear_model\nRun debugonce(\"lm\").\nRun the simInit() + spades() lines again to re-source module code and run the module OR run restartSpades() which will re-parse the module code and resume the workflow from the top of the event that was interrupted (the init).\n\nWhat objects does ls() show now?\n\nExit debugging mode again\nRe-run restartSpades()\n\nAre you back in debugging mode?\n\n\nNow go through steps 1-6 again, but replace debugonce(\"lm\") with debug(\"lm\") in step 3. What happened in step 6. this time?\n\n\n\n\n\n\nIf debugging functions that are S4 objects, you may need to be aware of which method needs to be debugged before calling debug or debugOnce.\nTry showMethods(\"show\") to see all the methods implemented.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "debugging.html#restartspades",
    "href": "debugging.html#restartspades",
    "title": "13  Debugging SpaDES Modules",
    "section": "13.3 restartSpades()",
    "text": "13.3 restartSpades()\nProbably one of our BFFs (best-friend functions) as SpaDES developpers, it will allow resuming a workflow whose execution was interrupted by an error or the user from the top of the interrupted event, but will first re-parse module code.\nThis means that we can insert a browser() somewhere in the event code, then restartSpades() and debug the event.",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "debugging.html#try-on-your-own",
    "href": "debugging.html#try-on-your-own",
    "title": "13  Debugging SpaDES Modules",
    "section": "13.4 Try on your own",
    "text": "13.4 Try on your own\n\nTry to debug the first method of the function show(). Here’s a tip: start with showMethods(\"show\").",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "debugging.html#see-also",
    "href": "debugging.html#see-also",
    "title": "13  Debugging SpaDES Modules",
    "section": "13.5 See also",
    "text": "13.5 See also\n?browser()\n?debug()\n?restartSpades()\n?showMethods() – useful to find out what methods of a function you may want to activate debugging for\nAn example of debugging a more complex SpaDES workflow in Section 15.5\nDebugging – Advanced R\nHow to make a reprex",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "debugging.html#barebones-r-script",
    "href": "debugging.html#barebones-r-script",
    "title": "13  Debugging SpaDES Modules",
    "section": "13.6 Barebones R script",
    "text": "13.6 Barebones R script\n\n\nCode\nmyFun &lt;- function(x, y) {\n  out &lt;- sum(x, y)\n  return(out)\n}\n\nmyFun(runif(20), \"A\")\n\nmyFun &lt;- function(x, y) {\n  browser()\n  out &lt;- sum(x, y)\n  return(out)\n}\n\nmyFun(runif(20), \"A\")\n\n\n\n\n\nout &lt;- simInit(modules = nm1, paths = list(modulePath = modulePath))\nout &lt;- spades(out)\n\n\n\ndebugonce(\"time\")\n\ntime(out) ## then press ENTER to execute each line of code one-by-one",
    "crumbs": [
      "Working with Continuous Workflows",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Debugging SpaDES Modules</span>"
    ]
  },
  {
    "objectID": "setupProject.html",
    "href": "setupProject.html",
    "title": "SpaDES workflows and projects",
    "section": "",
    "text": "Some of the SpaDES-verse\nWe can see many of the known modules in the SpaDES-verse and how they interact through their shared inputs and outputs in this interactive figure:\nShow the code\nRequire::Install(c(\"igraph\", \"visNetwork\"))\n\nmodPath &lt;- \"~/SpaDES_book/listModules/\"\naccountsListLong &lt;- c(\"PredictiveEcology\", \"ianmseddy\", \"achubaty\",\n                       \"FOR-CAST\", \"eliotmcintire\", \"tati-micheletti\", \"CeresBarros\")\ngrepListLong &lt;- c(\"Biomass\", \"WBI\", \"LandR\", \"fireSense\", \"CBM\",\n                  \"LandMine\", \"LandWeb\", \"NRV\", #\"scfm\",\n                  \"priority\", \"fire\",\n                  \"dataPrep\", \"DataPrep\", \"RoF\", \"Ontario\", \"ROF\")\nmodsLong &lt;- SpaDES.project::listModules(grepListLong, accounts = accountsListLong,\n                                        excludeStale = FALSE)\nmodsLong &lt;- paste0(modsLong, \"@HEAD\")\n\n# downloads lots of modules\nmods &lt;- SpaDES.project::getModule(modsLong, modulePath = modPath)\n\nDT &lt;- SpaDES.project::moduleDependencies(modsLong, modulePath = modPath)\ngraph &lt;- SpaDES.project::moduleDependenciesToGraph(DT)\n(vn &lt;- SpaDES.project::PlotModuleGraph(graph))\nWe also sometimes represent these as hexes, following the R-package convention:\nThe idea with setupProject is that we can start weaving different groups of modules together. This is what we will do in the next sections.",
    "crumbs": [
      "SpaDES workflows and projects"
    ]
  },
  {
    "objectID": "workflowSimple2.html",
    "href": "workflowSimple2.html",
    "title": "14  Workflows with setupProject",
    "section": "",
    "text": "14.1 SpaDES.project::setupProject\nhttps://spades-project.predictiveecology.org/articles/i-getting-started.html",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "workflowSimple2.html#installation",
    "href": "workflowSimple2.html#installation",
    "title": "14  Workflows with setupProject",
    "section": "14.2 Installation",
    "text": "14.2 Installation\n\n\nCode\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\n# if (!require(\"SpaDES.project\"))\nRequire::Install(c(\"SpaDES.project\", \"SpaDES.core\", \"reproducible\"), repos = repos, dependencies = TRUE)\n\npackagePath = SpaDES.project::.libPathDefault(\"~/SpaDES_book/integratingSpaDESmodules\")\n\n\n\n\nCode\npackagePath = SpaDES.project::.libPathDefault(\"PredictiveEcology.org\")",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "workflowSimple2.html#using-setupproject",
    "href": "workflowSimple2.html#using-setupproject",
    "title": "14  Workflows with setupProject",
    "section": "14.3 Using setupProject",
    "text": "14.3 Using setupProject\nsetupProject does a series of very specific things, in a particular order, so that the chances of package conflicts and user errors are minimized.\nNote how it downloads the listed modules directly from their GitHub repositories (e.g. tati-micheletti/speciesAbundance)\n\n\nCode\n##################### PART II: Download the modules and install the needed packages\nSetup &lt;- SpaDES.project::setupProject(\n  \n  paths = list(projectPath = \"~/SpaDES_book/integratingSpaDESmodules\",\n               packagePath = packagePath),\n  \n  modules = c(\"tati-micheletti/speciesAbundance@main\",\n              \"tati-micheletti/temperature@main\",\n              \"tati-micheletti/speciesAbundTempLM@main\"),\n  \n  times = list(start = 2013,\n               end = 2030),\n  \n  updateRprofile = FALSE\n  \n)\n\n\nThe output of setupProject is a list of argument values that can be passed to simInitAndSpaDES2 (with the “2” it accepts a list of arguments, instead of the arguments themselves).\n\n\nCode\nresults &lt;- SpaDES.core::simInitAndSpades2(Setup)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "workflowSimple2.html#emergent-workflow",
    "href": "workflowSimple2.html#emergent-workflow",
    "title": "14  Workflows with setupProject",
    "section": "14.4 Emergent workflow",
    "text": "14.4 Emergent workflow\nWe can evaluate the sequence of events using completed\n\n\nCode\nSpaDES.core::completed(results)\n\n\n    eventTime         moduleName            eventType eventPriority\n        &lt;num&gt;             &lt;char&gt;               &lt;char&gt;         &lt;num&gt;\n 1:      2013         checkpoint                 init             0\n 2:      2013               save                 init             0\n 3:      2013           progress                 init             0\n 4:      2013               load                 init             0\n 5:      2013   speciesAbundance                 init             1\n 6:      2013        temperature                 init             1\n 7:      2013 speciesAbundTempLM                 init             1\n 8:      2013   speciesAbundance       tableToRasters             5\n 9:      2013   speciesAbundance                 plot             5\n10:      2013        temperature         dataToRaster             5\n11:      2013        temperature             plotting             5\n12:      2013 speciesAbundTempLM        tableBuilding             5\n13:      2014   speciesAbundance       tableToRasters             5\n14:      2014        temperature         dataToRaster             5\n15:      2014 speciesAbundTempLM        tableBuilding             5\n16:      2015   speciesAbundance       tableToRasters             5\n17:      2015        temperature         dataToRaster             5\n18:      2015 speciesAbundTempLM        tableBuilding             5\n19:      2016   speciesAbundance       tableToRasters             5\n20:      2016        temperature         dataToRaster             5\n21:      2016 speciesAbundTempLM        tableBuilding             5\n22:      2017   speciesAbundance       tableToRasters             5\n23:      2017        temperature         dataToRaster             5\n24:      2017 speciesAbundTempLM        tableBuilding             5\n25:      2018   speciesAbundance                 plot             5\n26:      2018   speciesAbundance       tableToRasters             5\n27:      2018        temperature         dataToRaster             5\n28:      2018 speciesAbundTempLM        tableBuilding             5\n29:      2019   speciesAbundance       tableToRasters             5\n30:      2019        temperature         dataToRaster             5\n31:      2019 speciesAbundTempLM        tableBuilding             5\n32:      2020   speciesAbundance       tableToRasters             5\n33:      2020        temperature         dataToRaster             5\n34:      2020 speciesAbundTempLM        tableBuilding             5\n35:      2021   speciesAbundance       tableToRasters             5\n36:      2021        temperature         dataToRaster             5\n37:      2021 speciesAbundTempLM        tableBuilding             5\n38:      2022   speciesAbundance       tableToRasters             5\n39:      2022        temperature         dataToRaster             5\n40:      2022 speciesAbundTempLM        tableBuilding             5\n41:      2023        temperature             plotting             5\n42:      2023        temperature         dataToRaster             5\n43:      2023 speciesAbundTempLM        tableBuilding             5\n44:      2023 speciesAbundTempLM        modelBuilding             5\n45:      2023 speciesAbundTempLM abundanceForecasting             5\n46:      2023 speciesAbundTempLM                 plot             5\n47:      2024        temperature         dataToRaster             5\n48:      2024 speciesAbundTempLM abundanceForecasting             5\n49:      2024 speciesAbundTempLM                 plot             5\n50:      2025        temperature         dataToRaster             5\n51:      2025 speciesAbundTempLM abundanceForecasting             5\n52:      2025 speciesAbundTempLM                 plot             5\n53:      2026        temperature         dataToRaster             5\n54:      2026 speciesAbundTempLM abundanceForecasting             5\n55:      2026 speciesAbundTempLM                 plot             5\n56:      2027        temperature         dataToRaster             5\n57:      2027 speciesAbundTempLM abundanceForecasting             5\n58:      2027 speciesAbundTempLM                 plot             5\n59:      2028        temperature         dataToRaster             5\n60:      2028 speciesAbundTempLM abundanceForecasting             5\n61:      2028 speciesAbundTempLM                 plot             5\n62:      2029        temperature         dataToRaster             5\n63:      2029 speciesAbundTempLM abundanceForecasting             5\n64:      2029 speciesAbundTempLM                 plot             5\n65:      2030        temperature         dataToRaster             5\n66:      2030 speciesAbundTempLM abundanceForecasting             5\n67:      2030 speciesAbundTempLM                 plot             5\n    eventTime         moduleName            eventType eventPriority\n    ._prevEventTimeFinish           clockTime\n                   &lt;POSc&gt;              &lt;POSc&gt;\n 1:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 2:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 3:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 4:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 5:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 6:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 7:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 8:   2024-06-12 01:40:15 2024-06-12 01:40:15\n 9:   2024-06-12 01:40:15 2024-06-12 01:40:15\n10:   2024-06-12 01:40:15 2024-06-12 01:40:15\n11:   2024-06-12 01:40:15 2024-06-12 01:40:15\n12:   2024-06-12 01:40:15 2024-06-12 01:40:15\n13:   2024-06-12 01:40:15 2024-06-12 01:40:15\n14:   2024-06-12 01:40:15 2024-06-12 01:40:15\n15:   2024-06-12 01:40:15 2024-06-12 01:40:15\n16:   2024-06-12 01:40:15 2024-06-12 01:40:15\n17:   2024-06-12 01:40:15 2024-06-12 01:40:15\n18:   2024-06-12 01:40:15 2024-06-12 01:40:15\n19:   2024-06-12 01:40:15 2024-06-12 01:40:15\n20:   2024-06-12 01:40:15 2024-06-12 01:40:15\n21:   2024-06-12 01:40:15 2024-06-12 01:40:15\n22:   2024-06-12 01:40:15 2024-06-12 01:40:15\n23:   2024-06-12 01:40:15 2024-06-12 01:40:15\n24:   2024-06-12 01:40:15 2024-06-12 01:40:15\n25:   2024-06-12 01:40:15 2024-06-12 01:40:15\n26:   2024-06-12 01:40:15 2024-06-12 01:40:15\n27:   2024-06-12 01:40:15 2024-06-12 01:40:15\n28:   2024-06-12 01:40:15 2024-06-12 01:40:15\n29:   2024-06-12 01:40:15 2024-06-12 01:40:15\n30:   2024-06-12 01:40:15 2024-06-12 01:40:15\n31:   2024-06-12 01:40:15 2024-06-12 01:40:15\n32:   2024-06-12 01:40:15 2024-06-12 01:40:15\n33:   2024-06-12 01:40:15 2024-06-12 01:40:15\n34:   2024-06-12 01:40:15 2024-06-12 01:40:15\n35:   2024-06-12 01:40:15 2024-06-12 01:40:15\n36:   2024-06-12 01:40:15 2024-06-12 01:40:15\n37:   2024-06-12 01:40:15 2024-06-12 01:40:15\n38:   2024-06-12 01:40:15 2024-06-12 01:40:15\n39:   2024-06-12 01:40:15 2024-06-12 01:40:15\n40:   2024-06-12 01:40:15 2024-06-12 01:40:15\n41:   2024-06-12 01:40:15 2024-06-12 01:40:15\n42:   2024-06-12 01:40:15 2024-06-12 01:40:15\n43:   2024-06-12 01:40:15 2024-06-12 01:40:15\n44:   2024-06-12 01:40:15 2024-06-12 01:40:16\n45:   2024-06-12 01:40:16 2024-06-12 01:40:16\n46:   2024-06-12 01:40:16 2024-06-12 01:40:16\n47:   2024-06-12 01:40:16 2024-06-12 01:40:16\n48:   2024-06-12 01:40:16 2024-06-12 01:40:16\n49:   2024-06-12 01:40:16 2024-06-12 01:40:16\n50:   2024-06-12 01:40:16 2024-06-12 01:40:16\n51:   2024-06-12 01:40:16 2024-06-12 01:40:16\n52:   2024-06-12 01:40:16 2024-06-12 01:40:16\n53:   2024-06-12 01:40:16 2024-06-12 01:40:16\n54:   2024-06-12 01:40:16 2024-06-12 01:40:16\n55:   2024-06-12 01:40:16 2024-06-12 01:40:16\n56:   2024-06-12 01:40:16 2024-06-12 01:40:16\n57:   2024-06-12 01:40:16 2024-06-12 01:40:16\n58:   2024-06-12 01:40:16 2024-06-12 01:40:16\n59:   2024-06-12 01:40:16 2024-06-12 01:40:16\n60:   2024-06-12 01:40:16 2024-06-12 01:40:16\n61:   2024-06-12 01:40:16 2024-06-12 01:40:16\n62:   2024-06-12 01:40:16 2024-06-12 01:40:16\n63:   2024-06-12 01:40:16 2024-06-12 01:40:16\n64:   2024-06-12 01:40:16 2024-06-12 01:40:17\n65:   2024-06-12 01:40:17 2024-06-12 01:40:17\n66:   2024-06-12 01:40:17 2024-06-12 01:40:17\n67:   2024-06-12 01:40:17 2024-06-12 01:40:17\n    ._prevEventTimeFinish           clockTime\n\n\nWe can also see how modules and objects interact using the functions objectDiagram() and moduleDiagram().\nModules’ diagram showing the interactions among modules:\n\n\nCode\nSpaDES.core::moduleDiagram(results)\n\n\n\n\n\n\n\n\n\nWe can also access any objects and use them. For example, we can look at the forecasted abundances and the difference raster is also possible. This is done by calling the object name from the results list.\n\n\nCode\nterra::plot(rast(results$forecasts))",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "workflowSimple2.html#examples",
    "href": "workflowSimple2.html#examples",
    "title": "14  Workflows with setupProject",
    "section": "14.5 Examples",
    "text": "14.5 Examples\nIn the remaining chapters of this section, we will explore several examples, including learning of several arguments to the function setupProject. But we will start very simple first.",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "workflowSimple2.html#see-also",
    "href": "workflowSimple2.html#see-also",
    "title": "14  Workflows with setupProject",
    "section": "14.6 See also",
    "text": "14.6 See also\nAll Functions in SpaDES.core\n?SpaDES.core::completed",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "workflowSimple2.html#barebones-r-script",
    "href": "workflowSimple2.html#barebones-r-script",
    "title": "14  Workflows with setupProject",
    "section": "14.7 Barebones R script",
    "text": "14.7 Barebones R script\n\n\nCode\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\n# if (!require(\"SpaDES.project\"))\nRequire::Install(c(\"SpaDES.project\", \"SpaDES.core\", \"reproducible\"), repos = repos, dependencies = TRUE)\n\npackagePath = SpaDES.project::.libPathDefault(\"~/SpaDES_book/integratingSpaDESmodules\")\n\npackagePath = SpaDES.project::.libPathDefault(\"PredictiveEcology.org\")\n\n##################### PART II: Download the modules and install the needed packages\nSetup &lt;- SpaDES.project::setupProject(\n  \n  paths = list(projectPath = \"~/SpaDES_book/integratingSpaDESmodules\",\n               packagePath = packagePath),\n  \n  modules = c(\"tati-micheletti/speciesAbundance@main\",\n              \"tati-micheletti/temperature@main\",\n              \"tati-micheletti/speciesAbundTempLM@main\"),\n  \n  times = list(start = 2013,\n               end = 2030),\n  \n  updateRprofile = FALSE\n  \n)\n\nresults &lt;- SpaDES.core::simInitAndSpades2(Setup)\n\nSpaDES.core::completed(results)\n\nSpaDES.core::moduleDiagram(results)\n\nterra::plot(rast(results$forecasts))",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Workflows with `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html",
    "href": "LandRDemo_coreVeg.html",
    "title": "15  Forest Landscape Modelling with LandR and setupProject",
    "section": "",
    "text": "15.1 All the steps of an ecological modelling project in a continuous workflow",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#workflow-setup",
    "href": "LandRDemo_coreVeg.html#workflow-setup",
    "title": "15  Forest Landscape Modelling with LandR and setupProject",
    "section": "15.2 Workflow setup",
    "text": "15.2 Workflow setup\n\n\nShow code\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\ninstall.packages(\"SpaDES.project\", repos = repos, dependencies = TRUE)\nlibrary(SpaDES.project)\n\nout &lt;- setupProject(\n  # INPUT OBJECTS -----------------------------------\n  # these need to come *before* any formal arguments, as they are needed for params.R\n  sppEquivCol = \"Boreal\",\n  vegLeadingProportion = 0,\n  successionTimestep = 10L,\n  eventCaching = c(\".inputObjects\", \"init\"),\n  useParallel = FALSE,\n  paths = list(\"packagePath\" = \"packages/\",\n               \"projectPath\" = \"~/SpaDES_book/LandRDemo_coreVeg\"),\n  packages = c(\n    # these are needed but don't load\n    \"DiagrammeR\", \n    \"PredictiveEcology/SpaDES.experiment@development (HEAD)\",\n    \"terra\"  \n  ),\n  options = list(\n    \"LandR.assertions\" = TRUE,\n    \"reproducible.destinationPath\" = paths$inputPath,\n    \"spades.inputPath\" = paths$inputPath,\n    \"spades.moduleCodeChecks\" = FALSE,\n    \"repos\" = repos\n  ),\n  modules = c(\n    \"PredictiveEcology/Biomass_speciesData@main\",\n    \"PredictiveEcology/Biomass_borealDataPrep@main\",\n    \"PredictiveEcology/Biomass_speciesParameters@main\",\n    \"PredictiveEcology/Biomass_core@main\"\n  ),\n  # SIMULATION SETUP ------------------------------------\n  times = list(start = 2001, end = 2031),\n  params = \"PredictiveEcology/PredictiveEcology.org@training-book/tutos/LandRDemo_coreVeg/params.R\",\n  # (more) INPUT OBJECTS -----------------------------------\n  # these come after, so that we don't need to pre-install/load LandR\n  # species lists/traits\n  sppEquiv = {\n    data(\"sppEquivalencies_CA\", package = \"LandR\")\n    sppEquivalencies_CA[grep(\"Pin\", LandR), `:=`(EN_generic_short = \"Pine\",\n                                                 EN_generic_full = \"Pine\",\n                                                 Leading = \"Pine leading\")]\n    sppEquivalencies_CA[grep(\"Betu_pap\", LandR), `:=`(EN_generic_short = \"Birch\",\n                                                      EN_generic_full = \"Birch\",\n                                                      Leading = \"Birch leading\")]\n    # all Popu will be merged\n    sppEquivalencies_CA[grep(\"Popu_\", LandR), `:=`(EN_generic_short = \"Poplar\",\n                                                   EN_generic_full = \"Poplar\",\n                                                   Leading = \"Poplar leading\")]\n    sppEquivalencies_CA[grep(\"Popu_\", LandR), Boreal := \"Popu_Spp\"]\n    \n    # define spp column to use for model\n    sppEquivalencies_CA &lt;- sppEquivalencies_CA[!\"\", on = sppEquivCol]\n    sppEquivalencies_CA &lt;- na.omit(sppEquivalencies_CA, sppEquivCol)\n    sppEquivalencies_CA\n  },\n  speciesParams = {\n    list(\n      \"shadetolerance\" = list(\n        Betu_Pap = 1\n        , Lari_Lar = 1\n        , Pice_Gla = 2\n        , Pice_Mar = 3\n        , Pinu_Ban = 1.5\n        , Popu_Spp = 1\n      )\n    )\n  },\n  studyArea = {\n    originalcrs &lt;- \"+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    Biomass_corecrs &lt;- \"+proj=lcc +lat_1=49 +lat_2=77 +lat_0=0 +lon_0=-95 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    \n    smallExtent &lt;- c(xmin = -104.757, xmax = -104.48835, ymin = 55.68663, ymax = 55.94491)\n    studyAreaS &lt;- terra::vect(terra::ext(smallExtent))\n    studyAreaS &lt;-  terra::vect(terra::geom(studyAreaS), \"polygons\", crs = originalcrs, atts = data.frame(id = 1:length(studyAreaS)))\n    studyAreaS &lt;- terra::project(studyAreaS, Biomass_corecrs)\n    studyAreaS\n  },\n  studyAreaLarge = {\n    originalcrs &lt;- \"+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    Biomass_corecrs &lt;- \"+proj=lcc +lat_1=49 +lat_2=77 +lat_0=0 +lon_0=-95 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    largeExtent &lt;- c(xmin = -104.757, xmax = -104.2197, ymin = 55.68663, ymax = 56.20319)\n    \n    studyAreaL &lt;- terra::vect(terra::ext(largeExtent))\n    studyAreaL &lt;-  terra::vect(terra::geom(studyAreaL), \"polygons\", crs = originalcrs, atts = data.frame(id = 1:length(studyAreaL)))\n    studyAreaL &lt;- terra::project(studyAreaL, Biomass_corecrs)\n    studyAreaL\n  },\n  # OUTPUTS TO SAVE -----------------------\n  outputs = {\n    rbind(\n      data.frame(\n        objectName = \"cohortData\", \n        saveTime = seq(times$start, times$end)\n      ),\n      data.frame(\n        objectName = \"pixelGroupMap\", \n        saveTime = seq(times$start, times$end)\n      )\n    )\n  }\n)\n\n\nIf you have a look at Section 17.1 in the Chapter 17 chapter, you will see some differences in the way we setup the two workflows:\n\npaths. Here we left the defaults for all paths (see ?setupPaths() for the list of path options) except for the project location (projectPath) and the location of the package library (packagePath, which will be placed inside projectPath).\noptions. We also set a couple of “global options” that determine the where data will be downloaded to (“reproducible.destinationPath”). This will be the same as the default directory to look for inputs (“spades.inputPath”). Notice how we used paths$ to get these directory paths from the paths object that setupProject creates (based on the paths argument above) prior to setting the options.\nother arguments (...). Almost all other arguments in the call above were passed to .... These are objects that need to be supplied by the user for these modules (e.g. studyArea and studyAreaLarge) or whose defaults we want to override (e.g., the species table, sppEquiv, and trait values, speciesParams). To avoid creating them on the .GlobalEnv first, we take advantage of setupProject‘s ability to run the code in { } and make these polygons. Note that these arguments are passed prior to any ’formal arguments’ (see ?formalArgs())",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#run-simulation",
    "href": "LandRDemo_coreVeg.html#run-simulation",
    "title": "15  Forest Landscape Modelling with LandR and setupProject",
    "section": "15.3 Run simulation",
    "text": "15.3 Run simulation\n\nYou can initialise the and run the workflow in two separate steps…\n\n\nCode\n# initialise then run simulation \nsimInitOut &lt;- SpaDES.core::simInit2(out)\nsimOut &lt;- SpaDES.core::spades(simInitOut)\n\n\n… or together, using simInitAndSpades2()\n\n\nCode\nsimOut &lt;- SpaDES.core::simInitAndSpades2(out)\n\n\n\n15.3.1 Inspect the workflow, its inputs, outputs and parameters\nNow that we have a simulation we can inspect it. Let’s assume you initialised and ran your simulation with two separate simInit2() and spades() calls.\nInspect module connections and between-module object flows:\n\n\nCode\nSpaDES.core::moduleDiagram(simInitOut)\nSpaDES.core::objectDiagram(simInitOut)  \n\n\n\n\n\n\n\n\n\n\n\nLandR vegetation module ‘connections’.\n\n\n\n\n\n\n\nObject flows between modules (truncated).\n\n\n\n\n\nNote the scheduling of the init events in simInitOut and how simOut has future events scheduled too – thanks to this, we can extend the simulation beyond the original SpaDES.core::end(sim) of 2031 (Extend the simulation).\n\n\nCode\nSpaDES.core::events(simInitOut)\nSpaDES.core::events(simOut)\n\n\nWe can also have a look at the completed events:\n\n\nCode\nSpaDES.core::completed(simInitOut)\nSpaDES.core::completed(simOut)\n\n\nFinally, the following accessor functions will show a list of model inputs, outputs and parameters:\n\n\nCode\nSpaDES.core::inputs(simOut)\nSpaDES.core::outputs(simOut)\nSpaDES.core::parameters(simOut)\n\n\nWe could even plot some of the input and output rasters to check that they are as we expected – no need to look for these objects files, they are all in the simList.\n\n\nCode\n# spatial inputs from list above\nterra::plot(simOut$studyAreaLarge, col = \"navyblue\", main = \"studyArea & studyAreaLarge\")\nterra::plot(simOut$studyArea, col = \"lightblue\", add = TRUE)\n\n# spatial outputs from list above\nterra::plot(simOut$vegTypeMap, \n            col = hcl.colors(palette = \"Dynamic\", n = length(unique(simOut$vegTypeMap[]))), \n            main = \"\")\nterra::plot(simOut$speciesLayers)\n\n\n\n\n\n\n\n\n\n\n\nStudy areas used for parameterisation (dark blue) and simulation (light blue).\n\n\n\n\n\n\n\nLast year’s vegetation type map (leading species).\n\n\n\n\n\n\n\nPercent cover of species retained for simulation.\n\n\n\n\n\n\nInspecting inputs and outputs directly from the simList\n\n\n\nMore importantly in our view, is the ability to inspect statistical models used to fit model parameters. This is possible because the developers have declared the fitted statistical model objects as module outputs. Often, this type of information is buried in supplementary materials of papers and incomplete (e.g. coefficients and goodness-of-fit statistics are presented, but the entire model object, with its fitted values, residuals, etc., are not).\nBy exporting entire model objects, and making them available via repeatable code or data repositories, model transparency and potential scrutiny are massively increased.\n\n\nCode\n# model used to estimate species establishment probabilities\nsummary(simOut$modelBiomass$mod)\nplot(simOut$modelBiomass$mod)\n\n# model used to calibrate Picea glauca's growth parameters\nsummary(simOut$speciesGrowthCurves$Pice_Gla$NonLinearModel$Pice_Gla)\n\n\n\n\n15.3.2 Turn plotting on after setting up the workflow\nWe can change parameters and re-run the simulation to, e.g., activate live plotting in Biomass_core, without having to\n\nchange the parameter provided to setupProject\nrepeat the setupProject call\n\nNote that because simOut is actually a copy of simInitOut (see the output of SpaDES.core::completed(simInitOut)), this still means that simInitOut has to be re-generated for this purpose, otherwise spades would try to resume the simulation from the “last year”.\nThanks to internal caching, it will only take seconds to “redo” simInitOut. You will also notice that init events are retrieved from cache, this time around2.\n\n\nCode\nsimInitOut &lt;- SpaDES.core::simInit2(out)\nSpaDES.core::P(simInitOut, param = \".plots\", module = \"Biomass_core\") &lt;- \"screen\"\nSpaDES.core::P(simInitOut, param = \".plotMaps\", module = \"Biomass_core\") &lt;- TRUE\nsimOut &lt;- SpaDES.core::spades(simInitOut)\n\n\n\n\n15.3.3 Extend the simulation\nWe can also keep it going for a few more years. Use SpaDES.core::end() to extend the simulation another 20 years and then call SpaDES.core::spades() on the changed simList (not the one output by `SpaDES.core::simInit2()) to resume the simulation from 2031.\n\n\nCode\nSpaDES.core::end(simOut) &lt;- 2061\nsimOut &lt;- SpaDES.core::spades(simOut)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#sec-LandRScenarios",
    "href": "LandRDemo_coreVeg.html#sec-LandRScenarios",
    "title": "15  Forest Landscape Modelling with LandR and setupProject",
    "section": "15.4 Different scenarios and model selection",
    "text": "15.4 Different scenarios and model selection\nIn Barros et al. (2023), the model was run with two different parameterisation approaches one that was “data hungry” and calibrated tree species growth parameters (using Biomass_speciesParameters as we have done above) and a simpler one that used default parameter values (without Biomass_speciesParameters).\nSpaDES and LandR allow us to swap parameterisation/calibration approaches easily and re-evaluate each and compare the models (see Barros et al. (2023)).\nDo to this, we simply exclude Biomass_speciesParameters from out and run a second simulation. We also need to save the outputs in a different folder, or the previous ones will be overriden.\n\n\nCode\nout2 &lt;- out\nout2$modules &lt;- out2$modules[out2$modules != \"Biomass_speciesParameters\"]\nout2$paths$outputPath &lt;- normPath(file.path(\"~/SpaDES_book/LandRDemo_coreVeg\", \"outputsSim2\"))\n\nsimOut2 &lt;- SpaDES.core::simInitAndSpades2(out2)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#sec-LandRdebug",
    "href": "LandRDemo_coreVeg.html#sec-LandRdebug",
    "title": "15  Forest Landscape Modelling with LandR and setupProject",
    "section": "15.5 Debugging",
    "text": "15.5 Debugging\nThere are several ways to debug SpaDES modules (see Chapter 13), a relatively easy one for when you are suprised by an error occurring during specific event is to pass the event’s name to spades(..., debug = ) argument.\nBelow, we debug the plotSummaryBySpecies event of Biomass_core. R interrupts the execution of the code in the chunk that executes this event’s operations (inside doEvent.Biomass_core())\n\n\nCode\nsimOut &lt;- SpaDES.core::spades(simInitOut, debug = \"plotSummaryBySpecies\")\n\n\nR interrupts code execution during this event’s operations (inside doEvent.Biomass_core()):\ndebugging in: get(moduleCall, envir = fnEnv)(sim, cur[[\"eventTime\"]], cur[[\"eventType\"]])\ndebug at C:/Users/cbarros/Documents/SpaDES_book/LandRDemo_coreVeg/modules/Biomass_core/Biomass_core.R#314: {\n(...)\nFrom there you can press ENTER, F10 or the “Next” button to execute the code line-by-line. At some point you will get to this line:\n\n\nCode\nsim &lt;- plotSummaryBySpecies(sim)\n\n\nwhich calls the function that effectively makes the summary plots. If you spotted a problem during the plotSummaryBySpecies event (or maybe you want to see what it does and/or change the code) and it hasn’t been triggered yet, then it’s likely it happened in this function.\nBefore running the line you can debugonce(plotSummaryBySpecies) to enable debugging the function and spot the issue.\nAnother option would be to insert a browser() at the top of the function’s definition inside the module code or the R scripts in the module’s R/ folder (&lt;modulePath&gt;/&lt;module_name&gt;/R/). In this case look for plotSummaryBySpecies &lt;- compiler::cmpfun(function(sim) {...} inside the module code (Biomass_core.R) and try putting a browser() inside the {}",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#try-on-your-own",
    "href": "LandRDemo_coreVeg.html#try-on-your-own",
    "title": "15  Forest Landscape Modelling with LandR and setupProject",
    "section": "15.6 Try on your own",
    "text": "15.6 Try on your own\nTry re-running the workflow with a different set of study areas. For example:\n\n\nCode\n# studyArea could be\nstudyArea = {\nset.seed(123)\nSpaDES.tools::randomStudyArea(size = 200000000)\n}\n\n# studyAreaLarge\nstudyAreaLarge = {\nterra::buffer(studyArea, width = 10000)\n}\n\n\n\nNoticed any differences (speed, cache IDs, …)?\nwere the species simulated the same? How about their trait values (e.g. estimated maxB, species establishment probabilities. )",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#see-also",
    "href": "LandRDemo_coreVeg.html#see-also",
    "title": "15  Forest Landscape Modelling with LandR and setupProject",
    "section": "15.7 See also",
    "text": "15.7 See also\nChapter 11 on caching.\nLandR Manual\n?future::plan\nsimList accessors",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#barebones-r-script",
    "href": "LandRDemo_coreVeg.html#barebones-r-script",
    "title": "15  Forest Landscape Modelling with LandR and setupProject",
    "section": "15.8 Barebones R script",
    "text": "15.8 Barebones R script\n\n\nCode\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\ninstall.packages(\"SpaDES.project\", repos = repos, dependencies = TRUE)\nlibrary(SpaDES.project)\n\nout &lt;- setupProject(\n  # INPUT OBJECTS -----------------------------------\n  # these need to come *before* any formal arguments, as they are needed for params.R\n  sppEquivCol = \"Boreal\",\n  vegLeadingProportion = 0,\n  successionTimestep = 10L,\n  eventCaching = c(\".inputObjects\", \"init\"),\n  useParallel = FALSE,\n  paths = list(\"packagePath\" = \"packages/\",\n               \"projectPath\" = \"~/SpaDES_book/LandRDemo_coreVeg\"),\n  packages = c(\n    # these are needed but don't load\n    \"DiagrammeR\", \n    \"PredictiveEcology/SpaDES.experiment@development (HEAD)\",\n    \"terra\"  \n  ),\n  options = list(\n    \"LandR.assertions\" = TRUE,\n    \"reproducible.destinationPath\" = paths$inputPath,\n    \"spades.inputPath\" = paths$inputPath,\n    \"spades.moduleCodeChecks\" = FALSE,\n    \"repos\" = repos\n  ),\n  modules = c(\n    \"PredictiveEcology/Biomass_speciesData@main\",\n    \"PredictiveEcology/Biomass_borealDataPrep@main\",\n    \"PredictiveEcology/Biomass_speciesParameters@main\",\n    \"PredictiveEcology/Biomass_core@main\"\n  ),\n  # SIMULATION SETUP ------------------------------------\n  times = list(start = 2001, end = 2031),\n  params = \"PredictiveEcology/PredictiveEcology.org@training-book/tutos/LandRDemo_coreVeg/params.R\",\n  # (more) INPUT OBJECTS -----------------------------------\n  # these come after, so that we don't need to pre-install/load LandR\n  # species lists/traits\n  sppEquiv = {\n    data(\"sppEquivalencies_CA\", package = \"LandR\")\n    sppEquivalencies_CA[grep(\"Pin\", LandR), `:=`(EN_generic_short = \"Pine\",\n                                                 EN_generic_full = \"Pine\",\n                                                 Leading = \"Pine leading\")]\n    sppEquivalencies_CA[grep(\"Betu_pap\", LandR), `:=`(EN_generic_short = \"Birch\",\n                                                      EN_generic_full = \"Birch\",\n                                                      Leading = \"Birch leading\")]\n    # all Popu will be merged\n    sppEquivalencies_CA[grep(\"Popu_\", LandR), `:=`(EN_generic_short = \"Poplar\",\n                                                   EN_generic_full = \"Poplar\",\n                                                   Leading = \"Poplar leading\")]\n    sppEquivalencies_CA[grep(\"Popu_\", LandR), Boreal := \"Popu_Spp\"]\n    \n    # define spp column to use for model\n    sppEquivalencies_CA &lt;- sppEquivalencies_CA[!\"\", on = sppEquivCol]\n    sppEquivalencies_CA &lt;- na.omit(sppEquivalencies_CA, sppEquivCol)\n    sppEquivalencies_CA\n  },\n  speciesParams = {\n    list(\n      \"shadetolerance\" = list(\n        Betu_Pap = 1\n        , Lari_Lar = 1\n        , Pice_Gla = 2\n        , Pice_Mar = 3\n        , Pinu_Ban = 1.5\n        , Popu_Spp = 1\n      )\n    )\n  },\n  studyArea = {\n    originalcrs &lt;- \"+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    Biomass_corecrs &lt;- \"+proj=lcc +lat_1=49 +lat_2=77 +lat_0=0 +lon_0=-95 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    \n    smallExtent &lt;- c(xmin = -104.757, xmax = -104.48835, ymin = 55.68663, ymax = 55.94491)\n    studyAreaS &lt;- terra::vect(terra::ext(smallExtent))\n    studyAreaS &lt;-  terra::vect(terra::geom(studyAreaS), \"polygons\", crs = originalcrs, atts = data.frame(id = 1:length(studyAreaS)))\n    studyAreaS &lt;- terra::project(studyAreaS, Biomass_corecrs)\n    studyAreaS\n  },\n  studyAreaLarge = {\n    originalcrs &lt;- \"+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    Biomass_corecrs &lt;- \"+proj=lcc +lat_1=49 +lat_2=77 +lat_0=0 +lon_0=-95 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0\"\n    largeExtent &lt;- c(xmin = -104.757, xmax = -104.2197, ymin = 55.68663, ymax = 56.20319)\n    \n    studyAreaL &lt;- terra::vect(terra::ext(largeExtent))\n    studyAreaL &lt;-  terra::vect(terra::geom(studyAreaL), \"polygons\", crs = originalcrs, atts = data.frame(id = 1:length(studyAreaL)))\n    studyAreaL &lt;- terra::project(studyAreaL, Biomass_corecrs)\n    studyAreaL\n  },\n  # OUTPUTS TO SAVE -----------------------\n  outputs = {\n    rbind(\n      data.frame(\n        objectName = \"cohortData\", \n        saveTime = seq(times$start, times$end)\n      ),\n      data.frame(\n        objectName = \"pixelGroupMap\", \n        saveTime = seq(times$start, times$end)\n      )\n    )\n  }\n)\n\n# initialise then run simulation \nsimInitOut &lt;- SpaDES.core::simInit2(out)\nsimOut &lt;- SpaDES.core::spades(simInitOut)\n\nsimOut &lt;- SpaDES.core::simInitAndSpades2(out)\n\n\nSpaDES.core::moduleDiagram(simInitOut)\nSpaDES.core::objectDiagram(simInitOut)  \n\n\nSpaDES.core::events(simInitOut)\nSpaDES.core::events(simOut)\n\n\nSpaDES.core::completed(simInitOut)\nSpaDES.core::completed(simOut)\n\n\nSpaDES.core::inputs(simOut)\nSpaDES.core::outputs(simOut)\nSpaDES.core::parameters(simOut)\n\n# spatial inputs from list above\nterra::plot(simOut$studyAreaLarge, col = \"navyblue\", main = \"studyArea & studyAreaLarge\")\nterra::plot(simOut$studyArea, col = \"lightblue\", add = TRUE)\n\n# spatial outputs from list above\nterra::plot(simOut$vegTypeMap, \n            col = hcl.colors(palette = \"Dynamic\", n = length(unique(simOut$vegTypeMap[]))), \n            main = \"\")\nterra::plot(simOut$speciesLayers)\n\n# model used to estimate species establishment probabilities\nsummary(simOut$modelBiomass$mod)\nplot(simOut$modelBiomass$mod)\n\n# model used to calibrate Picea glauca's growth parameters\nsummary(simOut$speciesGrowthCurves$Pice_Gla$NonLinearModel$Pice_Gla)\n\n\nsimInitOut &lt;- SpaDES.core::simInit2(out)\nSpaDES.core::P(simInitOut, param = \".plots\", module = \"Biomass_core\") &lt;- \"screen\"\nSpaDES.core::P(simInitOut, param = \".plotMaps\", module = \"Biomass_core\") &lt;- TRUE\nsimOut &lt;- SpaDES.core::spades(simInitOut)\n\nSpaDES.core::end(simOut) &lt;- 2061\nsimOut &lt;- SpaDES.core::spades(simOut)\n\n\n\n\n\n\n\nout2 &lt;- out\nout2$modules &lt;- out2$modules[out2$modules != \"Biomass_speciesParameters\"]\nout2$paths$outputPath &lt;- normPath(file.path(\"~/SpaDES_book/LandRDemo_coreVeg\", \"outputsSim2\"))\n\nsimOut2 &lt;- SpaDES.core::simInitAndSpades2(out2)\n\n\nsimOut &lt;- SpaDES.core::spades(simInitOut, debug = \"plotSummaryBySpecies\")\n\n\nsim &lt;- plotSummaryBySpecies(sim)\n\n# studyArea could be\nstudyArea = {\nset.seed(123)\nSpaDES.tools::randomStudyArea(size = 200000000)\n}\n\n# studyAreaLarge\nstudyAreaLarge = {\nterra::buffer(studyArea, width = 10000)\n}\n\n\n\n\n\n\nBarros, Ceres, Yong Luo, Alex M. Chubaty, Ian M. S. Eddy, Tatiane Micheletti, Céline Boisvenue, David W. Andison, Steven G. Cumming, and Eliot J. B. McIntire. 2023. “Empowering Ecological Modellers with a PERFICT Workflow: Seamlessly Linking Data, Parameterisation, Prediction, Validation and Visualisation.” Methods in Ecology and Evolution 14 (1): 173–88. https://doi.org/10.1111/2041-210X.14034.\n\n\nScheller, Robert M., and Brian R. Miranda. 2015. LANDIS-II Biomass Succession V3.2 Extension  User Guide.",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "LandRDemo_coreVeg.html#footnotes",
    "href": "LandRDemo_coreVeg.html#footnotes",
    "title": "15  Forest Landscape Modelling with LandR and setupProject",
    "section": "",
    "text": "See ?googledrive::drive_auth for more information.↩︎\nSee Chapter 11 about caching.↩︎",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Forest Landscape Modelling with LandR and `setupProject`</span>"
    ]
  },
  {
    "objectID": "ForestsAndFire.html",
    "href": "ForestsAndFire.html",
    "title": "16  Forest Succession and Wildfire using setupProject",
    "section": "",
    "text": "16.1 Examining things\nWe can do all sorts of things. We will start with a few simple “accessors”, i.e., “access something from the simList”. completed shows the events that were run. elapsedTime shows how much time each event took.\nCode\ncompleted(outSim)\nelapsedTime(outSim, units = \"minute\")\nThe module metadata can be accessed from the sim or can be read from the module source files or it is usually built into the Rmd file that comes with the module.\nCode\nmm &lt;- moduleMetadata(outSim)\n\n# a list of all the module metadata\nmm$Biomass_borealDataPrep$",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Forest Succession and Wildfire using `setupProject`</span>"
    ]
  },
  {
    "objectID": "ForestsAndFire.html#changing-things",
    "href": "ForestsAndFire.html#changing-things",
    "title": "16  Forest Succession and Wildfire using setupProject",
    "section": "16.2 Changing things",
    "text": "16.2 Changing things\nSetting .plots = \"png\" will turn on all known plotting (that uses the Plots function) and save them all as png files in the figures subfolder.\n\n\nCode\nout$params$.globals$.plots &lt;- \"png\"\noutSim &lt;- simInitAndSpades2(out)\n\n\nThen we can look in the outputs/figures folder to see all the figures that the modules created.",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Forest Succession and Wildfire using `setupProject`</span>"
    ]
  },
  {
    "objectID": "ForestsAndFire.html#barebones-r-script",
    "href": "ForestsAndFire.html#barebones-r-script",
    "title": "16  Forest Succession and Wildfire using setupProject",
    "section": "16.3 Barebones R script",
    "text": "16.3 Barebones R script\n\n\nCode\nrepos &lt;- unique(c(\"predictiveecology.r-universe.dev\", getOption(\"repos\")))\noptions(repos = repos)\n\n# Require::Require(c(\"SpaDES.project (HEAD)\"))\nRequire::Require(c(\"PredictiveEcology/SpaDES.project@development (HEAD)\")) \n# pkgload::load_all(\"~/GitHub/SpaDES.project\")\n\nout &lt;- SpaDES.project::setupProject(\n  updateRprofile = TRUE,\n  name = \"scfm_example_fresh\",\n  useGit = FALSE,\n  paths = list(projectPath = \"~/SpaDES_book\"),\n  modules = c(\"PredictiveEcology/Biomass_borealDataPrep@development\",\n              \"PredictiveEcology/Biomass_core@development\",\n              \"PredictiveEcology/Biomass_regeneration@development\",\n              file.path(\"PredictiveEcology/scfm@development/modules\",\n                        c(\"scfmLandcoverInit\", \"scfmRegime\", \"scfmDriver\",\n                          \"scfmIgnition\", \"scfmEscape\", \"scfmSpread\",\n                          \"scfmDiagnostics\"))\n  ),\n  params = list(\n    .globals = list(.studyAreaName = \"scfm_example\",\n                    dataYear = 2011, #will get kNN 2011 data, and NTEMS 2011 landcover\n                    sppEquivCol = \"LandR\",\n                    .plots = \"png\",\n                    .useCache = c(\".inputObjects\", \"init\")\n                 ),\n    scfmDriver = list(targetN = 1000, #default is 4000 - higher targetN adds time + precision\n                      # targetN would ideally be minimum 2000 - mean fire size estimates will be bad with 1000\n                      .useParallelFireRegimePolys = TRUE) #assumes parallelization is an otpion\n    \n  ),\n  options = list(#spades.allowInitDuringSimInit = TRUE,\n                 spades.allowSequentialCaching = TRUE,\n                 spades.moduleCodeChecks = FALSE,\n                 #                reproducible.shapefileRead = \"terra::vect\",\n                 spades.recoveryMode = 1\n  ),\n  packages = c('RCurl', 'XML', 'snow'), # need for some downloading; if omitted, a message tells user\n  times = list(start = 2011, end = 2061),\n  sppEquiv = LandR::sppEquivalencies_CA[KNN %in% c(\"Popu_Tre\", \"Betu_Pap\",\n                                                   \"Pice_Gla\", \"Pice_Mar\",\n                                                   \"Pinu_Con\", \"Pinu_Ban\")],\n  studyArea = {\n    targetCRS &lt;- paste(\"+proj=lcc +lat_1=49 +lat_2=77 +lat_0=0 +lon_0=-95 +x_0=0 +y_0=0\",\n                       \"+datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0\")\n    sa &lt;- terra::vect(cbind(-1209980, 7586865), crs = targetCRS)\n    sa &lt;- LandR::randomStudyArea(center = sa, size = 10000 * 250 * 30000, seed = 1002)\n    sa &lt;- sf::st_as_sf(sa)\n  },\n  studyAreaLarge = {\n    sf::st_buffer(studyArea, 20000)\n  },\n  rasterToMatchLarge = {\n    rtml&lt;- terra::rast(terra::ext(studyAreaLarge), res = c(250, 250))\n    terra::crs(rtml) &lt;- terra::crs(studyAreaLarge)\n    rtml[] &lt;- 1\n    rtml &lt;- terra::mask(rtml, studyAreaLarge)\n  },\n  rasterToMatch = {\n    rtm &lt;- terra::crop(rasterToMatchLarge, studyArea)\n    rtm &lt;- terra::mask(rtm, studyArea)\n  }\n)\n\n\n#this must be done outside of setupProject (temporarily)\n#alternatively\noutSim &lt;- do.call(SpaDES.core::simInitAndSpades, out) |&gt;\n  Cache()\n\ncompleted(outSim)\nelapsedTime(outSim, units = \"minute\")\n\nmm &lt;- moduleMetadata(outSim)\n\n# a list of all the module metadata\nmm$Biomass_borealDataPrep$\n\nout$params$.globals$.plots &lt;- \"png\"\noutSim &lt;- simInitAndSpades2(out)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Forest Succession and Wildfire using `setupProject`</span>"
    ]
  },
  {
    "objectID": "castorExample.html",
    "href": "castorExample.html",
    "title": "17  Castor Workflow with setupProject",
    "section": "",
    "text": "17.1 Workflow setup\nSpaDES.project functions expect SpaDES modules to either exist locally, or at root level of separate repositories. This is not the case with Castor modules, which are in a nested folder (i.e. a folder in a folder tree) of a single GitHub repository.\nSpaDES.project will eventually be able to deal with this1, but for now we work around this issue by using a custom function called getCastorModulesAndDB. This function will also download the demo SQLite database from Google Drive2. You’ll be prompted to authorize this operation and a browser window will open for this. Make sure you give tidyverse read/write access to your files:\nCode\n# install/load necessary packages\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\ninstall.packages(c(\"SpaDES.project\", \"googledrive\", \"reproducible\"), \n                 repos = repos, dependencies = TRUE)\nlibrary(SpaDES.project)\n\n# get Castor modules and functions\nsetupFunctions(paths = list(\"projectPath\" = \"~/SpaDES_book/castorExample/\"),\n               functions = c(\"PredictiveEcology/PredictiveEcology.org@main/tutos/castorExample/getCastorModulesAndDB.R\",\n                             \"PredictiveEcology/PredictiveEcology.org@main/tutos/castorExample/params.R\"),\n               overwrite = TRUE)\noutMod &lt;- getCastorModulesAndDB(paths = list(\"modulePath\" = \"~/SpaDES_book/castorExample/modules/\",\n                                             \"projectPath\" = \"~/SpaDES_book/castorExample\"),\n                                modules = c(\"dataCastor\", \n                                            \"growingStockCastor\", \n                                            \"forestryCastor\", \n                                            \"blockingCastor\"),\n                                dbURL = \"https://drive.google.com/file/d/1-2POunzC7aFbkKK5LeBJNsFYMBBY8dNx/view?usp=sharing\",\n                                dbPath = \"~/SpaDES_book/castorExample/R/scenarios/comparison_stsm\")\nCheck where the getCastorModulesAndDB.R and params.R files ended up. setupFunctions() respected the folder structure in PredictiveEcology.org and placed these files in tutos/castorExample/ within the specified projectPath. We’ll need to remember this for later.\nAfter the “workaround” setupProject does all the heavy-lifting of setting up the workflow, namely installing all package dependencies listed in the several modules and in setupProject(..., packages), creating all the necessary folders, sourcing additional files and creating parameter, inputs and outputs lists – see ?setupProject.\nNote that all folder/file paths are relative to projectPath, even the file path passed to parameters (remember the file path from above?).\nCode\n# set up the workflow paths, dependencies and modules\n# as well as simulation parameters, (some) inputs and outputs\nout &lt;- setupProject(\n  paths = list(\"inputPath\" = \"modules/forestryCastor/inputs\",\n               \"outputPath\" = \"R/scenarios/comparison_stsm/outputs\",\n               \"modulePath\" = \"modules/\",\n               \"cachePath\" = \"modules/forestryCastor\",\n               \"projectPath\" = \"~/SpaDES_book/castorExample\"),\n  modules = names(outMod$modules),\n  options = list(repos = repos),\n  functions = \"bcgov/castor@main/R/functions/R_Postgres.R\",\n  # install and load\n  require = \"dplyr\",\n  # install but don't load these:\n  packages = c(\n    \"DBI\", \n    \"DiagrammeR\",\n    \"keyring\",\n    \"rgdal\", \n    \"RPostgreSQL\", \n    \"sp\",\n    \"terra\"\n  ),\n  params = \"tutos/castorExample/params.R\",  \n  times = list(start = 0, end = 20),\n  outputs = {\n    data.frame(objectName = c(\"harvestReport\",\n                              \"growingStockReport\"))\n  },\n  scenario = {\n    data.table(name = \"stsm_base_case\",\n               description = paste(\"Priority queue = oldest first. Adjacency constraint\",\n                                   \"= None. Includes roads (mst) and blocks (pre).\",\n                                   \"Harvest flow = 147,300 m3/year in decade 1, 133,500\",\n                                   \"m3/year in decade 2, 132,300 m3/year in decades 3 to\",\n                                   \"14 and 135,400 m3/year in decades 15 to 25.\",\n                                   \"Minimum harvest age = 80 and minimum harvest volume = 150\"))\n  },\n  harvestFlow = {\n    rbindlist(list(data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 1,\n                                                 to = 1, \n                                                 by = 1),\n                                            1), \n                              flow = 1473000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 2,\n                                                 to = 2, \n                                                 by = 1),\n                                            1), \n                              flow = 1335000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 3,\n                                                 to = 14, \n                                                 by = 1),\n                                            1), \n                              flow = 1323000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 15,\n                                                 to = 25, \n                                                 by = 1),\n                                            1), \n                              flow = 1354000, \n                              partition_type = 'live')  \n    ))\n  },\n  Restart = TRUE\n)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Castor Workflow with `setupProject`</span>"
    ]
  },
  {
    "objectID": "castorExample.html#initialise-the-model-and-inspect-simlist",
    "href": "castorExample.html#initialise-the-model-and-inspect-simlist",
    "title": "17  Castor Workflow with setupProject",
    "section": "17.2 Initialise the model and inspect simList",
    "text": "17.2 Initialise the model and inspect simList\nsetupProject() returns a names list containing values that can be passed as argument to simInit()3.\nWe use do.call() to pass the whole list of arguments to simInit.\n\n\nCode\n# initialize simulation\ncastorInit &lt;- do.call(SpaDES.core::simInit, out)\n\n\nAnother (more verbose) option would to call simInit directly:\n\n\nCode\ncastorInit &lt;- SpaDES.core::simInit(\n  times = out$times,\n  params = out$params, \n  modules = out$modules, \n  objects = list(scenario = out$scenario, \n                 harvestFlow = out$harvestFlow)\n)\n\n\nUse the following functions to access workflow/model properties. events(), for instance will output the scheduled events, which at this point are only the init events of each module as you can see in the output below.\n\n\nCode\n# inspect the `simList`\nSpaDES.core::params(castorInit) \nSpaDES.core::inputs(castorInit)\nSpaDES.core::outputs(castorInit)\nSpaDES.core::times(castorInit) \n\n# scheduled events\nSpaDES.core::events(castorInit) \n\n\n\n\n   eventTime         moduleName eventType eventPriority\n       &lt;num&gt;             &lt;char&gt;    &lt;char&gt;         &lt;num&gt;\n1:         0         checkpoint      init             0\n2:         0               save      init             0\n3:         0           progress      init             0\n4:         0               load      init             0\n5:         0         dataCastor      init             1\n6:         0 growingStockCastor      init             1\n7:         0     forestryCastor      init             1\n8:         0     blockingCastor      init             1",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Castor Workflow with `setupProject`</span>"
    ]
  },
  {
    "objectID": "castorExample.html#visualize-the-workflow",
    "href": "castorExample.html#visualize-the-workflow",
    "title": "17  Castor Workflow with setupProject",
    "section": "17.3 Visualize the workflow",
    "text": "17.3 Visualize the workflow\nmoduleDiagram() and objectDiagram() are great to visualise how each module interacts with the other. Recall that these interactions arise from object “exchanges” between modules, which are deduced by simInit() from module metadata (Figure 17.2) – i.e., if a module’s inputs are another’s outputs, then the first module will follow the second.\n\n\nCode\nSpaDES.core::moduleDiagram(castorInit)\nSpaDES.core::objectDiagram(castorInit)\n\n\n\n\n\n\n\n\n\n\nFigure 17.1: Diagram of module connections.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 17.2: Diagram of module inter-dependencies with object names.",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Castor Workflow with `setupProject`</span>"
    ]
  },
  {
    "objectID": "castorExample.html#run-simulation",
    "href": "castorExample.html#run-simulation",
    "title": "17  Castor Workflow with setupProject",
    "section": "17.4 Run simulation",
    "text": "17.4 Run simulation\nspades() runs the simulation, beginning with the execution of the init events. Notice how the result of outputs() differs from previously.\n\n\nCode\ncastorSim &lt;- SpaDES.core::spades(castorInit)\n\n# we now have outputs\nSpaDES.core::outputs(castorSim)\n\n\n\n\n          objectName\n1      harvestReport\n2 growingStockReport\n                                                                                                              file\n1      C:/Users/cbarros/Documents/tutos/castorExample/R/scenarios/comparison_stsm/outputs/harvestReport_year20.rds\n2 C:/Users/cbarros/Documents/tutos/castorExample/R/scenarios/comparison_stsm/outputs/growingStockReport_year20.rds\n      fun package saveTime saved arguments\n1 saveRDS    base       20  TRUE        NA\n2 saveRDS    base       20  TRUE        NA\n\n\ncompleted(castorSim) shows the chaining of events that was produced and run by spades(). The sequence of steps in the workflow therefore arises from each module’s events and their scheduling, rather than being explicitly imposed by the user.\n\n\nCode\nSpaDES.core::completed(castorSim)\n\n\n    eventTime         moduleName          eventType eventPriority\n        &lt;num&gt;             &lt;char&gt;             &lt;char&gt;         &lt;num&gt;\n 1:         0         checkpoint               init             0\n 2:         0               save               init             0\n 3:         0           progress               init             0\n 4:         0               load               init             0\n 5:         0         dataCastor               init             1\n 6:         0 growingStockCastor               init             1\n 7:         0     forestryCastor               init             1\n 8:         0     blockingCastor               init             1\n....\n\n\nWe suggest omitting the blockingCastor module in setupProject() and rerunning the workflow again to see how spades is capable of re-generating a new workflow with little effort from the user.\n\n\nCode\nmodules &lt;- c(\"dataCastor\", \n             \"growingStockCastor\", \n             \"forestryCastor\")\n\nout &lt;- setupProject(\n  paths = list(\"inputPath\" = \"modules/forestryCastor/inputs\",\n               \"outputPath\" = \"/R/scenarios/comparison_stsm/outputs\",\n               \"modulePath\" = \"modules/\",\n               \"cachePath\" = \"modules/forestryCastor\",\n               \"projectPath\" = \"~/SpaDES_book/castorExample/\"),\n  modules = modules,\n  functions = \"bcgov/castor@main/R/functions/R_Postgres.R\",\n  # install and load\n  require = \"dplyr\",\n  # install but don't load these:\n  packages = c(\n    \"DBI\", \n    \"keyring\",\n    \"rgdal\", \n    \"RPostgreSQL\", \n    \"sp\",\n    \"terra\"\n  ),\n  params = \"params.R\",\n  times = list(start = 0, end = 20),\n  outputs = {\n    data.frame(objectName = c(\"harvestReport\",\n                              \"growingStockReport\"))\n  },\n  scenario = {\n    data.table(name = \"stsm_base_case\",\n               description = paste(\"Priority queue = oldest first. Adjacency constraint\",\n                                   \"= None. Includes roads (mst) and blocks (pre).\",\n                                   \"Harvest flow = 147,300 m3/year in decade 1, 133,500\",\n                                   \"m3/year in decade 2, 132,300 m3/year in decades 3 to\",\n                                   \"14 and 135,400 m3/year in decades 15 to 25.\",\n                                   \"Minimum harvest age = 80 and minimum harvest volume = 150\"))\n  },\n  harvestFlow = {\n    rbindlist(list(data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 1,\n                                                 to = 1, \n                                                 by = 1),\n                                            1), \n                              flow = 1473000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 2,\n                                                 to = 2, \n                                                 by = 1),\n                                            1), \n                              flow = 1335000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 3,\n                                                 to = 14, \n                                                 by = 1),\n                                            1), \n                              flow = 1323000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 15,\n                                                 to = 25, \n                                                 by = 1),\n                                            1), \n                              flow = 1354000, \n                              partition_type = 'live')  \n    ))\n  },\n  Restart = TRUE\n)\n\n# initialize and run simulation in one go\ncastorSim2 &lt;- do.call(SpaDES.core::simInitAndSpades, out)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Castor Workflow with `setupProject`</span>"
    ]
  },
  {
    "objectID": "castorExample.html#barebones-r-script",
    "href": "castorExample.html#barebones-r-script",
    "title": "17  Castor Workflow with setupProject",
    "section": "17.5 Barebones R script",
    "text": "17.5 Barebones R script\n\n\nCode\n# install/load necessary packages\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\ninstall.packages(c(\"SpaDES.project\", \"googledrive\", \"reproducible\"), \n                 repos = repos, dependencies = TRUE)\nlibrary(SpaDES.project)\n\n# get Castor modules and functions\nsetupFunctions(paths = list(\"projectPath\" = \"~/SpaDES_book/castorExample/\"),\n               functions = c(\"PredictiveEcology/PredictiveEcology.org@main/tutos/castorExample/getCastorModulesAndDB.R\",\n                             \"PredictiveEcology/PredictiveEcology.org@main/tutos/castorExample/params.R\"),\n               overwrite = TRUE)\noutMod &lt;- getCastorModulesAndDB(paths = list(\"modulePath\" = \"~/SpaDES_book/castorExample/modules/\",\n                                             \"projectPath\" = \"~/SpaDES_book/castorExample\"),\n                                modules = c(\"dataCastor\", \n                                            \"growingStockCastor\", \n                                            \"forestryCastor\", \n                                            \"blockingCastor\"),\n                                dbURL = \"https://drive.google.com/file/d/1-2POunzC7aFbkKK5LeBJNsFYMBBY8dNx/view?usp=sharing\",\n                                dbPath = \"~/SpaDES_book/castorExample/R/scenarios/comparison_stsm\")\n\n\n# set up the workflow paths, dependencies and modules\n# as well as simulation parameters, (some) inputs and outputs\nout &lt;- setupProject(\n  paths = list(\"inputPath\" = \"modules/forestryCastor/inputs\",\n               \"outputPath\" = \"R/scenarios/comparison_stsm/outputs\",\n               \"modulePath\" = \"modules/\",\n               \"cachePath\" = \"modules/forestryCastor\",\n               \"projectPath\" = \"~/SpaDES_book/castorExample\"),\n  modules = names(outMod$modules),\n  options = list(repos = repos),\n  functions = \"bcgov/castor@main/R/functions/R_Postgres.R\",\n  # install and load\n  require = \"dplyr\",\n  # install but don't load these:\n  packages = c(\n    \"DBI\", \n    \"DiagrammeR\",\n    \"keyring\",\n    \"rgdal\", \n    \"RPostgreSQL\", \n    \"sp\",\n    \"terra\"\n  ),\n  params = \"tutos/castorExample/params.R\",  \n  times = list(start = 0, end = 20),\n  outputs = {\n    data.frame(objectName = c(\"harvestReport\",\n                              \"growingStockReport\"))\n  },\n  scenario = {\n    data.table(name = \"stsm_base_case\",\n               description = paste(\"Priority queue = oldest first. Adjacency constraint\",\n                                   \"= None. Includes roads (mst) and blocks (pre).\",\n                                   \"Harvest flow = 147,300 m3/year in decade 1, 133,500\",\n                                   \"m3/year in decade 2, 132,300 m3/year in decades 3 to\",\n                                   \"14 and 135,400 m3/year in decades 15 to 25.\",\n                                   \"Minimum harvest age = 80 and minimum harvest volume = 150\"))\n  },\n  harvestFlow = {\n    rbindlist(list(data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 1,\n                                                 to = 1, \n                                                 by = 1),\n                                            1), \n                              flow = 1473000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 2,\n                                                 to = 2, \n                                                 by = 1),\n                                            1), \n                              flow = 1335000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 3,\n                                                 to = 14, \n                                                 by = 1),\n                                            1), \n                              flow = 1323000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 15,\n                                                 to = 25, \n                                                 by = 1),\n                                            1), \n                              flow = 1354000, \n                              partition_type = 'live')  \n    ))\n  },\n  Restart = TRUE\n)\n\n# initialize simulation\ncastorInit &lt;- do.call(SpaDES.core::simInit, out)\n\ncastorInit &lt;- SpaDES.core::simInit(\n  times = out$times,\n  params = out$params,\n  modules = out$modules,\n  objects = list(scenario = out$scenario,\n                 harvestFlow = out$harvestFlow)\n)\n\n# inspect the `simList`\nSpaDES.core::params(castorInit)\nSpaDES.core::inputs(castorInit)\nSpaDES.core::outputs(castorInit)\nSpaDES.core::times(castorInit)\n\n# scheduled events\nSpaDES.core::events(castorInit)\n\n\n\nSpaDES.core::moduleDiagram(castorInit)\nSpaDES.core::objectDiagram(castorInit)\n\n\n\n\n\ncastorSim &lt;- SpaDES.core::spades(castorInit)\n\n# we now have outputs\nSpaDES.core::outputs(castorSim)\n\n\n\n\n\nSpaDES.core::completed(castorSim)\n\nmodules &lt;- c(\"dataCastor\",\n             \"growingStockCastor\",\n             \"forestryCastor\")\n\nout &lt;- setupProject(\n  paths = list(\"inputPath\" = \"modules/forestryCastor/inputs\",\n               \"outputPath\" = \"/R/scenarios/comparison_stsm/outputs\",\n               \"modulePath\" = \"modules/\",\n               \"cachePath\" = \"modules/forestryCastor\",\n               \"projectPath\" = \"~/SpaDES_book/castorExample/\"),\n  modules = modules,\n  functions = \"bcgov/castor@main/R/functions/R_Postgres.R\",\n  # install and load\n  require = \"dplyr\",\n  # install but don't load these:\n  packages = c(\n    \"DBI\",\n    \"keyring\",\n    \"rgdal\",\n    \"RPostgreSQL\",\n    \"sp\",\n    \"terra\"\n  ),\n  params = \"params.R\",\n  times = list(start = 0, end = 20),\n  outputs = {\n    data.frame(objectName = c(\"harvestReport\",\n                              \"growingStockReport\"))\n  },\n  scenario = {\n    data.table(name = \"stsm_base_case\",\n               description = paste(\"Priority queue = oldest first. Adjacency constraint\",\n                                   \"= None. Includes roads (mst) and blocks (pre).\",\n                                   \"Harvest flow = 147,300 m3/year in decade 1, 133,500\",\n                                   \"m3/year in decade 2, 132,300 m3/year in decades 3 to\",\n                                   \"14 and 135,400 m3/year in decades 15 to 25.\",\n                                   \"Minimum harvest age = 80 and minimum harvest volume = 150\"))\n  },\n  harvestFlow = {\n    rbindlist(list(data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ',\n                              period = rep( seq (from = 1,\n                                                 to = 1,\n                                                 by = 1),\n                                            1),\n                              flow = 1473000,\n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ',\n                              period = rep( seq (from = 2,\n                                                 to = 2,\n                                                 by = 1),\n                                            1),\n                              flow = 1335000,\n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ',\n                              period = rep( seq (from = 3,\n                                                 to = 14,\n                                                 by = 1),\n                                            1),\n                              flow = 1323000,\n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ',\n                              period = rep( seq (from = 15,\n                                                 to = 25,\n                                                 by = 1),\n                                            1),\n                              flow = 1354000,\n                              partition_type = 'live')\n    ))\n  },\n  Restart = TRUE\n)\n\n# initialize and run simulation in one go\ncastorSim2 &lt;- do.call(SpaDES.core::simInitAndSpades, out)",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Castor Workflow with `setupProject`</span>"
    ]
  },
  {
    "objectID": "castorExample.html#footnotes",
    "href": "castorExample.html#footnotes",
    "title": "17  Castor Workflow with setupProject",
    "section": "",
    "text": "SpaDES.project is currently being adapted to deal with modules nested in folders of GitHub repositories (instead of living in their own GitHub repositories). Hence, the code in this example is subject to changes in the near future.↩︎\nUsing the googledrive R package. See ?googledrive::drive_auth for more information.↩︎\nSee also Chapter 8.↩︎",
    "crumbs": [
      "SpaDES workflows and projects",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Castor Workflow with `setupProject`</span>"
    ]
  },
  {
    "objectID": "bestPractices.html",
    "href": "bestPractices.html",
    "title": "Best practices for \\(R^3T\\) workflows",
    "section": "",
    "text": "General best practices\n::: {.callout-tip collapse = “false” appearance=“simple”}\nNot a very useful comment (we can check ?lm to know what it does):\nCode\n# lm fits a linear model\nlm(biomass ~ height)\nA more useful comment:\nCode\n# model linear relationship between biomass and height\nlm(biomass ~ height)\n:::\n!Functions and modules as key tools for \\(R^3T\\), but also for building integrated and continuous workflows; McIntire et al. (2022)",
    "crumbs": [
      "Best practices for $R^3T$ workflows"
    ]
  },
  {
    "objectID": "bestPractices.html#general-best-practices",
    "href": "bestPractices.html#general-best-practices",
    "title": "Best practices for \\(R^3T\\) workflows",
    "section": "",
    "text": "Script, script, script – this means script everything you do, including package installation;\n“DOComment” your code – use comments that describe the intention of the code, not necessarily a code translation into human language:\n\n\n\n\n\n\n\n\nMinimize the number of software/languages used – the more jumps between languages/software the less robust and reproducible the workflow is. Remember: other users will need to install the same software and be able to the same jumps/operations that you did without you looking over their shoulder.\nModularise and “functionise” – avoid loooooong scripts, which are harder to read, learn and debug.\nSpaDES helps the modularisation part a great deal but it is still up to the developer to create functions and to decide what workflow components can/should be broken into separate modules or events;\nWhen using embedded module and event caching, think about what workflow steps can be cached to speed up development and re-runs and consider turning these into separate modules or events;\nConsider “packaging” your functions so they can be used across projects and SpaDES modules.\n\n\n\nCentralize workflow in a single script – this is quite intuitive when using SpaDES, as usually there is a “controller” script that sets up and runs the workflow.\nUse project-oriented and self-contained workflows – pick a structure that is self-explanatory and make sure that the project can be “moved” between users/machines without changing the code.\nDon’t use absolute paths – use relative paths (relative to project directory) – RStudio Projects and SpaDES.project do this automatically.\nYou can even install your R packages into project-level libraries, to allow for different package versions between projects in the same machine\nVersion control – great for collaboration, great for tracking changes, great to recover old versions of a project/code\nTest (!) – test your code and your workflow if you want them to endure and persist through time and users\nUse a combination of assertions, unit tests and integration tests1",
    "crumbs": [
      "Best practices for $R^3T$ workflows"
    ]
  },
  {
    "objectID": "bestPractices.html#best-practices-for-spades-workflows",
    "href": "bestPractices.html#best-practices-for-spades-workflows",
    "title": "Best practices for \\(R^3T\\) workflows",
    "section": "Best practices for SpaDES workflows",
    "text": "Best practices for SpaDES workflows\n\nlimit the number of objects in .GlobalEnv. Instead, put them in functions – such as with setupProject as arguments – or inside a module. When objects are in modules, you can add default object values (e.g. via .inputObjects), or save them into files that are loaded by setupProject or simInit. See\n\n\n\n\n\nWhy not? There are many reasons why things can get messed up with modelling in R… e.g., package dependency issues (especially version numbers that collide during development stages), internet availability, modules finding objects in the .GlobalEnv when they shouldn’t, etc… SpaDES.project::setupProject and simInit deal with these issues by loading and using namespaces/packages and objects directly into a separate environment (the simList).\nDon’t install packages “manually” and “separately” – script package installation in a reproducible way, i.e. that includes reference to package versions. Even better, let setupProject deal with package installation\nWhy not? When you have many modules, each with a list of packages it needs it will be hard to figure out what packages need to be installed or updated. setupProject was designed to deal with this issue using the Require package.\nDon’t pre-load packages – let simInit do it when the simulation is being initialized and only after it has asserted that packages are available and in the correct versions.\nWhy not? There are many reasons why things can get messed up with modelling in R… e.g., package dependency issues (especially version numbers that collide during development stages), internet availability. Pre-loading a package prevents it from being updated, which can make setupProject (and simInit) fail if they attempt to update a package to respect module requirements.",
    "crumbs": [
      "Best practices for $R^3T$ workflows"
    ]
  },
  {
    "objectID": "bestPractices.html#see-also",
    "href": "bestPractices.html#see-also",
    "title": "Best practices for \\(R^3T\\) workflows",
    "section": "See also",
    "text": "See also\nEFI’s reproducible forecasting workflows\nThe Practice of Reproducible Research\nAdvanced R - Style guide; by Hadley Wickham\nTypes of testing; by Codecov\nPaper by Sarma et al. (2016) on code testing\n\n\n\n\nSarma, Gopal P., Travis W. Jacobs, Mark D. Watts, S. Vahid Ghayoomie, Stephen D. Larson, and Richard C. Gerkin. 2016. “Unit Testing, Model Validation, and Biological Simulation.” F1000Research 5 (August): 1946. https://doi.org/10.12688/f1000research.9315.1.",
    "crumbs": [
      "Best practices for $R^3T$ workflows"
    ]
  },
  {
    "objectID": "bestPractices.html#footnotes",
    "href": "bestPractices.html#footnotes",
    "title": "Best practices for \\(R^3T\\) workflows",
    "section": "",
    "text": "Assertions and unit tests are smaller and generally test specific operations within a workflow (e.g. if (1 + x != 2) stop(\"there is an error\")) or things like object integrity (e.g. if (!is(x, \"data.frame\") stop(\"there is an error\")). Integration tests are larger in the sense that they test many components of a workflow and whether they work well together (they can also test an entire workflow)↩︎",
    "crumbs": [
      "Best practices for $R^3T$ workflows"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Barros, Ceres, Yong Luo, Alex M. Chubaty, Ian M. S. Eddy, Tatiane\nMicheletti, Céline Boisvenue, David W. Andison, Steven G. Cumming, and\nEliot J. B. McIntire. 2023. “Empowering Ecological Modellers with\na PERFICT Workflow: Seamlessly Linking Data, Parameterisation,\nPrediction, Validation and Visualisation.” Methods in Ecology\nand Evolution 14 (1): 173–88. https://doi.org/10.1111/2041-210X.14034.\n\n\nSarma, Gopal P., Travis W. Jacobs, Mark D. Watts, S. Vahid Ghayoomie,\nStephen D. Larson, and Richard C. Gerkin. 2016. “Unit Testing,\nModel Validation, and Biological Simulation.”\nF1000Research 5 (August): 1946. https://doi.org/10.12688/f1000research.9315.1.\n\n\nScheller, Robert M., and Brian R. Miranda. 2015. LANDIS-II Biomass\nSuccession V3.2 Extension  User Guide.",
    "crumbs": [
      "References"
    ]
  }
]